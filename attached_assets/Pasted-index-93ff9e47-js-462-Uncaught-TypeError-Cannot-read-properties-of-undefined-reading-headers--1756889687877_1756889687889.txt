index-93ff9e47.js:462 Uncaught TypeError: Cannot read properties of undefined (reading 'headers')
    at new E8 (index-93ff9e47.js:462:30767)
    at A8 (index-93ff9e47.js:462:33301)
    at index-93ff9e47.js:462:34013
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity),
        i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
}
)();
var Ye = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
function ho(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function ms(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.keys(t).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }),
    n
}
var kv = {
    exports: {}
}
  , rh = {}
  , Ev = {
    exports: {}
}
  , Le = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fc = Symbol.for("react.element")
  , v2 = Symbol.for("react.portal")
  , b2 = Symbol.for("react.fragment")
  , _2 = Symbol.for("react.strict_mode")
  , x2 = Symbol.for("react.profiler")
  , S2 = Symbol.for("react.provider")
  , k2 = Symbol.for("react.context")
  , E2 = Symbol.for("react.forward_ref")
  , A2 = Symbol.for("react.suspense")
  , I2 = Symbol.for("react.memo")
  , M2 = Symbol.for("react.lazy")
  , Wy = Symbol.iterator;
function T2(t) {
    return t === null || typeof t != "object" ? null : (t = Wy && t[Wy] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Av = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Iv = Object.assign
  , Mv = {};
function Pa(t, e, n) {
    this.props = t,
    this.context = e,
    this.refs = Mv,
    this.updater = n || Av
}
Pa.prototype.isReactComponent = {};
Pa.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
}
;
Pa.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function Tv() {}
Tv.prototype = Pa.prototype;
function Ug(t, e, n) {
    this.props = t,
    this.context = e,
    this.refs = Mv,
    this.updater = n || Av
}
var Wg = Ug.prototype = new Tv;
Wg.constructor = Ug;
Iv(Wg, Pa.prototype);
Wg.isPureReactComponent = !0;
var Fy = Array.isArray
  , Nv = Object.prototype.hasOwnProperty
  , Fg = {
    current: null
}
  , Cv = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Rv(t, e, n) {
    var r, i = {}, s = null, o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            Nv.call(e, r) && !Cv.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1)
        i.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        i.children = l
    }
    if (t && t.defaultProps)
        for (r in a = t.defaultProps,
        a)
            i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: fc,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: Fg.current
    }
}
function N2(t, e) {
    return {
        $$typeof: fc,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function $g(t) {
    return typeof t == "object" && t !== null && t.$$typeof === fc
}
function C2(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
        return e[n]
    })
}
var $y = /\/+/g;
function vf(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? C2("" + t.key) : e.toString(36)
}
function gu(t, e, n, r, i) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case fc:
            case v2:
                o = !0
            }
        }
    if (o)
        return o = t,
        i = i(o),
        t = r === "" ? "." + vf(o, 0) : r,
        Fy(i) ? (n = "",
        t != null && (n = t.replace($y, "$&/") + "/"),
        gu(i, e, n, "", function(c) {
            return c
        })) : i != null && ($g(i) && (i = N2(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace($y, "$&/") + "/") + t)),
        e.push(i)),
        1;
    if (o = 0,
    r = r === "" ? "." : r + ":",
    Fy(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var l = r + vf(s, a);
            o += gu(s, e, n, l, i)
        }
    else if (l = T2(t),
    typeof l == "function")
        for (t = l.call(t),
        a = 0; !(s = t.next()).done; )
            s = s.value,
            l = r + vf(s, a++),
            o += gu(s, e, n, l, i);
    else if (s === "object")
        throw e = String(t),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Oc(t, e, n) {
    if (t == null)
        return t;
    var r = []
      , i = 0;
    return gu(t, r, "", "", function(s) {
        return e.call(n, s, i++)
    }),
    r
}
function R2(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(),
        e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = n)
        }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = n)
        }),
        t._status === -1 && (t._status = 0,
        t._result = e)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var Dn = {
    current: null
}
  , mu = {
    transition: null
}
  , L2 = {
    ReactCurrentDispatcher: Dn,
    ReactCurrentBatchConfig: mu,
    ReactCurrentOwner: Fg
};
function Lv() {
    throw Error("act(...) is not supported in production builds of React.")
}
Le.Children = {
    map: Oc,
    forEach: function(t, e, n) {
        Oc(t, function() {
            e.apply(this, arguments)
        }, n)
    },
    count: function(t) {
        var e = 0;
        return Oc(t, function() {
            e++
        }),
        e
    },
    toArray: function(t) {
        return Oc(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!$g(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Le.Component = Pa;
Le.Fragment = b2;
Le.Profiler = x2;
Le.PureComponent = Ug;
Le.StrictMode = _2;
Le.Suspense = A2;
Le.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L2;
Le.act = Lv;
Le.cloneElement = function(t, e, n) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = Iv({}, t.props)
      , i = t.key
      , s = t.ref
      , o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = Fg.current),
        e.key !== void 0 && (i = "" + e.key),
        t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
        for (l in e)
            Nv.call(e, l) && !Cv.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        r.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: fc,
        type: t.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
}
;
Le.createContext = function(t) {
    return t = {
        $$typeof: k2,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: S2,
        _context: t
    },
    t.Consumer = t
}
;
Le.createElement = Rv;
Le.createFactory = function(t) {
    var e = Rv.bind(null, t);
    return e.type = t,
    e
}
;
Le.createRef = function() {
    return {
        current: null
    }
}
;
Le.forwardRef = function(t) {
    return {
        $$typeof: E2,
        render: t
    }
}
;
Le.isValidElement = $g;
Le.lazy = function(t) {
    return {
        $$typeof: M2,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: R2
    }
}
;
Le.memo = function(t, e) {
    return {
        $$typeof: I2,
        type: t,
        compare: e === void 0 ? null : e
    }
}
;
Le.startTransition = function(t) {
    var e = mu.transition;
    mu.transition = {};
    try {
        t()
    } finally {
        mu.transition = e
    }
}
;
Le.unstable_act = Lv;
Le.useCallback = function(t, e) {
    return Dn.current.useCallback(t, e)
}
;
Le.useContext = function(t) {
    return Dn.current.useContext(t)
}
;
Le.useDebugValue = function() {}
;
Le.useDeferredValue = function(t) {
    return Dn.current.useDeferredValue(t)
}
;
Le.useEffect = function(t, e) {
    return Dn.current.useEffect(t, e)
}
;
Le.useId = function() {
    return Dn.current.useId()
}
;
Le.useImperativeHandle = function(t, e, n) {
    return Dn.current.useImperativeHandle(t, e, n)
}
;
Le.useInsertionEffect = function(t, e) {
    return Dn.current.useInsertionEffect(t, e)
}
;
Le.useLayoutEffect = function(t, e) {
    return Dn.current.useLayoutEffect(t, e)
}
;
Le.useMemo = function(t, e) {
    return Dn.current.useMemo(t, e)
}
;
Le.useReducer = function(t, e, n) {
    return Dn.current.useReducer(t, e, n)
}
;
Le.useRef = function(t) {
    return Dn.current.useRef(t)
}
;
Le.useState = function(t) {
    return Dn.current.useState(t)
}
;
Le.useSyncExternalStore = function(t, e, n) {
    return Dn.current.useSyncExternalStore(t, e, n)
}
;
Le.useTransition = function() {
    return Dn.current.useTransition()
}
;
Le.version = "18.3.1";
Ev.exports = Le;
var Y = Ev.exports;
const J = ho(Y);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var j2 = Y
  , B2 = Symbol.for("react.element")
  , P2 = Symbol.for("react.fragment")
  , O2 = Object.prototype.hasOwnProperty
  , D2 = j2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , z2 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function jv(t, e, n) {
    var r, i = {}, s = null, o = null;
    n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (r in e)
        O2.call(e, r) && !z2.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
        for (r in e = t.defaultProps,
        e)
            i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: B2,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: D2.current
    }
}
rh.Fragment = P2;
rh.jsx = jv;
rh.jsxs = jv;
kv.exports = rh;
var S = kv.exports
  , pe = {}
  , ih = {};
ih.byteLength = F2;
ih.toByteArray = K2;
ih.fromByteArray = q2;
var Kr = []
  , pr = []
  , U2 = typeof Uint8Array < "u" ? Uint8Array : Array
  , bf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var xo = 0, W2 = bf.length; xo < W2; ++xo)
    Kr[xo] = bf[xo],
    pr[bf.charCodeAt(xo)] = xo;
pr["-".charCodeAt(0)] = 62;
pr["_".charCodeAt(0)] = 63;
function Bv(t) {
    var e = t.length;
    if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [n, r]
}
function F2(t) {
    var e = Bv(t)
      , n = e[0]
      , r = e[1];
    return (n + r) * 3 / 4 - r
}
function $2(t, e, n) {
    return (e + n) * 3 / 4 - n
}
function K2(t) {
    var e, n = Bv(t), r = n[0], i = n[1], s = new U2($2(t, r, i)), o = 0, a = i > 0 ? r - 4 : r, l;
    for (l = 0; l < a; l += 4)
        e = pr[t.charCodeAt(l)] << 18 | pr[t.charCodeAt(l + 1)] << 12 | pr[t.charCodeAt(l + 2)] << 6 | pr[t.charCodeAt(l + 3)],
        s[o++] = e >> 16 & 255,
        s[o++] = e >> 8 & 255,
        s[o++] = e & 255;
    return i === 2 && (e = pr[t.charCodeAt(l)] << 2 | pr[t.charCodeAt(l + 1)] >> 4,
    s[o++] = e & 255),
    i === 1 && (e = pr[t.charCodeAt(l)] << 10 | pr[t.charCodeAt(l + 1)] << 4 | pr[t.charCodeAt(l + 2)] >> 2,
    s[o++] = e >> 8 & 255,
    s[o++] = e & 255),
    s
}
function V2(t) {
    return Kr[t >> 18 & 63] + Kr[t >> 12 & 63] + Kr[t >> 6 & 63] + Kr[t & 63]
}
function H2(t, e, n) {
    for (var r, i = [], s = e; s < n; s += 3)
        r = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255),
        i.push(V2(r));
    return i.join("")
}
function q2(t) {
    for (var e, n = t.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
        i.push(H2(t, o, o + s > a ? a : o + s));
    return r === 1 ? (e = t[n - 1],
    i.push(Kr[e >> 2] + Kr[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1],
    i.push(Kr[e >> 10] + Kr[e >> 4 & 63] + Kr[e << 2 & 63] + "=")),
    i.join("")
}
var Kg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Kg.read = function(t, e, n, r, i) {
    var s, o, a = i * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, d = -7, h = n ? i - 1 : 0, y = n ? -1 : 1, m = t[e + h];
    for (h += y,
    s = m & (1 << -d) - 1,
    m >>= -d,
    d += a; d > 0; s = s * 256 + t[e + h],
    h += y,
    d -= 8)
        ;
    for (o = s & (1 << -d) - 1,
    s >>= -d,
    d += r; d > 0; o = o * 256 + t[e + h],
    h += y,
    d -= 8)
        ;
    if (s === 0)
        s = 1 - c;
    else {
        if (s === l)
            return o ? NaN : (m ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, r),
        s = s - c
    }
    return (m ? -1 : 1) * o * Math.pow(2, s - r)
}
;
Kg.write = function(t, e, n, r, i, s) {
    var o, a, l, c = s * 8 - i - 1, d = (1 << c) - 1, h = d >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = r ? 0 : s - 1, v = r ? 1 : -1, E = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e),
    isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
    o = d) : (o = Math.floor(Math.log(e) / Math.LN2),
    e * (l = Math.pow(2, -o)) < 1 && (o--,
    l *= 2),
    o + h >= 1 ? e += y / l : e += y * Math.pow(2, 1 - h),
    e * l >= 2 && (o++,
    l /= 2),
    o + h >= d ? (a = 0,
    o = d) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
    o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i),
    o = 0)); i >= 8; t[n + m] = a & 255,
    m += v,
    a /= 256,
    i -= 8)
        ;
    for (o = o << i | a,
    c += i; c > 0; t[n + m] = o & 255,
    m += v,
    o /= 256,
    c -= 8)
        ;
    t[n + m - v] |= E * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = ih
      , n = Kg
      , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a,
    t.SlowBuffer = x,
    t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i,
    a.TYPED_ARRAY_SUPPORT = s(),
    !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
        try {
            const M = new Uint8Array(1)
              , f = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(f, Uint8Array.prototype),
            Object.setPrototypeOf(M, f),
            M.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.byteOffset
        }
    });
    function o(M) {
        if (M > i)
            throw new RangeError('The value "' + M + '" is invalid for option "size"');
        const f = new Uint8Array(M);
        return Object.setPrototypeOf(f, a.prototype),
        f
    }
    function a(M, f, w) {
        if (typeof M == "number") {
            if (typeof f == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return h(M)
        }
        return l(M, f, w)
    }
    a.poolSize = 8192;
    function l(M, f, w) {
        if (typeof M == "string")
            return y(M, f);
        if (ArrayBuffer.isView(M))
            return v(M);
        if (M == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M);
        if (Qn(M, ArrayBuffer) || M && Qn(M.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Qn(M, SharedArrayBuffer) || M && Qn(M.buffer, SharedArrayBuffer)))
            return E(M, f, w);
        if (typeof M == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const j = M.valueOf && M.valueOf();
        if (j != null && j !== M)
            return a.from(j, f, w);
        const U = A(M);
        if (U)
            return U;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof M[Symbol.toPrimitive] == "function")
            return a.from(M[Symbol.toPrimitive]("string"), f, w);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M)
    }
    a.from = function(M, f, w) {
        return l(M, f, w)
    }
    ,
    Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(a, Uint8Array);
    function c(M) {
        if (typeof M != "number")
            throw new TypeError('"size" argument must be of type number');
        if (M < 0)
            throw new RangeError('The value "' + M + '" is invalid for option "size"')
    }
    function d(M, f, w) {
        return c(M),
        M <= 0 ? o(M) : f !== void 0 ? typeof w == "string" ? o(M).fill(f, w) : o(M).fill(f) : o(M)
    }
    a.alloc = function(M, f, w) {
        return d(M, f, w)
    }
    ;
    function h(M) {
        return c(M),
        o(M < 0 ? 0 : _(M) | 0)
    }
    a.allocUnsafe = function(M) {
        return h(M)
    }
    ,
    a.allocUnsafeSlow = function(M) {
        return h(M)
    }
    ;
    function y(M, f) {
        if ((typeof f != "string" || f === "") && (f = "utf8"),
        !a.isEncoding(f))
            throw new TypeError("Unknown encoding: " + f);
        const w = b(M, f) | 0;
        let j = o(w);
        const U = j.write(M, f);
        return U !== w && (j = j.slice(0, U)),
        j
    }
    function m(M) {
        const f = M.length < 0 ? 0 : _(M.length) | 0
          , w = o(f);
        for (let j = 0; j < f; j += 1)
            w[j] = M[j] & 255;
        return w
    }
    function v(M) {
        if (Qn(M, Uint8Array)) {
            const f = new Uint8Array(M);
            return E(f.buffer, f.byteOffset, f.byteLength)
        }
        return m(M)
    }
    function E(M, f, w) {
        if (f < 0 || M.byteLength < f)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (M.byteLength < f + (w || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let j;
        return f === void 0 && w === void 0 ? j = new Uint8Array(M) : w === void 0 ? j = new Uint8Array(M,f) : j = new Uint8Array(M,f,w),
        Object.setPrototypeOf(j, a.prototype),
        j
    }
    function A(M) {
        if (a.isBuffer(M)) {
            const f = _(M.length) | 0
              , w = o(f);
            return w.length === 0 || M.copy(w, 0, 0, f),
            w
        }
        if (M.length !== void 0)
            return typeof M.length != "number" || ct(M.length) ? o(0) : m(M);
        if (M.type === "Buffer" && Array.isArray(M.data))
            return m(M.data)
    }
    function _(M) {
        if (M >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return M | 0
    }
    function x(M) {
        return +M != M && (M = 0),
        a.alloc(+M)
    }
    a.isBuffer = function(f) {
        return f != null && f._isBuffer === !0 && f !== a.prototype
    }
    ,
    a.compare = function(f, w) {
        if (Qn(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        Qn(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)),
        !a.isBuffer(f) || !a.isBuffer(w))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (f === w)
            return 0;
        let j = f.length
          , U = w.length;
        for (let $ = 0, q = Math.min(j, U); $ < q; ++$)
            if (f[$] !== w[$]) {
                j = f[$],
                U = w[$];
                break
            }
        return j < U ? -1 : U < j ? 1 : 0
    }
    ,
    a.isEncoding = function(f) {
        switch (String(f).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    a.concat = function(f, w) {
        if (!Array.isArray(f))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (f.length === 0)
            return a.alloc(0);
        let j;
        if (w === void 0)
            for (w = 0,
            j = 0; j < f.length; ++j)
                w += f[j].length;
        const U = a.allocUnsafe(w);
        let $ = 0;
        for (j = 0; j < f.length; ++j) {
            let q = f[j];
            if (Qn(q, Uint8Array))
                $ + q.length > U.length ? (a.isBuffer(q) || (q = a.from(q)),
                q.copy(U, $)) : Uint8Array.prototype.set.call(U, q, $);
            else if (a.isBuffer(q))
                q.copy(U, $);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            $ += q.length
        }
        return U
    }
    ;
    function b(M, f) {
        if (a.isBuffer(M))
            return M.length;
        if (ArrayBuffer.isView(M) || Qn(M, ArrayBuffer))
            return M.byteLength;
        if (typeof M != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof M);
        const w = M.length
          , j = arguments.length > 2 && arguments[2] === !0;
        if (!j && w === 0)
            return 0;
        let U = !1;
        for (; ; )
            switch (f) {
            case "ascii":
            case "latin1":
            case "binary":
                return w;
            case "utf8":
            case "utf-8":
                return lt(M).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return w * 2;
            case "hex":
                return w >>> 1;
            case "base64":
                return dt(M).length;
            default:
                if (U)
                    return j ? -1 : lt(M).length;
                f = ("" + f).toLowerCase(),
                U = !0
            }
    }
    a.byteLength = b;
    function R(M, f, w) {
        let j = !1;
        if ((f === void 0 || f < 0) && (f = 0),
        f > this.length || ((w === void 0 || w > this.length) && (w = this.length),
        w <= 0) || (w >>>= 0,
        f >>>= 0,
        w <= f))
            return "";
        for (M || (M = "utf8"); ; )
            switch (M) {
            case "hex":
                return L(this, f, w);
            case "utf8":
            case "utf-8":
                return u(this, f, w);
            case "ascii":
                return C(this, f, w);
            case "latin1":
            case "binary":
                return I(this, f, w);
            case "base64":
                return T(this, f, w);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return P(this, f, w);
            default:
                if (j)
                    throw new TypeError("Unknown encoding: " + M);
                M = (M + "").toLowerCase(),
                j = !0
            }
    }
    a.prototype._isBuffer = !0;
    function O(M, f, w) {
        const j = M[f];
        M[f] = M[w],
        M[w] = j
    }
    a.prototype.swap16 = function() {
        const f = this.length;
        if (f % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let w = 0; w < f; w += 2)
            O(this, w, w + 1);
        return this
    }
    ,
    a.prototype.swap32 = function() {
        const f = this.length;
        if (f % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let w = 0; w < f; w += 4)
            O(this, w, w + 3),
            O(this, w + 1, w + 2);
        return this
    }
    ,
    a.prototype.swap64 = function() {
        const f = this.length;
        if (f % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let w = 0; w < f; w += 8)
            O(this, w, w + 7),
            O(this, w + 1, w + 6),
            O(this, w + 2, w + 5),
            O(this, w + 3, w + 4);
        return this
    }
    ,
    a.prototype.toString = function() {
        const f = this.length;
        return f === 0 ? "" : arguments.length === 0 ? u(this, 0, f) : R.apply(this, arguments)
    }
    ,
    a.prototype.toLocaleString = a.prototype.toString,
    a.prototype.equals = function(f) {
        if (!a.isBuffer(f))
            throw new TypeError("Argument must be a Buffer");
        return this === f ? !0 : a.compare(this, f) === 0
    }
    ,
    a.prototype.inspect = function() {
        let f = "";
        const w = t.INSPECT_MAX_BYTES;
        return f = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(),
        this.length > w && (f += " ... "),
        "<Buffer " + f + ">"
    }
    ,
    r && (a.prototype[r] = a.prototype.inspect),
    a.prototype.compare = function(f, w, j, U, $) {
        if (Qn(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        !a.isBuffer(f))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof f);
        if (w === void 0 && (w = 0),
        j === void 0 && (j = f ? f.length : 0),
        U === void 0 && (U = 0),
        $ === void 0 && ($ = this.length),
        w < 0 || j > f.length || U < 0 || $ > this.length)
            throw new RangeError("out of range index");
        if (U >= $ && w >= j)
            return 0;
        if (U >= $)
            return -1;
        if (w >= j)
            return 1;
        if (w >>>= 0,
        j >>>= 0,
        U >>>= 0,
        $ >>>= 0,
        this === f)
            return 0;
        let q = $ - U
          , Ee = j - w;
        const Se = Math.min(q, Ee)
          , be = this.slice(U, $)
          , rt = f.slice(w, j);
        for (let we = 0; we < Se; ++we)
            if (be[we] !== rt[we]) {
                q = be[we],
                Ee = rt[we];
                break
            }
        return q < Ee ? -1 : Ee < q ? 1 : 0
    }
    ;
    function D(M, f, w, j, U) {
        if (M.length === 0)
            return -1;
        if (typeof w == "string" ? (j = w,
        w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648),
        w = +w,
        ct(w) && (w = U ? 0 : M.length - 1),
        w < 0 && (w = M.length + w),
        w >= M.length) {
            if (U)
                return -1;
            w = M.length - 1
        } else if (w < 0)
            if (U)
                w = 0;
            else
                return -1;
        if (typeof f == "string" && (f = a.from(f, j)),
        a.isBuffer(f))
            return f.length === 0 ? -1 : z(M, f, w, j, U);
        if (typeof f == "number")
            return f = f & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(M, f, w) : Uint8Array.prototype.lastIndexOf.call(M, f, w) : z(M, [f], w, j, U);
        throw new TypeError("val must be string, number or Buffer")
    }
    function z(M, f, w, j, U) {
        let $ = 1
          , q = M.length
          , Ee = f.length;
        if (j !== void 0 && (j = String(j).toLowerCase(),
        j === "ucs2" || j === "ucs-2" || j === "utf16le" || j === "utf-16le")) {
            if (M.length < 2 || f.length < 2)
                return -1;
            $ = 2,
            q /= 2,
            Ee /= 2,
            w /= 2
        }
        function Se(rt, we) {
            return $ === 1 ? rt[we] : rt.readUInt16BE(we * $)
        }
        let be;
        if (U) {
            let rt = -1;
            for (be = w; be < q; be++)
                if (Se(M, be) === Se(f, rt === -1 ? 0 : be - rt)) {
                    if (rt === -1 && (rt = be),
                    be - rt + 1 === Ee)
                        return rt * $
                } else
                    rt !== -1 && (be -= be - rt),
                    rt = -1
        } else
            for (w + Ee > q && (w = q - Ee),
            be = w; be >= 0; be--) {
                let rt = !0;
                for (let we = 0; we < Ee; we++)
                    if (Se(M, be + we) !== Se(f, we)) {
                        rt = !1;
                        break
                    }
                if (rt)
                    return be
            }
        return -1
    }
    a.prototype.includes = function(f, w, j) {
        return this.indexOf(f, w, j) !== -1
    }
    ,
    a.prototype.indexOf = function(f, w, j) {
        return D(this, f, w, j, !0)
    }
    ,
    a.prototype.lastIndexOf = function(f, w, j) {
        return D(this, f, w, j, !1)
    }
    ;
    function K(M, f, w, j) {
        w = Number(w) || 0;
        const U = M.length - w;
        j ? (j = Number(j),
        j > U && (j = U)) : j = U;
        const $ = f.length;
        j > $ / 2 && (j = $ / 2);
        let q;
        for (q = 0; q < j; ++q) {
            const Ee = parseInt(f.substr(q * 2, 2), 16);
            if (ct(Ee))
                return q;
            M[w + q] = Ee
        }
        return q
    }
    function F(M, f, w, j) {
        return nt(lt(f, M.length - w), M, w, j)
    }
    function G(M, f, w, j) {
        return nt(_t(f), M, w, j)
    }
    function Z(M, f, w, j) {
        return nt(dt(f), M, w, j)
    }
    function X(M, f, w, j) {
        return nt(Pc(f, M.length - w), M, w, j)
    }
    a.prototype.write = function(f, w, j, U) {
        if (w === void 0)
            U = "utf8",
            j = this.length,
            w = 0;
        else if (j === void 0 && typeof w == "string")
            U = w,
            j = this.length,
            w = 0;
        else if (isFinite(w))
            w = w >>> 0,
            isFinite(j) ? (j = j >>> 0,
            U === void 0 && (U = "utf8")) : (U = j,
            j = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const $ = this.length - w;
        if ((j === void 0 || j > $) && (j = $),
        f.length > 0 && (j < 0 || w < 0) || w > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        U || (U = "utf8");
        let q = !1;
        for (; ; )
            switch (U) {
            case "hex":
                return K(this, f, w, j);
            case "utf8":
            case "utf-8":
                return F(this, f, w, j);
            case "ascii":
            case "latin1":
            case "binary":
                return G(this, f, w, j);
            case "base64":
                return Z(this, f, w, j);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return X(this, f, w, j);
            default:
                if (q)
                    throw new TypeError("Unknown encoding: " + U);
                U = ("" + U).toLowerCase(),
                q = !0
            }
    }
    ,
    a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function T(M, f, w) {
        return f === 0 && w === M.length ? e.fromByteArray(M) : e.fromByteArray(M.slice(f, w))
    }
    function u(M, f, w) {
        w = Math.min(M.length, w);
        const j = [];
        let U = f;
        for (; U < w; ) {
            const $ = M[U];
            let q = null
              , Ee = $ > 239 ? 4 : $ > 223 ? 3 : $ > 191 ? 2 : 1;
            if (U + Ee <= w) {
                let Se, be, rt, we;
                switch (Ee) {
                case 1:
                    $ < 128 && (q = $);
                    break;
                case 2:
                    Se = M[U + 1],
                    (Se & 192) === 128 && (we = ($ & 31) << 6 | Se & 63,
                    we > 127 && (q = we));
                    break;
                case 3:
                    Se = M[U + 1],
                    be = M[U + 2],
                    (Se & 192) === 128 && (be & 192) === 128 && (we = ($ & 15) << 12 | (Se & 63) << 6 | be & 63,
                    we > 2047 && (we < 55296 || we > 57343) && (q = we));
                    break;
                case 4:
                    Se = M[U + 1],
                    be = M[U + 2],
                    rt = M[U + 3],
                    (Se & 192) === 128 && (be & 192) === 128 && (rt & 192) === 128 && (we = ($ & 15) << 18 | (Se & 63) << 12 | (be & 63) << 6 | rt & 63,
                    we > 65535 && we < 1114112 && (q = we))
                }
            }
            q === null ? (q = 65533,
            Ee = 1) : q > 65535 && (q -= 65536,
            j.push(q >>> 10 & 1023 | 55296),
            q = 56320 | q & 1023),
            j.push(q),
            U += Ee
        }
        return k(j)
    }
    const p = 4096;
    function k(M) {
        const f = M.length;
        if (f <= p)
            return String.fromCharCode.apply(String, M);
        let w = ""
          , j = 0;
        for (; j < f; )
            w += String.fromCharCode.apply(String, M.slice(j, j += p));
        return w
    }
    function C(M, f, w) {
        let j = "";
        w = Math.min(M.length, w);
        for (let U = f; U < w; ++U)
            j += String.fromCharCode(M[U] & 127);
        return j
    }
    function I(M, f, w) {
        let j = "";
        w = Math.min(M.length, w);
        for (let U = f; U < w; ++U)
            j += String.fromCharCode(M[U]);
        return j
    }
    function L(M, f, w) {
        const j = M.length;
        (!f || f < 0) && (f = 0),
        (!w || w < 0 || w > j) && (w = j);
        let U = "";
        for (let $ = f; $ < w; ++$)
            U += xt[M[$]];
        return U
    }
    function P(M, f, w) {
        const j = M.slice(f, w);
        let U = "";
        for (let $ = 0; $ < j.length - 1; $ += 2)
            U += String.fromCharCode(j[$] + j[$ + 1] * 256);
        return U
    }
    a.prototype.slice = function(f, w) {
        const j = this.length;
        f = ~~f,
        w = w === void 0 ? j : ~~w,
        f < 0 ? (f += j,
        f < 0 && (f = 0)) : f > j && (f = j),
        w < 0 ? (w += j,
        w < 0 && (w = 0)) : w > j && (w = j),
        w < f && (w = f);
        const U = this.subarray(f, w);
        return Object.setPrototypeOf(U, a.prototype),
        U
    }
    ;
    function N(M, f, w) {
        if (M % 1 !== 0 || M < 0)
            throw new RangeError("offset is not uint");
        if (M + f > w)
            throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(f, w, j) {
        f = f >>> 0,
        w = w >>> 0,
        j || N(f, w, this.length);
        let U = this[f]
          , $ = 1
          , q = 0;
        for (; ++q < w && ($ *= 256); )
            U += this[f + q] * $;
        return U
    }
    ,
    a.prototype.readUintBE = a.prototype.readUIntBE = function(f, w, j) {
        f = f >>> 0,
        w = w >>> 0,
        j || N(f, w, this.length);
        let U = this[f + --w]
          , $ = 1;
        for (; w > 0 && ($ *= 256); )
            U += this[f + --w] * $;
        return U
    }
    ,
    a.prototype.readUint8 = a.prototype.readUInt8 = function(f, w) {
        return f = f >>> 0,
        w || N(f, 1, this.length),
        this[f]
    }
    ,
    a.prototype.readUint16LE = a.prototype.readUInt16LE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 2, this.length),
        this[f] | this[f + 1] << 8
    }
    ,
    a.prototype.readUint16BE = a.prototype.readUInt16BE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 2, this.length),
        this[f] << 8 | this[f + 1]
    }
    ,
    a.prototype.readUint32LE = a.prototype.readUInt32LE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        (this[f] | this[f + 1] << 8 | this[f + 2] << 16) + this[f + 3] * 16777216
    }
    ,
    a.prototype.readUint32BE = a.prototype.readUInt32BE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        this[f] * 16777216 + (this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3])
    }
    ,
    a.prototype.readBigUInt64LE = Sr(function(f) {
        f = f >>> 0,
        fr(f, "offset");
        const w = this[f]
          , j = this[f + 7];
        (w === void 0 || j === void 0) && Qe(f, this.length - 8);
        const U = w + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24
          , $ = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + j * 2 ** 24;
        return BigInt(U) + (BigInt($) << BigInt(32))
    }),
    a.prototype.readBigUInt64BE = Sr(function(f) {
        f = f >>> 0,
        fr(f, "offset");
        const w = this[f]
          , j = this[f + 7];
        (w === void 0 || j === void 0) && Qe(f, this.length - 8);
        const U = w * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f]
          , $ = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + j;
        return (BigInt(U) << BigInt(32)) + BigInt($)
    }),
    a.prototype.readIntLE = function(f, w, j) {
        f = f >>> 0,
        w = w >>> 0,
        j || N(f, w, this.length);
        let U = this[f]
          , $ = 1
          , q = 0;
        for (; ++q < w && ($ *= 256); )
            U += this[f + q] * $;
        return $ *= 128,
        U >= $ && (U -= Math.pow(2, 8 * w)),
        U
    }
    ,
    a.prototype.readIntBE = function(f, w, j) {
        f = f >>> 0,
        w = w >>> 0,
        j || N(f, w, this.length);
        let U = w
          , $ = 1
          , q = this[f + --U];
        for (; U > 0 && ($ *= 256); )
            q += this[f + --U] * $;
        return $ *= 128,
        q >= $ && (q -= Math.pow(2, 8 * w)),
        q
    }
    ,
    a.prototype.readInt8 = function(f, w) {
        return f = f >>> 0,
        w || N(f, 1, this.length),
        this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f]
    }
    ,
    a.prototype.readInt16LE = function(f, w) {
        f = f >>> 0,
        w || N(f, 2, this.length);
        const j = this[f] | this[f + 1] << 8;
        return j & 32768 ? j | 4294901760 : j
    }
    ,
    a.prototype.readInt16BE = function(f, w) {
        f = f >>> 0,
        w || N(f, 2, this.length);
        const j = this[f + 1] | this[f] << 8;
        return j & 32768 ? j | 4294901760 : j
    }
    ,
    a.prototype.readInt32LE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        this[f] | this[f + 1] << 8 | this[f + 2] << 16 | this[f + 3] << 24
    }
    ,
    a.prototype.readInt32BE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        this[f] << 24 | this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3]
    }
    ,
    a.prototype.readBigInt64LE = Sr(function(f) {
        f = f >>> 0,
        fr(f, "offset");
        const w = this[f]
          , j = this[f + 7];
        (w === void 0 || j === void 0) && Qe(f, this.length - 8);
        const U = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (j << 24);
        return (BigInt(U) << BigInt(32)) + BigInt(w + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24)
    }),
    a.prototype.readBigInt64BE = Sr(function(f) {
        f = f >>> 0,
        fr(f, "offset");
        const w = this[f]
          , j = this[f + 7];
        (w === void 0 || j === void 0) && Qe(f, this.length - 8);
        const U = (w << 24) + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f];
        return (BigInt(U) << BigInt(32)) + BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + j)
    }),
    a.prototype.readFloatLE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        n.read(this, f, !0, 23, 4)
    }
    ,
    a.prototype.readFloatBE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 4, this.length),
        n.read(this, f, !1, 23, 4)
    }
    ,
    a.prototype.readDoubleLE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 8, this.length),
        n.read(this, f, !0, 52, 8)
    }
    ,
    a.prototype.readDoubleBE = function(f, w) {
        return f = f >>> 0,
        w || N(f, 8, this.length),
        n.read(this, f, !1, 52, 8)
    }
    ;
    function g(M, f, w, j, U, $) {
        if (!a.isBuffer(M))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (f > U || f < $)
            throw new RangeError('"value" argument is out of bounds');
        if (w + j > M.length)
            throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(f, w, j, U) {
        if (f = +f,
        w = w >>> 0,
        j = j >>> 0,
        !U) {
            const Ee = Math.pow(2, 8 * j) - 1;
            g(this, f, w, j, Ee, 0)
        }
        let $ = 1
          , q = 0;
        for (this[w] = f & 255; ++q < j && ($ *= 256); )
            this[w + q] = f / $ & 255;
        return w + j
    }
    ,
    a.prototype.writeUintBE = a.prototype.writeUIntBE = function(f, w, j, U) {
        if (f = +f,
        w = w >>> 0,
        j = j >>> 0,
        !U) {
            const Ee = Math.pow(2, 8 * j) - 1;
            g(this, f, w, j, Ee, 0)
        }
        let $ = j - 1
          , q = 1;
        for (this[w + $] = f & 255; --$ >= 0 && (q *= 256); )
            this[w + $] = f / q & 255;
        return w + j
    }
    ,
    a.prototype.writeUint8 = a.prototype.writeUInt8 = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 1, 255, 0),
        this[w] = f & 255,
        w + 1
    }
    ,
    a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 2, 65535, 0),
        this[w] = f & 255,
        this[w + 1] = f >>> 8,
        w + 2
    }
    ,
    a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 2, 65535, 0),
        this[w] = f >>> 8,
        this[w + 1] = f & 255,
        w + 2
    }
    ,
    a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 4, 4294967295, 0),
        this[w + 3] = f >>> 24,
        this[w + 2] = f >>> 16,
        this[w + 1] = f >>> 8,
        this[w] = f & 255,
        w + 4
    }
    ,
    a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 4, 4294967295, 0),
        this[w] = f >>> 24,
        this[w + 1] = f >>> 16,
        this[w + 2] = f >>> 8,
        this[w + 3] = f & 255,
        w + 4
    }
    ;
    function B(M, f, w, j, U) {
        Ze(f, j, U, M, w, 7);
        let $ = Number(f & BigInt(4294967295));
        M[w++] = $,
        $ = $ >> 8,
        M[w++] = $,
        $ = $ >> 8,
        M[w++] = $,
        $ = $ >> 8,
        M[w++] = $;
        let q = Number(f >> BigInt(32) & BigInt(4294967295));
        return M[w++] = q,
        q = q >> 8,
        M[w++] = q,
        q = q >> 8,
        M[w++] = q,
        q = q >> 8,
        M[w++] = q,
        w
    }
    function ie(M, f, w, j, U) {
        Ze(f, j, U, M, w, 7);
        let $ = Number(f & BigInt(4294967295));
        M[w + 7] = $,
        $ = $ >> 8,
        M[w + 6] = $,
        $ = $ >> 8,
        M[w + 5] = $,
        $ = $ >> 8,
        M[w + 4] = $;
        let q = Number(f >> BigInt(32) & BigInt(4294967295));
        return M[w + 3] = q,
        q = q >> 8,
        M[w + 2] = q,
        q = q >> 8,
        M[w + 1] = q,
        q = q >> 8,
        M[w] = q,
        w + 8
    }
    a.prototype.writeBigUInt64LE = Sr(function(f, w=0) {
        return B(this, f, w, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeBigUInt64BE = Sr(function(f, w=0) {
        return ie(this, f, w, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeIntLE = function(f, w, j, U) {
        if (f = +f,
        w = w >>> 0,
        !U) {
            const Se = Math.pow(2, 8 * j - 1);
            g(this, f, w, j, Se - 1, -Se)
        }
        let $ = 0
          , q = 1
          , Ee = 0;
        for (this[w] = f & 255; ++$ < j && (q *= 256); )
            f < 0 && Ee === 0 && this[w + $ - 1] !== 0 && (Ee = 1),
            this[w + $] = (f / q >> 0) - Ee & 255;
        return w + j
    }
    ,
    a.prototype.writeIntBE = function(f, w, j, U) {
        if (f = +f,
        w = w >>> 0,
        !U) {
            const Se = Math.pow(2, 8 * j - 1);
            g(this, f, w, j, Se - 1, -Se)
        }
        let $ = j - 1
          , q = 1
          , Ee = 0;
        for (this[w + $] = f & 255; --$ >= 0 && (q *= 256); )
            f < 0 && Ee === 0 && this[w + $ + 1] !== 0 && (Ee = 1),
            this[w + $] = (f / q >> 0) - Ee & 255;
        return w + j
    }
    ,
    a.prototype.writeInt8 = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 1, 127, -128),
        f < 0 && (f = 255 + f + 1),
        this[w] = f & 255,
        w + 1
    }
    ,
    a.prototype.writeInt16LE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 2, 32767, -32768),
        this[w] = f & 255,
        this[w + 1] = f >>> 8,
        w + 2
    }
    ,
    a.prototype.writeInt16BE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 2, 32767, -32768),
        this[w] = f >>> 8,
        this[w + 1] = f & 255,
        w + 2
    }
    ,
    a.prototype.writeInt32LE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 4, 2147483647, -2147483648),
        this[w] = f & 255,
        this[w + 1] = f >>> 8,
        this[w + 2] = f >>> 16,
        this[w + 3] = f >>> 24,
        w + 4
    }
    ,
    a.prototype.writeInt32BE = function(f, w, j) {
        return f = +f,
        w = w >>> 0,
        j || g(this, f, w, 4, 2147483647, -2147483648),
        f < 0 && (f = 4294967295 + f + 1),
        this[w] = f >>> 24,
        this[w + 1] = f >>> 16,
        this[w + 2] = f >>> 8,
        this[w + 3] = f & 255,
        w + 4
    }
    ,
    a.prototype.writeBigInt64LE = Sr(function(f, w=0) {
        return B(this, f, w, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    a.prototype.writeBigInt64BE = Sr(function(f, w=0) {
        return ie(this, f, w, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function te(M, f, w, j, U, $) {
        if (w + j > M.length)
            throw new RangeError("Index out of range");
        if (w < 0)
            throw new RangeError("Index out of range")
    }
    function oe(M, f, w, j, U) {
        return f = +f,
        w = w >>> 0,
        U || te(M, f, w, 4),
        n.write(M, f, w, j, 23, 4),
        w + 4
    }
    a.prototype.writeFloatLE = function(f, w, j) {
        return oe(this, f, w, !0, j)
    }
    ,
    a.prototype.writeFloatBE = function(f, w, j) {
        return oe(this, f, w, !1, j)
    }
    ;
    function xe(M, f, w, j, U) {
        return f = +f,
        w = w >>> 0,
        U || te(M, f, w, 8),
        n.write(M, f, w, j, 52, 8),
        w + 8
    }
    a.prototype.writeDoubleLE = function(f, w, j) {
        return xe(this, f, w, !0, j)
    }
    ,
    a.prototype.writeDoubleBE = function(f, w, j) {
        return xe(this, f, w, !1, j)
    }
    ,
    a.prototype.copy = function(f, w, j, U) {
        if (!a.isBuffer(f))
            throw new TypeError("argument should be a Buffer");
        if (j || (j = 0),
        !U && U !== 0 && (U = this.length),
        w >= f.length && (w = f.length),
        w || (w = 0),
        U > 0 && U < j && (U = j),
        U === j || f.length === 0 || this.length === 0)
            return 0;
        if (w < 0)
            throw new RangeError("targetStart out of bounds");
        if (j < 0 || j >= this.length)
            throw new RangeError("Index out of range");
        if (U < 0)
            throw new RangeError("sourceEnd out of bounds");
        U > this.length && (U = this.length),
        f.length - w < U - j && (U = f.length - w + j);
        const $ = U - j;
        return this === f && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(w, j, U) : Uint8Array.prototype.set.call(f, this.subarray(j, U), w),
        $
    }
    ,
    a.prototype.fill = function(f, w, j, U) {
        if (typeof f == "string") {
            if (typeof w == "string" ? (U = w,
            w = 0,
            j = this.length) : typeof j == "string" && (U = j,
            j = this.length),
            U !== void 0 && typeof U != "string")
                throw new TypeError("encoding must be a string");
            if (typeof U == "string" && !a.isEncoding(U))
                throw new TypeError("Unknown encoding: " + U);
            if (f.length === 1) {
                const q = f.charCodeAt(0);
                (U === "utf8" && q < 128 || U === "latin1") && (f = q)
            }
        } else
            typeof f == "number" ? f = f & 255 : typeof f == "boolean" && (f = Number(f));
        if (w < 0 || this.length < w || this.length < j)
            throw new RangeError("Out of range index");
        if (j <= w)
            return this;
        w = w >>> 0,
        j = j === void 0 ? this.length : j >>> 0,
        f || (f = 0);
        let $;
        if (typeof f == "number")
            for ($ = w; $ < j; ++$)
                this[$] = f;
        else {
            const q = a.isBuffer(f) ? f : a.from(f, U)
              , Ee = q.length;
            if (Ee === 0)
                throw new TypeError('The value "' + f + '" is invalid for argument "value"');
            for ($ = 0; $ < j - w; ++$)
                this[$ + w] = q[$ % Ee]
        }
        return this
    }
    ;
    const ve = {};
    function ye(M, f, w) {
        ve[M] = class extends w {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: f.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${M}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return M
            }
            set code(U) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: U,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${M}]: ${this.message}`
            }
        }
    }
    ye("ERR_BUFFER_OUT_OF_BOUNDS", function(M) {
        return M ? `${M} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    ye("ERR_INVALID_ARG_TYPE", function(M, f) {
        return `The "${M}" argument must be of type number. Received type ${typeof f}`
    }, TypeError),
    ye("ERR_OUT_OF_RANGE", function(M, f, w) {
        let j = `The value of "${M}" is out of range.`
          , U = w;
        return Number.isInteger(w) && Math.abs(w) > 2 ** 32 ? U = vt(String(w)) : typeof w == "bigint" && (U = String(w),
        (w > BigInt(2) ** BigInt(32) || w < -(BigInt(2) ** BigInt(32))) && (U = vt(U)),
        U += "n"),
        j += ` It must be ${f}. Received ${U}`,
        j
    }, RangeError);
    function vt(M) {
        let f = ""
          , w = M.length;
        const j = M[0] === "-" ? 1 : 0;
        for (; w >= j + 4; w -= 3)
            f = `_${M.slice(w - 3, w)}${f}`;
        return `${M.slice(0, w)}${f}`
    }
    function qe(M, f, w) {
        fr(f, "offset"),
        (M[f] === void 0 || M[f + w] === void 0) && Qe(f, M.length - (w + 1))
    }
    function Ze(M, f, w, j, U, $) {
        if (M > w || M < f) {
            const q = typeof f == "bigint" ? "n" : "";
            let Ee;
            throw $ > 3 ? f === 0 || f === BigInt(0) ? Ee = `>= 0${q} and < 2${q} ** ${($ + 1) * 8}${q}` : Ee = `>= -(2${q} ** ${($ + 1) * 8 - 1}${q}) and < 2 ** ${($ + 1) * 8 - 1}${q}` : Ee = `>= ${f}${q} and <= ${w}${q}`,
            new ve.ERR_OUT_OF_RANGE("value",Ee,M)
        }
        qe(j, U, $)
    }
    function fr(M, f) {
        if (typeof M != "number")
            throw new ve.ERR_INVALID_ARG_TYPE(f,"number",M)
    }
    function Qe(M, f, w) {
        throw Math.floor(M) !== M ? (fr(M, w),
        new ve.ERR_OUT_OF_RANGE(w || "offset","an integer",M)) : f < 0 ? new ve.ERR_BUFFER_OUT_OF_BOUNDS : new ve.ERR_OUT_OF_RANGE(w || "offset",`>= ${w ? 1 : 0} and <= ${f}`,M)
    }
    const bt = /[^+/0-9A-Za-z-_]/g;
    function Bc(M) {
        if (M = M.split("=")[0],
        M = M.trim().replace(bt, ""),
        M.length < 2)
            return "";
        for (; M.length % 4 !== 0; )
            M = M + "=";
        return M
    }
    function lt(M, f) {
        f = f || 1 / 0;
        let w;
        const j = M.length;
        let U = null;
        const $ = [];
        for (let q = 0; q < j; ++q) {
            if (w = M.charCodeAt(q),
            w > 55295 && w < 57344) {
                if (!U) {
                    if (w > 56319) {
                        (f -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    } else if (q + 1 === j) {
                        (f -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    }
                    U = w;
                    continue
                }
                if (w < 56320) {
                    (f -= 3) > -1 && $.push(239, 191, 189),
                    U = w;
                    continue
                }
                w = (U - 55296 << 10 | w - 56320) + 65536
            } else
                U && (f -= 3) > -1 && $.push(239, 191, 189);
            if (U = null,
            w < 128) {
                if ((f -= 1) < 0)
                    break;
                $.push(w)
            } else if (w < 2048) {
                if ((f -= 2) < 0)
                    break;
                $.push(w >> 6 | 192, w & 63 | 128)
            } else if (w < 65536) {
                if ((f -= 3) < 0)
                    break;
                $.push(w >> 12 | 224, w >> 6 & 63 | 128, w & 63 | 128)
            } else if (w < 1114112) {
                if ((f -= 4) < 0)
                    break;
                $.push(w >> 18 | 240, w >> 12 & 63 | 128, w >> 6 & 63 | 128, w & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return $
    }
    function _t(M) {
        const f = [];
        for (let w = 0; w < M.length; ++w)
            f.push(M.charCodeAt(w) & 255);
        return f
    }
    function Pc(M, f) {
        let w, j, U;
        const $ = [];
        for (let q = 0; q < M.length && !((f -= 2) < 0); ++q)
            w = M.charCodeAt(q),
            j = w >> 8,
            U = w % 256,
            $.push(U),
            $.push(j);
        return $
    }
    function dt(M) {
        return e.toByteArray(Bc(M))
    }
    function nt(M, f, w, j) {
        let U;
        for (U = 0; U < j && !(U + w >= f.length || U >= M.length); ++U)
            f[U + w] = M[U];
        return U
    }
    function Qn(M, f) {
        return M instanceof f || M != null && M.constructor != null && M.constructor.name != null && M.constructor.name === f.name
    }
    function ct(M) {
        return M !== M
    }
    const xt = function() {
        const M = "0123456789abcdef"
          , f = new Array(256);
        for (let w = 0; w < 16; ++w) {
            const j = w * 16;
            for (let U = 0; U < 16; ++U)
                f[j + U] = M[w] + M[U]
        }
        return f
    }();
    function Sr(M) {
        return typeof BigInt > "u" ? St : M
    }
    function St() {
        throw new Error("BigInt not supported")
    }
}
)(pe);
typeof window < "u" && (window.Buffer = pe.Buffer,
typeof window.global > "u" && (window.global = window),
window.global.Buffer = pe.Buffer);
typeof globalThis > "u" && (globalThis.global = globalThis);
var C0 = {}
  , Pv = {
    exports: {}
}
  , cr = {}
  , Ov = {
    exports: {}
}
  , Dv = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(I, L) {
        var P = I.length;
        I.push(L);
        e: for (; 0 < P; ) {
            var N = P - 1 >>> 1
              , g = I[N];
            if (0 < i(g, L))
                I[N] = L,
                I[P] = g,
                P = N;
            else
                break e
        }
    }
    function n(I) {
        return I.length === 0 ? null : I[0]
    }
    function r(I) {
        if (I.length === 0)
            return null;
        var L = I[0]
          , P = I.pop();
        if (P !== L) {
            I[0] = P;
            e: for (var N = 0, g = I.length, B = g >>> 1; N < B; ) {
                var ie = 2 * (N + 1) - 1
                  , te = I[ie]
                  , oe = ie + 1
                  , xe = I[oe];
                if (0 > i(te, P))
                    oe < g && 0 > i(xe, te) ? (I[N] = xe,
                    I[oe] = P,
                    N = oe) : (I[N] = te,
                    I[ie] = P,
                    N = ie);
                else if (oe < g && 0 > i(xe, P))
                    I[N] = xe,
                    I[oe] = P,
                    N = oe;
                else
                    break e
            }
        }
        return L
    }
    function i(I, L) {
        var P = I.sortIndex - L.sortIndex;
        return P !== 0 ? P : I.id - L.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , y = 3
      , m = !1
      , v = !1
      , E = !1
      , A = typeof setTimeout == "function" ? setTimeout : null
      , _ = typeof clearTimeout == "function" ? clearTimeout : null
      , x = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function b(I) {
        for (var L = n(c); L !== null; ) {
            if (L.callback === null)
                r(c);
            else if (L.startTime <= I)
                r(c),
                L.sortIndex = L.expirationTime,
                e(l, L);
            else
                break;
            L = n(c)
        }
    }
    function R(I) {
        if (E = !1,
        b(I),
        !v)
            if (n(l) !== null)
                v = !0,
                k(O);
            else {
                var L = n(c);
                L !== null && C(R, L.startTime - I)
            }
    }
    function O(I, L) {
        v = !1,
        E && (E = !1,
        _(K),
        K = -1),
        m = !0;
        var P = y;
        try {
            for (b(L),
            h = n(l); h !== null && (!(h.expirationTime > L) || I && !Z()); ) {
                var N = h.callback;
                if (typeof N == "function") {
                    h.callback = null,
                    y = h.priorityLevel;
                    var g = N(h.expirationTime <= L);
                    L = t.unstable_now(),
                    typeof g == "function" ? h.callback = g : h === n(l) && r(l),
                    b(L)
                } else
                    r(l);
                h = n(l)
            }
            if (h !== null)
                var B = !0;
            else {
                var ie = n(c);
                ie !== null && C(R, ie.startTime - L),
                B = !1
            }
            return B
        } finally {
            h = null,
            y = P,
            m = !1
        }
    }
    var D = !1
      , z = null
      , K = -1
      , F = 5
      , G = -1;
    function Z() {
        return !(t.unstable_now() - G < F)
    }
    function X() {
        if (z !== null) {
            var I = t.unstable_now();
            G = I;
            var L = !0;
            try {
                L = z(!0, I)
            } finally {
                L ? T() : (D = !1,
                z = null)
            }
        } else
            D = !1
    }
    var T;
    if (typeof x == "function")
        T = function() {
            x(X)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var u = new MessageChannel
          , p = u.port2;
        u.port1.onmessage = X,
        T = function() {
            p.postMessage(null)
        }
    } else
        T = function() {
            A(X, 0)
        }
        ;
    function k(I) {
        z = I,
        D || (D = !0,
        T())
    }
    function C(I, L) {
        K = A(function() {
            I(t.unstable_now())
        }, L)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(I) {
        I.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        v || m || (v = !0,
        k(O))
    }
    ,
    t.unstable_forceFrameRate = function(I) {
        0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < I ? Math.floor(1e3 / I) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return y
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return n(l)
    }
    ,
    t.unstable_next = function(I) {
        switch (y) {
        case 1:
        case 2:
        case 3:
            var L = 3;
            break;
        default:
            L = y
        }
        var P = y;
        y = L;
        try {
            return I()
        } finally {
            y = P
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(I, L) {
        switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            I = 3
        }
        var P = y;
        y = I;
        try {
            return L()
        } finally {
            y = P
        }
    }
    ,
    t.unstable_scheduleCallback = function(I, L, P) {
        var N = t.unstable_now();
        switch (typeof P == "object" && P !== null ? (P = P.delay,
        P = typeof P == "number" && 0 < P ? N + P : N) : P = N,
        I) {
        case 1:
            var g = -1;
            break;
        case 2:
            g = 250;
            break;
        case 5:
            g = 1073741823;
            break;
        case 4:
            g = 1e4;
            break;
        default:
            g = 5e3
        }
        return g = P + g,
        I = {
            id: d++,
            callback: L,
            priorityLevel: I,
            startTime: P,
            expirationTime: g,
            sortIndex: -1
        },
        P > N ? (I.sortIndex = P,
        e(c, I),
        n(l) === null && I === n(c) && (E ? (_(K),
        K = -1) : E = !0,
        C(R, P - N))) : (I.sortIndex = g,
        e(l, I),
        v || m || (v = !0,
        k(O))),
        I
    }
    ,
    t.unstable_shouldYield = Z,
    t.unstable_wrapCallback = function(I) {
        var L = y;
        return function() {
            var P = y;
            y = L;
            try {
                return I.apply(this, arguments)
            } finally {
                y = P
            }
        }
    }
}
)(Dv);
Ov.exports = Dv;
var G2 = Ov.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Y2 = Y
  , lr = G2;
function ee(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
        e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var zv = new Set
  , Dl = {};
function fo(t, e) {
    ya(t, e),
    ya(t + "Capture", e)
}
function ya(t, e) {
    for (Dl[t] = e,
    t = 0; t < e.length; t++)
        zv.add(e[t])
}
var Ii = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , R0 = Object.prototype.hasOwnProperty
  , Z2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , Ky = {}
  , Vy = {};
function Q2(t) {
    return R0.call(Vy, t) ? !0 : R0.call(Ky, t) ? !1 : Z2.test(t) ? Vy[t] = !0 : (Ky[t] = !0,
    !1)
}
function J2(t, e, n, r) {
    if (n !== null && n.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function X2(t, e, n, r) {
    if (e === null || typeof e > "u" || J2(t, e, n, r))
        return !0;
    if (r)
        return !1;
    if (n !== null)
        switch (n.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function zn(t, e, n, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = r,
    this.attributeNamespace = i,
    this.mustUseProperty = n,
    this.propertyName = t,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var vn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    vn[t] = new zn(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var e = t[0];
    vn[e] = new zn(e,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    vn[t] = new zn(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    vn[t] = new zn(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    vn[t] = new zn(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    vn[t] = new zn(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    vn[t] = new zn(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    vn[t] = new zn(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    vn[t] = new zn(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var Vg = /[\-:]([a-z])/g;
function Hg(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(Vg, Hg);
    vn[e] = new zn(e,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(Vg, Hg);
    vn[e] = new zn(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(Vg, Hg);
    vn[e] = new zn(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    vn[t] = new zn(t,1,!1,t.toLowerCase(),null,!1,!1)
});
vn.xlinkHref = new zn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    vn[t] = new zn(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function qg(t, e, n, r) {
    var i = vn.hasOwnProperty(e) ? vn[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (X2(e, n, i, r) && (n = null),
    r || i === null ? Q2(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName,
    r = i.attributeNamespace,
    n === null ? t.removeAttribute(e) : (i = i.type,
    n = i === 3 || i === 4 && n === !0 ? "" : "" + n,
    r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var Ri = Y2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Dc = Symbol.for("react.element")
  , Ko = Symbol.for("react.portal")
  , Vo = Symbol.for("react.fragment")
  , Gg = Symbol.for("react.strict_mode")
  , L0 = Symbol.for("react.profiler")
  , Uv = Symbol.for("react.provider")
  , Wv = Symbol.for("react.context")
  , Yg = Symbol.for("react.forward_ref")
  , j0 = Symbol.for("react.suspense")
  , B0 = Symbol.for("react.suspense_list")
  , Zg = Symbol.for("react.memo")
  , Ki = Symbol.for("react.lazy")
  , Fv = Symbol.for("react.offscreen")
  , Hy = Symbol.iterator;
function qa(t) {
    return t === null || typeof t != "object" ? null : (t = Hy && t[Hy] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var mt = Object.assign, _f;
function sl(t) {
    if (_f === void 0)
        try {
            throw Error()
        } catch (n) {
            var e = n.stack.trim().match(/\n( *(at )?)/);
            _f = e && e[1] || ""
        }
    return `
` + _f + t
}
var xf = !1;
function Sf(t, e) {
    if (!t || xf)
        return "";
    xf = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    r = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            t()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        xf = !1,
        Error.prepareStackTrace = n
    }
    return (t = t ? t.displayName || t.name : "") ? sl(t) : ""
}
function eE(t) {
    switch (t.tag) {
    case 5:
        return sl(t.type);
    case 16:
        return sl("Lazy");
    case 13:
        return sl("Suspense");
    case 19:
        return sl("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = Sf(t.type, !1),
        t;
    case 11:
        return t = Sf(t.type.render, !1),
        t;
    case 1:
        return t = Sf(t.type, !0),
        t;
    default:
        return ""
    }
}
function P0(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case Vo:
        return "Fragment";
    case Ko:
        return "Portal";
    case L0:
        return "Profiler";
    case Gg:
        return "StrictMode";
    case j0:
        return "Suspense";
    case B0:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case Wv:
            return (t.displayName || "Context") + ".Consumer";
        case Uv:
            return (t._context.displayName || "Context") + ".Provider";
        case Yg:
            var e = t.render;
            return t = t.displayName,
            t || (t = e.displayName || e.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case Zg:
            return e = t.displayName || null,
            e !== null ? e : P0(t.type) || "Memo";
        case Ki:
            e = t._payload,
            t = t._init;
            try {
                return P0(t(e))
            } catch {}
        }
    return null
}
function tE(t) {
    var e = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = e.render,
        t = t.displayName || t.name || "",
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return P0(e);
    case 8:
        return e === Gg ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function fs(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function $v(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function nE(t) {
    var e = $v(t) ? "checked" : "value"
      , n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
      , r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get
          , s = n.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(t, e, {
            enumerable: n.enumerable
        }),
        {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[e]
            }
        }
    }
}
function zc(t) {
    t._valueTracker || (t._valueTracker = nE(t))
}
function Kv(t) {
    if (!t)
        return !1;
    var e = t._valueTracker;
    if (!e)
        return !0;
    var n = e.getValue()
      , r = "";
    return t && (r = $v(t) ? t.checked ? "true" : "false" : t.value),
    t = r,
    t !== n ? (e.setValue(t),
    !0) : !1
}
function ad(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function O0(t, e) {
    var n = e.checked;
    return mt({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ?? t._wrapperState.initialChecked
    })
}
function qy(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue
      , r = e.checked != null ? e.checked : e.defaultChecked;
    n = fs(e.value != null ? e.value : n),
    t._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function Vv(t, e) {
    e = e.checked,
    e != null && qg(t, "checked", e, !1)
}
function D0(t, e) {
    Vv(t, e);
    var n = fs(e.value)
      , r = e.type;
    if (n != null)
        r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? z0(t, e.type, n) : e.hasOwnProperty("defaultValue") && z0(t, e.type, fs(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}
function Gy(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + t._wrapperState.initialValue,
        n || e === t.value || (t.value = e),
        t.defaultValue = e
    }
    n = t.name,
    n !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    n !== "" && (t.name = n)
}
function z0(t, e, n) {
    (e !== "number" || ad(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var ol = Array.isArray;
function sa(t, e, n, r) {
    if (t = t.options,
    e) {
        e = {};
        for (var i = 0; i < n.length; i++)
            e["$" + n[i]] = !0;
        for (n = 0; n < t.length; n++)
            i = e.hasOwnProperty("$" + t[n].value),
            t[n].selected !== i && (t[n].selected = i),
            i && r && (t[n].defaultSelected = !0)
    } else {
        for (n = "" + fs(n),
        e = null,
        i = 0; i < t.length; i++) {
            if (t[i].value === n) {
                t[i].selected = !0,
                r && (t[i].defaultSelected = !0);
                return
            }
            e !== null || t[i].disabled || (e = t[i])
        }
        e !== null && (e.selected = !0)
    }
}
function U0(t, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(ee(91));
    return mt({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function Yy(t, e) {
    var n = e.value;
    if (n == null) {
        if (n = e.children,
        e = e.defaultValue,
        n != null) {
            if (e != null)
                throw Error(ee(92));
            if (ol(n)) {
                if (1 < n.length)
                    throw Error(ee(93));
                n = n[0]
            }
            e = n
        }
        e == null && (e = ""),
        n = e
    }
    t._wrapperState = {
        initialValue: fs(n)
    }
}
function Hv(t, e) {
    var n = fs(e.value)
      , r = fs(e.defaultValue);
    n != null && (n = "" + n,
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = "" + r)
}
function Zy(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
function qv(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function W0(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? qv(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Uc, Gv = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, r, i)
        })
    }
    : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = e;
    else {
        for (Uc = Uc || document.createElement("div"),
        Uc.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Uc.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; e.firstChild; )
            t.appendChild(e.firstChild)
    }
});
function zl(t, e) {
    if (e) {
        var n = t.firstChild;
        if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var _l = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , rE = ["Webkit", "ms", "Moz", "O"];
Object.keys(_l).forEach(function(t) {
    rE.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1),
        _l[e] = _l[t]
    })
});
function Yv(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || _l.hasOwnProperty(t) && _l[t] ? ("" + e).trim() : e + "px"
}
function Zv(t, e) {
    t = t.style;
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0
              , i = Yv(n, e[n], r);
            n === "float" && (n = "cssFloat"),
            r ? t.setProperty(n, i) : t[n] = i
        }
}
var iE = mt({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function F0(t, e) {
    if (e) {
        if (iE[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(ee(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(ee(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(ee(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(ee(62))
    }
}
function $0(t, e) {
    if (t.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var K0 = null;
function Qg(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var V0 = null
  , oa = null
  , aa = null;
function Qy(t) {
    if (t = mc(t)) {
        if (typeof V0 != "function")
            throw Error(ee(280));
        var e = t.stateNode;
        e && (e = ch(e),
        V0(t.stateNode, t.type, e))
    }
}
function Qv(t) {
    oa ? aa ? aa.push(t) : aa = [t] : oa = t
}
function Jv() {
    if (oa) {
        var t = oa
          , e = aa;
        if (aa = oa = null,
        Qy(t),
        e)
            for (t = 0; t < e.length; t++)
                Qy(e[t])
    }
}
function Xv(t, e) {
    return t(e)
}
function eb() {}
var kf = !1;
function tb(t, e, n) {
    if (kf)
        return t(e, n);
    kf = !0;
    try {
        return Xv(t, e, n)
    } finally {
        kf = !1,
        (oa !== null || aa !== null) && (eb(),
        Jv())
    }
}
function Ul(t, e) {
    var n = t.stateNode;
    if (n === null)
        return null;
    var r = ch(n);
    if (r === null)
        return null;
    n = r[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (r = !r.disabled) || (t = t.type,
        r = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !r;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (n && typeof n != "function")
        throw Error(ee(231, e, typeof n));
    return n
}
var H0 = !1;
if (Ii)
    try {
        var Ga = {};
        Object.defineProperty(Ga, "passive", {
            get: function() {
                H0 = !0
            }
        }),
        window.addEventListener("test", Ga, Ga),
        window.removeEventListener("test", Ga, Ga)
    } catch {
        H0 = !1
    }
function sE(t, e, n, r, i, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(n, c)
    } catch (d) {
        this.onError(d)
    }
}
var xl = !1
  , ld = null
  , cd = !1
  , q0 = null
  , oE = {
    onError: function(t) {
        xl = !0,
        ld = t
    }
};
function aE(t, e, n, r, i, s, o, a, l) {
    xl = !1,
    ld = null,
    sE.apply(oE, arguments)
}
function lE(t, e, n, r, i, s, o, a, l) {
    if (aE.apply(this, arguments),
    xl) {
        if (xl) {
            var c = ld;
            xl = !1,
            ld = null
        } else
            throw Error(ee(198));
        cd || (cd = !0,
        q0 = c)
    }
}
function po(t) {
    var e = t
      , n = t;
    if (t.alternate)
        for (; e.return; )
            e = e.return;
    else {
        t = e;
        do
            e = t,
            e.flags & 4098 && (n = e.return),
            t = e.return;
        while (t)
    }
    return e.tag === 3 ? n : null
}
function nb(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate,
        t !== null && (e = t.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Jy(t) {
    if (po(t) !== t)
        throw Error(ee(188))
}
function cE(t) {
    var e = t.alternate;
    if (!e) {
        if (e = po(t),
        e === null)
            throw Error(ee(188));
        return e !== t ? null : t
    }
    for (var n = t, r = e; ; ) {
        var i = n.return;
        if (i === null)
            break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return,
            r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s; ) {
                if (s === n)
                    return Jy(i),
                    t;
                if (s === r)
                    return Jy(i),
                    e;
                s = s.sibling
            }
            throw Error(ee(188))
        }
        if (n.return !== r.return)
            n = i,
            r = s;
        else {
            for (var o = !1, a = i.child; a; ) {
                if (a === n) {
                    o = !0,
                    n = i,
                    r = s;
                    break
                }
                if (a === r) {
                    o = !0,
                    r = i,
                    n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === n) {
                        o = !0,
                        n = s,
                        r = i;
                        break
                    }
                    if (a === r) {
                        o = !0,
                        r = s,
                        n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(ee(189))
            }
        }
        if (n.alternate !== r)
            throw Error(ee(190))
    }
    if (n.tag !== 3)
        throw Error(ee(188));
    return n.stateNode.current === n ? t : e
}
function rb(t) {
    return t = cE(t),
    t !== null ? ib(t) : null
}
function ib(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var e = ib(t);
        if (e !== null)
            return e;
        t = t.sibling
    }
    return null
}
var sb = lr.unstable_scheduleCallback
  , Xy = lr.unstable_cancelCallback
  , uE = lr.unstable_shouldYield
  , dE = lr.unstable_requestPaint
  , Mt = lr.unstable_now
  , hE = lr.unstable_getCurrentPriorityLevel
  , Jg = lr.unstable_ImmediatePriority
  , ob = lr.unstable_UserBlockingPriority
  , ud = lr.unstable_NormalPriority
  , fE = lr.unstable_LowPriority
  , ab = lr.unstable_IdlePriority
  , sh = null
  , Xr = null;
function pE(t) {
    if (Xr && typeof Xr.onCommitFiberRoot == "function")
        try {
            Xr.onCommitFiberRoot(sh, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var Lr = Math.clz32 ? Math.clz32 : yE
  , gE = Math.log
  , mE = Math.LN2;
function yE(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (gE(t) / mE | 0) | 0
}
var Wc = 64
  , Fc = 4194304;
function al(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function dd(t, e) {
    var n = t.pendingLanes;
    if (n === 0)
        return 0;
    var r = 0
      , i = t.suspendedLanes
      , s = t.pingedLanes
      , o = n & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = al(a) : (s &= o,
        s !== 0 && (r = al(s)))
    } else
        o = n & ~i,
        o !== 0 ? r = al(o) : s !== 0 && (r = al(s));
    if (r === 0)
        return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r,
    s = e & -e,
    i >= s || i === 16 && (s & 4194240) !== 0))
        return e;
    if (r & 4 && (r |= n & 16),
    e = t.entangledLanes,
    e !== 0)
        for (t = t.entanglements,
        e &= r; 0 < e; )
            n = 31 - Lr(e),
            i = 1 << n,
            r |= t[n],
            e &= ~i;
    return r
}
function wE(t, e) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function vE(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s; ) {
        var o = 31 - Lr(s)
          , a = 1 << o
          , l = i[o];
        l === -1 ? (!(a & n) || a & r) && (i[o] = wE(a, e)) : l <= e && (t.expiredLanes |= a),
        s &= ~a
    }
}
function G0(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function lb() {
    var t = Wc;
    return Wc <<= 1,
    !(Wc & 4194240) && (Wc = 64),
    t
}
function Ef(t) {
    for (var e = [], n = 0; 31 > n; n++)
        e.push(t);
    return e
}
function pc(t, e, n) {
    t.pendingLanes |= e,
    e !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    e = 31 - Lr(e),
    t[e] = n
}
function bE(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= e,
    t.mutableReadLanes &= e,
    t.entangledLanes &= e,
    e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n; ) {
        var i = 31 - Lr(n)
          , s = 1 << i;
        e[i] = 0,
        r[i] = -1,
        t[i] = -1,
        n &= ~s
    }
}
function Xg(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n; ) {
        var r = 31 - Lr(n)
          , i = 1 << r;
        i & e | t[r] & e && (t[r] |= e),
        n &= ~i
    }
}
var Ke = 0;
function cb(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var ub, em, db, hb, fb, Y0 = !1, $c = [], rs = null, is = null, ss = null, Wl = new Map, Fl = new Map, qi = [], _E = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function ew(t, e) {
    switch (t) {
    case "focusin":
    case "focusout":
        rs = null;
        break;
    case "dragenter":
    case "dragleave":
        is = null;
        break;
    case "mouseover":
    case "mouseout":
        ss = null;
        break;
    case "pointerover":
    case "pointerout":
        Wl.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Fl.delete(e.pointerId)
    }
}
function Ya(t, e, n, r, i, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    },
    e !== null && (e = mc(e),
    e !== null && em(e)),
    t) : (t.eventSystemFlags |= r,
    e = t.targetContainers,
    i !== null && e.indexOf(i) === -1 && e.push(i),
    t)
}
function xE(t, e, n, r, i) {
    switch (e) {
    case "focusin":
        return rs = Ya(rs, t, e, n, r, i),
        !0;
    case "dragenter":
        return is = Ya(is, t, e, n, r, i),
        !0;
    case "mouseover":
        return ss = Ya(ss, t, e, n, r, i),
        !0;
    case "pointerover":
        var s = i.pointerId;
        return Wl.set(s, Ya(Wl.get(s) || null, t, e, n, r, i)),
        !0;
    case "gotpointercapture":
        return s = i.pointerId,
        Fl.set(s, Ya(Fl.get(s) || null, t, e, n, r, i)),
        !0
    }
    return !1
}
function pb(t) {
    var e = zs(t.target);
    if (e !== null) {
        var n = po(e);
        if (n !== null) {
            if (e = n.tag,
            e === 13) {
                if (e = nb(n),
                e !== null) {
                    t.blockedOn = e,
                    fb(t.priority, function() {
                        db(n)
                    });
                    return
                }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function yu(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var e = t.targetContainers; 0 < e.length; ) {
        var n = Z0(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type,n);
            K0 = r,
            n.target.dispatchEvent(r),
            K0 = null
        } else
            return e = mc(n),
            e !== null && em(e),
            t.blockedOn = n,
            !1;
        e.shift()
    }
    return !0
}
function tw(t, e, n) {
    yu(t) && n.delete(e)
}
function SE() {
    Y0 = !1,
    rs !== null && yu(rs) && (rs = null),
    is !== null && yu(is) && (is = null),
    ss !== null && yu(ss) && (ss = null),
    Wl.forEach(tw),
    Fl.forEach(tw)
}
function Za(t, e) {
    t.blockedOn === e && (t.blockedOn = null,
    Y0 || (Y0 = !0,
    lr.unstable_scheduleCallback(lr.unstable_NormalPriority, SE)))
}
function $l(t) {
    function e(i) {
        return Za(i, t)
    }
    if (0 < $c.length) {
        Za($c[0], t);
        for (var n = 1; n < $c.length; n++) {
            var r = $c[n];
            r.blockedOn === t && (r.blockedOn = null)
        }
    }
    for (rs !== null && Za(rs, t),
    is !== null && Za(is, t),
    ss !== null && Za(ss, t),
    Wl.forEach(e),
    Fl.forEach(e),
    n = 0; n < qi.length; n++)
        r = qi[n],
        r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < qi.length && (n = qi[0],
    n.blockedOn === null); )
        pb(n),
        n.blockedOn === null && qi.shift()
}
var la = Ri.ReactCurrentBatchConfig
  , hd = !0;
function kE(t, e, n, r) {
    var i = Ke
      , s = la.transition;
    la.transition = null;
    try {
        Ke = 1,
        tm(t, e, n, r)
    } finally {
        Ke = i,
        la.transition = s
    }
}
function EE(t, e, n, r) {
    var i = Ke
      , s = la.transition;
    la.transition = null;
    try {
        Ke = 4,
        tm(t, e, n, r)
    } finally {
        Ke = i,
        la.transition = s
    }
}
function tm(t, e, n, r) {
    if (hd) {
        var i = Z0(t, e, n, r);
        if (i === null)
            Bf(t, e, r, fd, n),
            ew(t, r);
        else if (xE(i, t, e, n, r))
            r.stopPropagation();
        else if (ew(t, r),
        e & 4 && -1 < _E.indexOf(t)) {
            for (; i !== null; ) {
                var s = mc(i);
                if (s !== null && ub(s),
                s = Z0(t, e, n, r),
                s === null && Bf(t, e, r, fd, n),
                s === i)
                    break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else
            Bf(t, e, r, null, n)
    }
}
var fd = null;
function Z0(t, e, n, r) {
    if (fd = null,
    t = Qg(r),
    t = zs(t),
    t !== null)
        if (e = po(t),
        e === null)
            t = null;
        else if (n = e.tag,
        n === 13) {
            if (t = nb(e),
            t !== null)
                return t;
            t = null
        } else if (n === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null
        } else
            e !== t && (t = null);
    return fd = t,
    null
}
function gb(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (hE()) {
        case Jg:
            return 1;
        case ob:
            return 4;
        case ud:
        case fE:
            return 16;
        case ab:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Qi = null
  , nm = null
  , wu = null;
function mb() {
    if (wu)
        return wu;
    var t, e = nm, n = e.length, r, i = "value"in Qi ? Qi.value : Qi.textContent, s = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++)
        ;
    var o = n - t;
    for (r = 1; r <= o && e[n - r] === i[s - r]; r++)
        ;
    return wu = i.slice(t, 1 < r ? 1 - r : void 0)
}
function vu(t) {
    var e = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && e === 13 && (t = 13)) : t = e,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function Kc() {
    return !0
}
function nw() {
    return !1
}
function ur(t) {
    function e(n, r, i, s, o) {
        this._reactName = n,
        this._targetInst = i,
        this.type = r,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in t)
            t.hasOwnProperty(a) && (n = t[a],
            this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Kc : nw,
        this.isPropagationStopped = nw,
        this
    }
    return mt(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
            this.isDefaultPrevented = Kc)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
            this.isPropagationStopped = Kc)
        },
        persist: function() {},
        isPersistent: Kc
    }),
    e
}
var Oa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, rm = ur(Oa), gc = mt({}, Oa, {
    view: 0,
    detail: 0
}), AE = ur(gc), Af, If, Qa, oh = mt({}, gc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: im,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== Qa && (Qa && t.type === "mousemove" ? (Af = t.screenX - Qa.screenX,
        If = t.screenY - Qa.screenY) : If = Af = 0,
        Qa = t),
        Af)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : If
    }
}), rw = ur(oh), IE = mt({}, oh, {
    dataTransfer: 0
}), ME = ur(IE), TE = mt({}, gc, {
    relatedTarget: 0
}), Mf = ur(TE), NE = mt({}, Oa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), CE = ur(NE), RE = mt({}, Oa, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), LE = ur(RE), jE = mt({}, Oa, {
    data: 0
}), iw = ur(jE), BE = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, PE = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, OE = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function DE(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = OE[t]) ? !!e[t] : !1
}
function im() {
    return DE
}
var zE = mt({}, gc, {
    key: function(t) {
        if (t.key) {
            var e = BE[t.key] || t.key;
            if (e !== "Unidentified")
                return e
        }
        return t.type === "keypress" ? (t = vu(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? PE[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: im,
    charCode: function(t) {
        return t.type === "keypress" ? vu(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? vu(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , UE = ur(zE)
  , WE = mt({}, oh, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , sw = ur(WE)
  , FE = mt({}, gc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: im
})
  , $E = ur(FE)
  , KE = mt({}, Oa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , VE = ur(KE)
  , HE = mt({}, oh, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , qE = ur(HE)
  , GE = [9, 13, 27, 32]
  , sm = Ii && "CompositionEvent"in window
  , Sl = null;
Ii && "documentMode"in document && (Sl = document.documentMode);
var YE = Ii && "TextEvent"in window && !Sl
  , yb = Ii && (!sm || Sl && 8 < Sl && 11 >= Sl)
  , ow = String.fromCharCode(32)
  , aw = !1;
function wb(t, e) {
    switch (t) {
    case "keyup":
        return GE.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function vb(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var Ho = !1;
function ZE(t, e) {
    switch (t) {
    case "compositionend":
        return vb(e);
    case "keypress":
        return e.which !== 32 ? null : (aw = !0,
        ow);
    case "textInput":
        return t = e.data,
        t === ow && aw ? null : t;
    default:
        return null
    }
}
function QE(t, e) {
    if (Ho)
        return t === "compositionend" || !sm && wb(t, e) ? (t = mb(),
        wu = nm = Qi = null,
        Ho = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return yb && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var JE = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function lw(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!JE[t.type] : e === "textarea"
}
function bb(t, e, n, r) {
    Qv(r),
    e = pd(e, "onChange"),
    0 < e.length && (n = new rm("onChange","change",null,n,r),
    t.push({
        event: n,
        listeners: e
    }))
}
var kl = null
  , Kl = null;
function XE(t) {
    Cb(t, 0)
}
function ah(t) {
    var e = Yo(t);
    if (Kv(e))
        return t
}
function eA(t, e) {
    if (t === "change")
        return e
}
var _b = !1;
if (Ii) {
    var Tf;
    if (Ii) {
        var Nf = "oninput"in document;
        if (!Nf) {
            var cw = document.createElement("div");
            cw.setAttribute("oninput", "return;"),
            Nf = typeof cw.oninput == "function"
        }
        Tf = Nf
    } else
        Tf = !1;
    _b = Tf && (!document.documentMode || 9 < document.documentMode)
}
function uw() {
    kl && (kl.detachEvent("onpropertychange", xb),
    Kl = kl = null)
}
function xb(t) {
    if (t.propertyName === "value" && ah(Kl)) {
        var e = [];
        bb(e, Kl, t, Qg(t)),
        tb(XE, e)
    }
}
function tA(t, e, n) {
    t === "focusin" ? (uw(),
    kl = e,
    Kl = n,
    kl.attachEvent("onpropertychange", xb)) : t === "focusout" && uw()
}
function nA(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return ah(Kl)
}
function rA(t, e) {
    if (t === "click")
        return ah(e)
}
function iA(t, e) {
    if (t === "input" || t === "change")
        return ah(e)
}
function sA(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Pr = typeof Object.is == "function" ? Object.is : sA;
function Vl(t, e) {
    if (Pr(t, e))
        return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
    var n = Object.keys(t)
      , r = Object.keys(e);
    if (n.length !== r.length)
        return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!R0.call(e, i) || !Pr(t[i], e[i]))
            return !1
    }
    return !0
}
function dw(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function hw(t, e) {
    var n = dw(t);
    t = 0;
    for (var r; n; ) {
        if (n.nodeType === 3) {
            if (r = t + n.textContent.length,
            t <= e && r >= e)
                return {
                    node: n,
                    offset: e - t
                };
            t = r
        }
        e: {
            for (; n; ) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = dw(n)
    }
}
function Sb(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Sb(t, e.parentNode) : "contains"in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}
function kb() {
    for (var t = window, e = ad(); e instanceof t.HTMLIFrameElement; ) {
        try {
            var n = typeof e.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n)
            t = e.contentWindow;
        else
            break;
        e = ad(t.document)
    }
    return e
}
function om(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
function oA(t) {
    var e = kb()
      , n = t.focusedElem
      , r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && Sb(n.ownerDocument.documentElement, n)) {
        if (r !== null && om(n)) {
            if (e = r.start,
            t = r.end,
            t === void 0 && (t = e),
            "selectionStart"in n)
                n.selectionStart = e,
                n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var i = n.textContent.length
                  , s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i),
                !t.extend && s > r && (i = r,
                r = s,
                s = i),
                i = hw(n, s);
                var o = hw(n, r);
                i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(i.node, i.offset),
                t.removeAllRanges(),
                s > r ? (t.addRange(e),
                t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                t.addRange(e)))
            }
        }
        for (e = [],
        t = n; t = t.parentNode; )
            t.nodeType === 1 && e.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof n.focus == "function" && n.focus(),
        n = 0; n < e.length; n++)
            t = e[n],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var aA = Ii && "documentMode"in document && 11 >= document.documentMode
  , qo = null
  , Q0 = null
  , El = null
  , J0 = !1;
function fw(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    J0 || qo == null || qo !== ad(r) || (r = qo,
    "selectionStart"in r && om(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(),
    r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }),
    El && Vl(El, r) || (El = r,
    r = pd(Q0, "onSelect"),
    0 < r.length && (e = new rm("onSelect","select",null,e,n),
    t.push({
        event: e,
        listeners: r
    }),
    e.target = qo)))
}
function Vc(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(),
    n["Webkit" + t] = "webkit" + e,
    n["Moz" + t] = "moz" + e,
    n
}
var Go = {
    animationend: Vc("Animation", "AnimationEnd"),
    animationiteration: Vc("Animation", "AnimationIteration"),
    animationstart: Vc("Animation", "AnimationStart"),
    transitionend: Vc("Transition", "TransitionEnd")
}
  , Cf = {}
  , Eb = {};
Ii && (Eb = document.createElement("div").style,
"AnimationEvent"in window || (delete Go.animationend.animation,
delete Go.animationiteration.animation,
delete Go.animationstart.animation),
"TransitionEvent"in window || delete Go.transitionend.transition);
function lh(t) {
    if (Cf[t])
        return Cf[t];
    if (!Go[t])
        return t;
    var e = Go[t], n;
    for (n in e)
        if (e.hasOwnProperty(n) && n in Eb)
            return Cf[t] = e[n];
    return t
}
var Ab = lh("animationend")
  , Ib = lh("animationiteration")
  , Mb = lh("animationstart")
  , Tb = lh("transitionend")
  , Nb = new Map
  , pw = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ys(t, e) {
    Nb.set(t, e),
    fo(e, [t])
}
for (var Rf = 0; Rf < pw.length; Rf++) {
    var Lf = pw[Rf]
      , lA = Lf.toLowerCase()
      , cA = Lf[0].toUpperCase() + Lf.slice(1);
    ys(lA, "on" + cA)
}
ys(Ab, "onAnimationEnd");
ys(Ib, "onAnimationIteration");
ys(Mb, "onAnimationStart");
ys("dblclick", "onDoubleClick");
ys("focusin", "onFocus");
ys("focusout", "onBlur");
ys(Tb, "onTransitionEnd");
ya("onMouseEnter", ["mouseout", "mouseover"]);
ya("onMouseLeave", ["mouseout", "mouseover"]);
ya("onPointerEnter", ["pointerout", "pointerover"]);
ya("onPointerLeave", ["pointerout", "pointerover"]);
fo("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fo("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fo("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fo("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fo("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fo("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ll = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , uA = new Set("cancel close invalid load scroll toggle".split(" ").concat(ll));
function gw(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n,
    lE(r, e, void 0, t),
    t.currentTarget = null
}
function Cb(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
        var r = t[n]
          , i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    gw(i, a, c),
                    s = l
                }
            else
                for (o = 0; o < r.length; o++) {
                    if (a = r[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    gw(i, a, c),
                    s = l
                }
        }
    }
    if (cd)
        throw t = q0,
        cd = !1,
        q0 = null,
        t
}
function it(t, e) {
    var n = e[rp];
    n === void 0 && (n = e[rp] = new Set);
    var r = t + "__bubble";
    n.has(r) || (Rb(e, t, 2, !1),
    n.add(r))
}
function jf(t, e, n) {
    var r = 0;
    e && (r |= 4),
    Rb(n, t, r, e)
}
var Hc = "_reactListening" + Math.random().toString(36).slice(2);
function Hl(t) {
    if (!t[Hc]) {
        t[Hc] = !0,
        zv.forEach(function(n) {
            n !== "selectionchange" && (uA.has(n) || jf(n, !1, t),
            jf(n, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[Hc] || (e[Hc] = !0,
        jf("selectionchange", !1, e))
    }
}
function Rb(t, e, n, r) {
    switch (gb(e)) {
    case 1:
        var i = kE;
        break;
    case 4:
        i = EE;
        break;
    default:
        i = tm
    }
    n = i.bind(null, e, n, t),
    i = void 0,
    !H0 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0),
    r ? i !== void 0 ? t.addEventListener(e, n, {
        capture: !0,
        passive: i
    }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, {
        passive: i
    }) : t.addEventListener(e, n, !1)
}
function Bf(t, e, n, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null)
        e: for (; ; ) {
            if (r === null)
                return;
            var o = r.tag;
            if (o === 3 || o === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                    break;
                if (o === 4)
                    for (o = r.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === i || l.nodeType === 8 && l.parentNode === i))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = zs(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        r = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            r = r.return
        }
    tb(function() {
        var c = s
          , d = Qg(n)
          , h = [];
        e: {
            var y = Nb.get(t);
            if (y !== void 0) {
                var m = rm
                  , v = t;
                switch (t) {
                case "keypress":
                    if (vu(n) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = UE;
                    break;
                case "focusin":
                    v = "focus",
                    m = Mf;
                    break;
                case "focusout":
                    v = "blur",
                    m = Mf;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = Mf;
                    break;
                case "click":
                    if (n.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = rw;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = ME;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = $E;
                    break;
                case Ab:
                case Ib:
                case Mb:
                    m = CE;
                    break;
                case Tb:
                    m = VE;
                    break;
                case "scroll":
                    m = AE;
                    break;
                case "wheel":
                    m = qE;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = LE;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = sw
                }
                var E = (e & 4) !== 0
                  , A = !E && t === "scroll"
                  , _ = E ? y !== null ? y + "Capture" : null : y;
                E = [];
                for (var x = c, b; x !== null; ) {
                    b = x;
                    var R = b.stateNode;
                    if (b.tag === 5 && R !== null && (b = R,
                    _ !== null && (R = Ul(x, _),
                    R != null && E.push(ql(x, R, b)))),
                    A)
                        break;
                    x = x.return
                }
                0 < E.length && (y = new m(y,v,null,n,d),
                h.push({
                    event: y,
                    listeners: E
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (y = t === "mouseover" || t === "pointerover",
                m = t === "mouseout" || t === "pointerout",
                y && n !== K0 && (v = n.relatedTarget || n.fromElement) && (zs(v) || v[Mi]))
                    break e;
                if ((m || y) && (y = d.window === d ? d : (y = d.ownerDocument) ? y.defaultView || y.parentWindow : window,
                m ? (v = n.relatedTarget || n.toElement,
                m = c,
                v = v ? zs(v) : null,
                v !== null && (A = po(v),
                v !== A || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null,
                v = c),
                m !== v)) {
                    if (E = rw,
                    R = "onMouseLeave",
                    _ = "onMouseEnter",
                    x = "mouse",
                    (t === "pointerout" || t === "pointerover") && (E = sw,
                    R = "onPointerLeave",
                    _ = "onPointerEnter",
                    x = "pointer"),
                    A = m == null ? y : Yo(m),
                    b = v == null ? y : Yo(v),
                    y = new E(R,x + "leave",m,n,d),
                    y.target = A,
                    y.relatedTarget = b,
                    R = null,
                    zs(d) === c && (E = new E(_,x + "enter",v,n,d),
                    E.target = b,
                    E.relatedTarget = A,
                    R = E),
                    A = R,
                    m && v)
                        t: {
                            for (E = m,
                            _ = v,
                            x = 0,
                            b = E; b; b = So(b))
                                x++;
                            for (b = 0,
                            R = _; R; R = So(R))
                                b++;
                            for (; 0 < x - b; )
                                E = So(E),
                                x--;
                            for (; 0 < b - x; )
                                _ = So(_),
                                b--;
                            for (; x--; ) {
                                if (E === _ || _ !== null && E === _.alternate)
                                    break t;
                                E = So(E),
                                _ = So(_)
                            }
                            E = null
                        }
                    else
                        E = null;
                    m !== null && mw(h, y, m, E, !1),
                    v !== null && A !== null && mw(h, A, v, E, !0)
                }
            }
            e: {
                if (y = c ? Yo(c) : window,
                m = y.nodeName && y.nodeName.toLowerCase(),
                m === "select" || m === "input" && y.type === "file")
                    var O = eA;
                else if (lw(y))
                    if (_b)
                        O = iA;
                    else {
                        O = nA;
                        var D = tA
                    }
                else
                    (m = y.nodeName) && m.toLowerCase() === "input" && (y.type === "checkbox" || y.type === "radio") && (O = rA);
                if (O && (O = O(t, c))) {
                    bb(h, O, n, d);
                    break e
                }
                D && D(t, y, c),
                t === "focusout" && (D = y._wrapperState) && D.controlled && y.type === "number" && z0(y, "number", y.value)
            }
            switch (D = c ? Yo(c) : window,
            t) {
            case "focusin":
                (lw(D) || D.contentEditable === "true") && (qo = D,
                Q0 = c,
                El = null);
                break;
            case "focusout":
                El = Q0 = qo = null;
                break;
            case "mousedown":
                J0 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                J0 = !1,
                fw(h, n, d);
                break;
            case "selectionchange":
                if (aA)
                    break;
            case "keydown":
            case "keyup":
                fw(h, n, d)
            }
            var z;
            if (sm)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var K = "onCompositionStart";
                        break e;
                    case "compositionend":
                        K = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        K = "onCompositionUpdate";
                        break e
                    }
                    K = void 0
                }
            else
                Ho ? wb(t, n) && (K = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (K = "onCompositionStart");
            K && (yb && n.locale !== "ko" && (Ho || K !== "onCompositionStart" ? K === "onCompositionEnd" && Ho && (z = mb()) : (Qi = d,
            nm = "value"in Qi ? Qi.value : Qi.textContent,
            Ho = !0)),
            D = pd(c, K),
            0 < D.length && (K = new iw(K,t,null,n,d),
            h.push({
                event: K,
                listeners: D
            }),
            z ? K.data = z : (z = vb(n),
            z !== null && (K.data = z)))),
            (z = YE ? ZE(t, n) : QE(t, n)) && (c = pd(c, "onBeforeInput"),
            0 < c.length && (d = new iw("onBeforeInput","beforeinput",null,n,d),
            h.push({
                event: d,
                listeners: c
            }),
            d.data = z))
        }
        Cb(h, e)
    })
}
function ql(t, e, n) {
    return {
        instance: t,
        listener: e,
        currentTarget: n
    }
}
function pd(t, e) {
    for (var n = e + "Capture", r = []; t !== null; ) {
        var i = t
          , s = i.stateNode;
        i.tag === 5 && s !== null && (i = s,
        s = Ul(t, n),
        s != null && r.unshift(ql(t, s, i)),
        s = Ul(t, e),
        s != null && r.push(ql(t, s, i))),
        t = t.return
    }
    return r
}
function So(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function mw(t, e, n, r, i) {
    for (var s = e._reactName, o = []; n !== null && n !== r; ) {
        var a = n
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === r)
            break;
        a.tag === 5 && c !== null && (a = c,
        i ? (l = Ul(n, s),
        l != null && o.unshift(ql(n, l, a))) : i || (l = Ul(n, s),
        l != null && o.push(ql(n, l, a)))),
        n = n.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var dA = /\r\n?/g
  , hA = /\u0000|\uFFFD/g;
function yw(t) {
    return (typeof t == "string" ? t : "" + t).replace(dA, `
`).replace(hA, "")
}
function qc(t, e, n) {
    if (e = yw(e),
    yw(t) !== e && n)
        throw Error(ee(425))
}
function gd() {}
var X0 = null
  , ep = null;
function tp(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var np = typeof setTimeout == "function" ? setTimeout : void 0
  , fA = typeof clearTimeout == "function" ? clearTimeout : void 0
  , ww = typeof Promise == "function" ? Promise : void 0
  , pA = typeof queueMicrotask == "function" ? queueMicrotask : typeof ww < "u" ? function(t) {
    return ww.resolve(null).then(t).catch(gA)
}
: np;
function gA(t) {
    setTimeout(function() {
        throw t
    })
}
function Pf(t, e) {
    var n = e
      , r = 0;
    do {
        var i = n.nextSibling;
        if (t.removeChild(n),
        i && i.nodeType === 8)
            if (n = i.data,
            n === "/$") {
                if (r === 0) {
                    t.removeChild(i),
                    $l(e);
                    return
                }
                r--
            } else
                n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    $l(e)
}
function os(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = t.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return t
}
function vw(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
        if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (e === 0)
                    return t;
                e--
            } else
                n === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var Da = Math.random().toString(36).slice(2)
  , Vr = "__reactFiber$" + Da
  , Gl = "__reactProps$" + Da
  , Mi = "__reactContainer$" + Da
  , rp = "__reactEvents$" + Da
  , mA = "__reactListeners$" + Da
  , yA = "__reactHandles$" + Da;
function zs(t) {
    var e = t[Vr];
    if (e)
        return e;
    for (var n = t.parentNode; n; ) {
        if (e = n[Mi] || n[Vr]) {
            if (n = e.alternate,
            e.child !== null || n !== null && n.child !== null)
                for (t = vw(t); t !== null; ) {
                    if (n = t[Vr])
                        return n;
                    t = vw(t)
                }
            return e
        }
        t = n,
        n = t.parentNode
    }
    return null
}
function mc(t) {
    return t = t[Vr] || t[Mi],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function Yo(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(ee(33))
}
function ch(t) {
    return t[Gl] || null
}
var ip = []
  , Zo = -1;
function ws(t) {
    return {
        current: t
    }
}
function ot(t) {
    0 > Zo || (t.current = ip[Zo],
    ip[Zo] = null,
    Zo--)
}
function tt(t, e) {
    Zo++,
    ip[Zo] = t.current,
    t.current = e
}
var ps = {}
  , Rn = ws(ps)
  , Gn = ws(!1)
  , to = ps;
function wa(t, e) {
    var n = t.type.contextTypes;
    if (!n)
        return ps;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
        return r.__reactInternalMemoizedMaskedChildContext;
    var i = {}, s;
    for (s in n)
        i[s] = e[s];
    return r && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = e,
    t.__reactInternalMemoizedMaskedChildContext = i),
    i
}
function Yn(t) {
    return t = t.childContextTypes,
    t != null
}
function md() {
    ot(Gn),
    ot(Rn)
}
function bw(t, e, n) {
    if (Rn.current !== ps)
        throw Error(ee(168));
    tt(Rn, e),
    tt(Gn, n)
}
function Lb(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes,
    typeof r.getChildContext != "function")
        return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e))
            throw Error(ee(108, tE(t) || "Unknown", i));
    return mt({}, n, r)
}
function yd(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || ps,
    to = Rn.current,
    tt(Rn, t),
    tt(Gn, Gn.current),
    !0
}
function _w(t, e, n) {
    var r = t.stateNode;
    if (!r)
        throw Error(ee(169));
    n ? (t = Lb(t, e, to),
    r.__reactInternalMemoizedMergedChildContext = t,
    ot(Gn),
    ot(Rn),
    tt(Rn, t)) : ot(Gn),
    tt(Gn, n)
}
var gi = null
  , uh = !1
  , Of = !1;
function jb(t) {
    gi === null ? gi = [t] : gi.push(t)
}
function wA(t) {
    uh = !0,
    jb(t)
}
function vs() {
    if (!Of && gi !== null) {
        Of = !0;
        var t = 0
          , e = Ke;
        try {
            var n = gi;
            for (Ke = 1; t < n.length; t++) {
                var r = n[t];
                do
                    r = r(!0);
                while (r !== null)
            }
            gi = null,
            uh = !1
        } catch (i) {
            throw gi !== null && (gi = gi.slice(t + 1)),
            sb(Jg, vs),
            i
        } finally {
            Ke = e,
            Of = !1
        }
    }
    return null
}
var Qo = []
  , Jo = 0
  , wd = null
  , vd = 0
  , mr = []
  , yr = 0
  , no = null
  , _i = 1
  , xi = "";
function As(t, e) {
    Qo[Jo++] = vd,
    Qo[Jo++] = wd,
    wd = t,
    vd = e
}
function Bb(t, e, n) {
    mr[yr++] = _i,
    mr[yr++] = xi,
    mr[yr++] = no,
    no = t;
    var r = _i;
    t = xi;
    var i = 32 - Lr(r) - 1;
    r &= ~(1 << i),
    n += 1;
    var s = 32 - Lr(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32),
        r >>= o,
        i -= o,
        _i = 1 << 32 - Lr(e) + i | n << i | r,
        xi = s + t
    } else
        _i = 1 << s | n << i | r,
        xi = t
}
function am(t) {
    t.return !== null && (As(t, 1),
    Bb(t, 1, 0))
}
function lm(t) {
    for (; t === wd; )
        wd = Qo[--Jo],
        Qo[Jo] = null,
        vd = Qo[--Jo],
        Qo[Jo] = null;
    for (; t === no; )
        no = mr[--yr],
        mr[yr] = null,
        xi = mr[--yr],
        mr[yr] = null,
        _i = mr[--yr],
        mr[yr] = null
}
var sr = null
  , rr = null
  , ut = !1
  , Cr = null;
function Pb(t, e) {
    var n = wr(5, null, null, 0);
    n.elementType = "DELETED",
    n.stateNode = e,
    n.return = t,
    e = t.deletions,
    e === null ? (t.deletions = [n],
    t.flags |= 16) : e.push(n)
}
function xw(t, e) {
    switch (t.tag) {
    case 5:
        var n = t.type;
        return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (t.stateNode = e,
        sr = t,
        rr = os(e.firstChild),
        !0) : !1;
    case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (t.stateNode = e,
        sr = t,
        rr = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (n = no !== null ? {
            id: _i,
            overflow: xi
        } : null,
        t.memoizedState = {
            dehydrated: e,
            treeContext: n,
            retryLane: 1073741824
        },
        n = wr(18, null, null, 0),
        n.stateNode = e,
        n.return = t,
        t.child = n,
        sr = t,
        rr = null,
        !0) : !1;
    default:
        return !1
    }
}
function sp(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function op(t) {
    if (ut) {
        var e = rr;
        if (e) {
            var n = e;
            if (!xw(t, e)) {
                if (sp(t))
                    throw Error(ee(418));
                e = os(n.nextSibling);
                var r = sr;
                e && xw(t, e) ? Pb(r, n) : (t.flags = t.flags & -4097 | 2,
                ut = !1,
                sr = t)
            }
        } else {
            if (sp(t))
                throw Error(ee(418));
            t.flags = t.flags & -4097 | 2,
            ut = !1,
            sr = t
        }
    }
}
function Sw(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    sr = t
}
function Gc(t) {
    if (t !== sr)
        return !1;
    if (!ut)
        return Sw(t),
        ut = !0,
        !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type,
    e = e !== "head" && e !== "body" && !tp(t.type, t.memoizedProps)),
    e && (e = rr)) {
        if (sp(t))
            throw Ob(),
            Error(ee(418));
        for (; e; )
            Pb(t, e),
            e = os(e.nextSibling)
    }
    if (Sw(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(ee(317));
        e: {
            for (t = t.nextSibling,
            e = 0; t; ) {
                if (t.nodeType === 8) {
                    var n = t.data;
                    if (n === "/$") {
                        if (e === 0) {
                            rr = os(t.nextSibling);
                            break e
                        }
                        e--
                    } else
                        n !== "$" && n !== "$!" && n !== "$?" || e++
                }
                t = t.nextSibling
            }
            rr = null
        }
    } else
        rr = sr ? os(t.stateNode.nextSibling) : null;
    return !0
}
function Ob() {
    for (var t = rr; t; )
        t = os(t.nextSibling)
}
function va() {
    rr = sr = null,
    ut = !1
}
function cm(t) {
    Cr === null ? Cr = [t] : Cr.push(t)
}
var vA = Ri.ReactCurrentBatchConfig;
function Ja(t, e, n) {
    if (t = n.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (n._owner) {
            if (n = n._owner,
            n) {
                if (n.tag !== 1)
                    throw Error(ee(309));
                var r = n.stateNode
            }
            if (!r)
                throw Error(ee(147, t));
            var i = r
              , s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof t != "string")
            throw Error(ee(284));
        if (!n._owner)
            throw Error(ee(290, t))
    }
    return t
}
function Yc(t, e) {
    throw t = Object.prototype.toString.call(e),
    Error(ee(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}
function kw(t) {
    var e = t._init;
    return e(t._payload)
}
function Db(t) {
    function e(_, x) {
        if (t) {
            var b = _.deletions;
            b === null ? (_.deletions = [x],
            _.flags |= 16) : b.push(x)
        }
    }
    function n(_, x) {
        if (!t)
            return null;
        for (; x !== null; )
            e(_, x),
            x = x.sibling;
        return null
    }
    function r(_, x) {
        for (_ = new Map; x !== null; )
            x.key !== null ? _.set(x.key, x) : _.set(x.index, x),
            x = x.sibling;
        return _
    }
    function i(_, x) {
        return _ = us(_, x),
        _.index = 0,
        _.sibling = null,
        _
    }
    function s(_, x, b) {
        return _.index = b,
        t ? (b = _.alternate,
        b !== null ? (b = b.index,
        b < x ? (_.flags |= 2,
        x) : b) : (_.flags |= 2,
        x)) : (_.flags |= 1048576,
        x)
    }
    function o(_) {
        return t && _.alternate === null && (_.flags |= 2),
        _
    }
    function a(_, x, b, R) {
        return x === null || x.tag !== 6 ? (x = Kf(b, _.mode, R),
        x.return = _,
        x) : (x = i(x, b),
        x.return = _,
        x)
    }
    function l(_, x, b, R) {
        var O = b.type;
        return O === Vo ? d(_, x, b.props.children, R, b.key) : x !== null && (x.elementType === O || typeof O == "object" && O !== null && O.$$typeof === Ki && kw(O) === x.type) ? (R = i(x, b.props),
        R.ref = Ja(_, x, b),
        R.return = _,
        R) : (R = Au(b.type, b.key, b.props, null, _.mode, R),
        R.ref = Ja(_, x, b),
        R.return = _,
        R)
    }
    function c(_, x, b, R) {
        return x === null || x.tag !== 4 || x.stateNode.containerInfo !== b.containerInfo || x.stateNode.implementation !== b.implementation ? (x = Vf(b, _.mode, R),
        x.return = _,
        x) : (x = i(x, b.children || []),
        x.return = _,
        x)
    }
    function d(_, x, b, R, O) {
        return x === null || x.tag !== 7 ? (x = Xs(b, _.mode, R, O),
        x.return = _,
        x) : (x = i(x, b),
        x.return = _,
        x)
    }
    function h(_, x, b) {
        if (typeof x == "string" && x !== "" || typeof x == "number")
            return x = Kf("" + x, _.mode, b),
            x.return = _,
            x;
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
            case Dc:
                return b = Au(x.type, x.key, x.props, null, _.mode, b),
                b.ref = Ja(_, null, x),
                b.return = _,
                b;
            case Ko:
                return x = Vf(x, _.mode, b),
                x.return = _,
                x;
            case Ki:
                var R = x._init;
                return h(_, R(x._payload), b)
            }
            if (ol(x) || qa(x))
                return x = Xs(x, _.mode, b, null),
                x.return = _,
                x;
            Yc(_, x)
        }
        return null
    }
    function y(_, x, b, R) {
        var O = x !== null ? x.key : null;
        if (typeof b == "string" && b !== "" || typeof b == "number")
            return O !== null ? null : a(_, x, "" + b, R);
        if (typeof b == "object" && b !== null) {
            switch (b.$$typeof) {
            case Dc:
                return b.key === O ? l(_, x, b, R) : null;
            case Ko:
                return b.key === O ? c(_, x, b, R) : null;
            case Ki:
                return O = b._init,
                y(_, x, O(b._payload), R)
            }
            if (ol(b) || qa(b))
                return O !== null ? null : d(_, x, b, R, null);
            Yc(_, b)
        }
        return null
    }
    function m(_, x, b, R, O) {
        if (typeof R == "string" && R !== "" || typeof R == "number")
            return _ = _.get(b) || null,
            a(x, _, "" + R, O);
        if (typeof R == "object" && R !== null) {
            switch (R.$$typeof) {
            case Dc:
                return _ = _.get(R.key === null ? b : R.key) || null,
                l(x, _, R, O);
            case Ko:
                return _ = _.get(R.key === null ? b : R.key) || null,
                c(x, _, R, O);
            case Ki:
                var D = R._init;
                return m(_, x, b, D(R._payload), O)
            }
            if (ol(R) || qa(R))
                return _ = _.get(b) || null,
                d(x, _, R, O, null);
            Yc(x, R)
        }
        return null
    }
    function v(_, x, b, R) {
        for (var O = null, D = null, z = x, K = x = 0, F = null; z !== null && K < b.length; K++) {
            z.index > K ? (F = z,
            z = null) : F = z.sibling;
            var G = y(_, z, b[K], R);
            if (G === null) {
                z === null && (z = F);
                break
            }
            t && z && G.alternate === null && e(_, z),
            x = s(G, x, K),
            D === null ? O = G : D.sibling = G,
            D = G,
            z = F
        }
        if (K === b.length)
            return n(_, z),
            ut && As(_, K),
            O;
        if (z === null) {
            for (; K < b.length; K++)
                z = h(_, b[K], R),
                z !== null && (x = s(z, x, K),
                D === null ? O = z : D.sibling = z,
                D = z);
            return ut && As(_, K),
            O
        }
        for (z = r(_, z); K < b.length; K++)
            F = m(z, _, K, b[K], R),
            F !== null && (t && F.alternate !== null && z.delete(F.key === null ? K : F.key),
            x = s(F, x, K),
            D === null ? O = F : D.sibling = F,
            D = F);
        return t && z.forEach(function(Z) {
            return e(_, Z)
        }),
        ut && As(_, K),
        O
    }
    function E(_, x, b, R) {
        var O = qa(b);
        if (typeof O != "function")
            throw Error(ee(150));
        if (b = O.call(b),
        b == null)
            throw Error(ee(151));
        for (var D = O = null, z = x, K = x = 0, F = null, G = b.next(); z !== null && !G.done; K++,
        G = b.next()) {
            z.index > K ? (F = z,
            z = null) : F = z.sibling;
            var Z = y(_, z, G.value, R);
            if (Z === null) {
                z === null && (z = F);
                break
            }
            t && z && Z.alternate === null && e(_, z),
            x = s(Z, x, K),
            D === null ? O = Z : D.sibling = Z,
            D = Z,
            z = F
        }
        if (G.done)
            return n(_, z),
            ut && As(_, K),
            O;
        if (z === null) {
            for (; !G.done; K++,
            G = b.next())
                G = h(_, G.value, R),
                G !== null && (x = s(G, x, K),
                D === null ? O = G : D.sibling = G,
                D = G);
            return ut && As(_, K),
            O
        }
        for (z = r(_, z); !G.done; K++,
        G = b.next())
            G = m(z, _, K, G.value, R),
            G !== null && (t && G.alternate !== null && z.delete(G.key === null ? K : G.key),
            x = s(G, x, K),
            D === null ? O = G : D.sibling = G,
            D = G);
        return t && z.forEach(function(X) {
            return e(_, X)
        }),
        ut && As(_, K),
        O
    }
    function A(_, x, b, R) {
        if (typeof b == "object" && b !== null && b.type === Vo && b.key === null && (b = b.props.children),
        typeof b == "object" && b !== null) {
            switch (b.$$typeof) {
            case Dc:
                e: {
                    for (var O = b.key, D = x; D !== null; ) {
                        if (D.key === O) {
                            if (O = b.type,
                            O === Vo) {
                                if (D.tag === 7) {
                                    n(_, D.sibling),
                                    x = i(D, b.props.children),
                                    x.return = _,
                                    _ = x;
                                    break e
                                }
                            } else if (D.elementType === O || typeof O == "object" && O !== null && O.$$typeof === Ki && kw(O) === D.type) {
                                n(_, D.sibling),
                                x = i(D, b.props),
                                x.ref = Ja(_, D, b),
                                x.return = _,
                                _ = x;
                                break e
                            }
                            n(_, D);
                            break
                        } else
                            e(_, D);
                        D = D.sibling
                    }
                    b.type === Vo ? (x = Xs(b.props.children, _.mode, R, b.key),
                    x.return = _,
                    _ = x) : (R = Au(b.type, b.key, b.props, null, _.mode, R),
                    R.ref = Ja(_, x, b),
                    R.return = _,
                    _ = R)
                }
                return o(_);
            case Ko:
                e: {
                    for (D = b.key; x !== null; ) {
                        if (x.key === D)
                            if (x.tag === 4 && x.stateNode.containerInfo === b.containerInfo && x.stateNode.implementation === b.implementation) {
                                n(_, x.sibling),
                                x = i(x, b.children || []),
                                x.return = _,
                                _ = x;
                                break e
                            } else {
                                n(_, x);
                                break
                            }
                        else
                            e(_, x);
                        x = x.sibling
                    }
                    x = Vf(b, _.mode, R),
                    x.return = _,
                    _ = x
                }
                return o(_);
            case Ki:
                return D = b._init,
                A(_, x, D(b._payload), R)
            }
            if (ol(b))
                return v(_, x, b, R);
            if (qa(b))
                return E(_, x, b, R);
            Yc(_, b)
        }
        return typeof b == "string" && b !== "" || typeof b == "number" ? (b = "" + b,
        x !== null && x.tag === 6 ? (n(_, x.sibling),
        x = i(x, b),
        x.return = _,
        _ = x) : (n(_, x),
        x = Kf(b, _.mode, R),
        x.return = _,
        _ = x),
        o(_)) : n(_, x)
    }
    return A
}
var ba = Db(!0)
  , zb = Db(!1)
  , bd = ws(null)
  , _d = null
  , Xo = null
  , um = null;
function dm() {
    um = Xo = _d = null
}
function hm(t) {
    var e = bd.current;
    ot(bd),
    t._currentValue = e
}
function ap(t, e, n) {
    for (; t !== null; ) {
        var r = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e,
        r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
        t === n)
            break;
        t = t.return
    }
}
function ca(t, e) {
    _d = t,
    um = Xo = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & e && (Hn = !0),
    t.firstContext = null)
}
function _r(t) {
    var e = t._currentValue;
    if (um !== t)
        if (t = {
            context: t,
            memoizedValue: e,
            next: null
        },
        Xo === null) {
            if (_d === null)
                throw Error(ee(308));
            Xo = t,
            _d.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            Xo = Xo.next = t;
    return e
}
var Us = null;
function fm(t) {
    Us === null ? Us = [t] : Us.push(t)
}
function Ub(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n,
    fm(e)) : (n.next = i.next,
    i.next = n),
    e.interleaved = n,
    Ti(t, r)
}
function Ti(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e),
    n = t,
    t = t.return; t !== null; )
        t.childLanes |= e,
        n = t.alternate,
        n !== null && (n.childLanes |= e),
        n = t,
        t = t.return;
    return n.tag === 3 ? n.stateNode : null
}
var Vi = !1;
function pm(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function Wb(t, e) {
    t = t.updateQueue,
    e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function Ai(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function as(t, e, n) {
    var r = t.updateQueue;
    if (r === null)
        return null;
    if (r = r.shared,
    Oe & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next,
        i.next = e),
        r.pending = e,
        Ti(t, n)
    }
    return i = r.interleaved,
    i === null ? (e.next = e,
    fm(r)) : (e.next = i.next,
    i.next = e),
    r.interleaved = e,
    Ti(t, n)
}
function bu(t, e, n) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (n & 4194240) !== 0)) {
        var r = e.lanes;
        r &= t.pendingLanes,
        n |= r,
        e.lanes = n,
        Xg(t, n)
    }
}
function Ew(t, e) {
    var n = t.updateQueue
      , r = t.alternate;
    if (r !== null && (r = r.updateQueue,
    n === r)) {
        var i = null
          , s = null;
        if (n = n.firstBaseUpdate,
        n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o,
                n = n.next
            } while (n !== null);
            s === null ? i = s = e : s = s.next = e
        } else
            i = s = e;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        },
        t.updateQueue = n;
        return
    }
    t = n.lastBaseUpdate,
    t === null ? n.firstBaseUpdate = e : t.next = e,
    n.lastBaseUpdate = e
}
function xd(t, e, n, r) {
    var i = t.updateQueue;
    Vi = !1;
    var s = i.firstBaseUpdate
      , o = i.lastBaseUpdate
      , a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var d = t.alternate;
        d !== null && (d = d.updateQueue,
        a = d.lastBaseUpdate,
        a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c,
        d.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = i.baseState;
        o = 0,
        d = c = l = null,
        a = s;
        do {
            var y = a.lane
              , m = a.eventTime;
            if ((r & y) === y) {
                d !== null && (d = d.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = t
                      , E = a;
                    switch (y = e,
                    m = n,
                    E.tag) {
                    case 1:
                        if (v = E.payload,
                        typeof v == "function") {
                            h = v.call(m, h, y);
                            break e
                        }
                        h = v;
                        break e;
                    case 3:
                        v.flags = v.flags & -65537 | 128;
                    case 0:
                        if (v = E.payload,
                        y = typeof v == "function" ? v.call(m, h, y) : v,
                        y == null)
                            break e;
                        h = mt({}, h, y);
                        break e;
                    case 2:
                        Vi = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64,
                y = i.effects,
                y === null ? i.effects = [a] : y.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: y,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                d === null ? (c = d = m,
                l = h) : d = d.next = m,
                o |= y;
            if (a = a.next,
            a === null) {
                if (a = i.shared.pending,
                a === null)
                    break;
                y = a,
                a = y.next,
                y.next = null,
                i.lastBaseUpdate = y,
                i.shared.pending = null
            }
        } while (1);
        if (d === null && (l = h),
        i.baseState = l,
        i.firstBaseUpdate = c,
        i.lastBaseUpdate = d,
        e = i.shared.interleaved,
        e !== null) {
            i = e;
            do
                o |= i.lane,
                i = i.next;
            while (i !== e)
        } else
            s === null && (i.shared.lanes = 0);
        io |= o,
        t.lanes = o,
        t.memoizedState = h
    }
}
function Aw(t, e, n) {
    if (t = e.effects,
    e.effects = null,
    t !== null)
        for (e = 0; e < t.length; e++) {
            var r = t[e]
              , i = r.callback;
            if (i !== null) {
                if (r.callback = null,
                r = n,
                typeof i != "function")
                    throw Error(ee(191, i));
                i.call(r)
            }
        }
}
var yc = {}
  , ei = ws(yc)
  , Yl = ws(yc)
  , Zl = ws(yc);
function Ws(t) {
    if (t === yc)
        throw Error(ee(174));
    return t
}
function gm(t, e) {
    switch (tt(Zl, e),
    tt(Yl, t),
    tt(ei, yc),
    t = e.nodeType,
    t) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : W0(null, "");
        break;
    default:
        t = t === 8 ? e.parentNode : e,
        e = t.namespaceURI || null,
        t = t.tagName,
        e = W0(e, t)
    }
    ot(ei),
    tt(ei, e)
}
function _a() {
    ot(ei),
    ot(Yl),
    ot(Zl)
}
function Fb(t) {
    Ws(Zl.current);
    var e = Ws(ei.current)
      , n = W0(e, t.type);
    e !== n && (tt(Yl, t),
    tt(ei, n))
}
function mm(t) {
    Yl.current === t && (ot(ei),
    ot(Yl))
}
var ft = ws(0);
function Sd(t) {
    for (var e = t; e !== null; ) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated,
            n === null || n.data === "$?" || n.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === t)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var Df = [];
function ym() {
    for (var t = 0; t < Df.length; t++)
        Df[t]._workInProgressVersionPrimary = null;
    Df.length = 0
}
var _u = Ri.ReactCurrentDispatcher
  , zf = Ri.ReactCurrentBatchConfig
  , ro = 0
  , gt = null
  , en = null
  , an = null
  , kd = !1
  , Al = !1
  , Ql = 0
  , bA = 0;
function bn() {
    throw Error(ee(321))
}
function wm(t, e) {
    if (e === null)
        return !1;
    for (var n = 0; n < e.length && n < t.length; n++)
        if (!Pr(t[n], e[n]))
            return !1;
    return !0
}
function vm(t, e, n, r, i, s) {
    if (ro = s,
    gt = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    _u.current = t === null || t.memoizedState === null ? kA : EA,
    t = n(r, i),
    Al) {
        s = 0;
        do {
            if (Al = !1,
            Ql = 0,
            25 <= s)
                throw Error(ee(301));
            s += 1,
            an = en = null,
            e.updateQueue = null,
            _u.current = AA,
            t = n(r, i)
        } while (Al)
    }
    if (_u.current = Ed,
    e = en !== null && en.next !== null,
    ro = 0,
    an = en = gt = null,
    kd = !1,
    e)
        throw Error(ee(300));
    return t
}
function bm() {
    var t = Ql !== 0;
    return Ql = 0,
    t
}
function Wr() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return an === null ? gt.memoizedState = an = t : an = an.next = t,
    an
}
function xr() {
    if (en === null) {
        var t = gt.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = en.next;
    var e = an === null ? gt.memoizedState : an.next;
    if (e !== null)
        an = e,
        en = t;
    else {
        if (t === null)
            throw Error(ee(310));
        en = t,
        t = {
            memoizedState: en.memoizedState,
            baseState: en.baseState,
            baseQueue: en.baseQueue,
            queue: en.queue,
            next: null
        },
        an === null ? gt.memoizedState = an = t : an = an.next = t
    }
    return an
}
function Jl(t, e) {
    return typeof e == "function" ? e(t) : e
}
function Uf(t) {
    var e = xr()
      , n = e.queue;
    if (n === null)
        throw Error(ee(311));
    n.lastRenderedReducer = t;
    var r = en
      , i = r.baseQueue
      , s = n.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next,
            s.next = o
        }
        r.baseQueue = i = s,
        n.pending = null
    }
    if (i !== null) {
        s = i.next,
        r = r.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var d = c.lane;
            if ((ro & d) === d)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                r = c.hasEagerState ? c.eagerState : t(r, c.action);
            else {
                var h = {
                    lane: d,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = r) : l = l.next = h,
                gt.lanes |= d,
                io |= d
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = r : l.next = a,
        Pr(r, e.memoizedState) || (Hn = !0),
        e.memoizedState = r,
        e.baseState = o,
        e.baseQueue = l,
        n.lastRenderedState = r
    }
    if (t = n.interleaved,
    t !== null) {
        i = t;
        do
            s = i.lane,
            gt.lanes |= s,
            io |= s,
            i = i.next;
        while (i !== t)
    } else
        i === null && (n.lanes = 0);
    return [e.memoizedState, n.dispatch]
}
function Wf(t) {
    var e = xr()
      , n = e.queue;
    if (n === null)
        throw Error(ee(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch
      , i = n.pending
      , s = e.memoizedState;
    if (i !== null) {
        n.pending = null;
        var o = i = i.next;
        do
            s = t(s, o.action),
            o = o.next;
        while (o !== i);
        Pr(s, e.memoizedState) || (Hn = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        n.lastRenderedState = s
    }
    return [s, r]
}
function $b() {}
function Kb(t, e) {
    var n = gt
      , r = xr()
      , i = e()
      , s = !Pr(r.memoizedState, i);
    if (s && (r.memoizedState = i,
    Hn = !0),
    r = r.queue,
    _m(qb.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || s || an !== null && an.memoizedState.tag & 1) {
        if (n.flags |= 2048,
        Xl(9, Hb.bind(null, n, r, i, e), void 0, null),
        cn === null)
            throw Error(ee(349));
        ro & 30 || Vb(n, e, i)
    }
    return i
}
function Vb(t, e, n) {
    t.flags |= 16384,
    t = {
        getSnapshot: e,
        value: n
    },
    e = gt.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    gt.updateQueue = e,
    e.stores = [t]) : (n = e.stores,
    n === null ? e.stores = [t] : n.push(t))
}
function Hb(t, e, n, r) {
    e.value = n,
    e.getSnapshot = r,
    Gb(e) && Yb(t)
}
function qb(t, e, n) {
    return n(function() {
        Gb(e) && Yb(t)
    })
}
function Gb(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !Pr(t, n)
    } catch {
        return !0
    }
}
function Yb(t) {
    var e = Ti(t, 1);
    e !== null && jr(e, t, 1, -1)
}
function Iw(t) {
    var e = Wr();
    return typeof t == "function" && (t = t()),
    e.memoizedState = e.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Jl,
        lastRenderedState: t
    },
    e.queue = t,
    t = t.dispatch = SA.bind(null, gt, t),
    [e.memoizedState, t]
}
function Xl(t, e, n, r) {
    return t = {
        tag: t,
        create: e,
        destroy: n,
        deps: r,
        next: null
    },
    e = gt.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    gt.updateQueue = e,
    e.lastEffect = t.next = t) : (n = e.lastEffect,
    n === null ? e.lastEffect = t.next = t : (r = n.next,
    n.next = t,
    t.next = r,
    e.lastEffect = t)),
    t
}
function Zb() {
    return xr().memoizedState
}
function xu(t, e, n, r) {
    var i = Wr();
    gt.flags |= t,
    i.memoizedState = Xl(1 | e, n, void 0, r === void 0 ? null : r)
}
function dh(t, e, n, r) {
    var i = xr();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (en !== null) {
        var o = en.memoizedState;
        if (s = o.destroy,
        r !== null && wm(r, o.deps)) {
            i.memoizedState = Xl(e, n, s, r);
            return
        }
    }
    gt.flags |= t,
    i.memoizedState = Xl(1 | e, n, s, r)
}
function Mw(t, e) {
    return xu(8390656, 8, t, e)
}
function _m(t, e) {
    return dh(2048, 8, t, e)
}
function Qb(t, e) {
    return dh(4, 2, t, e)
}
function Jb(t, e) {
    return dh(4, 4, t, e)
}
function Xb(t, e) {
    if (typeof e == "function")
        return t = t(),
        e(t),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return t = t(),
        e.current = t,
        function() {
            e.current = null
        }
}
function e_(t, e, n) {
    return n = n != null ? n.concat([t]) : null,
    dh(4, 4, Xb.bind(null, e, t), n)
}
function xm() {}
function t_(t, e) {
    var n = xr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && wm(e, r[1]) ? r[0] : (n.memoizedState = [t, e],
    t)
}
function n_(t, e) {
    var n = xr();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && wm(e, r[1]) ? r[0] : (t = t(),
    n.memoizedState = [t, e],
    t)
}
function r_(t, e, n) {
    return ro & 21 ? (Pr(n, e) || (n = lb(),
    gt.lanes |= n,
    io |= n,
    t.baseState = !0),
    e) : (t.baseState && (t.baseState = !1,
    Hn = !0),
    t.memoizedState = n)
}
function _A(t, e) {
    var n = Ke;
    Ke = n !== 0 && 4 > n ? n : 4,
    t(!0);
    var r = zf.transition;
    zf.transition = {};
    try {
        t(!1),
        e()
    } finally {
        Ke = n,
        zf.transition = r
    }
}
function i_() {
    return xr().memoizedState
}
function xA(t, e, n) {
    var r = cs(t);
    if (n = {
        lane: r,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    s_(t))
        o_(e, n);
    else if (n = Ub(t, e, n, r),
    n !== null) {
        var i = Pn();
        jr(n, t, r, i),
        a_(n, e, r)
    }
}
function SA(t, e, n) {
    var r = cs(t)
      , i = {
        lane: r,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (s_(t))
        o_(e, i);
    else {
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, n);
                if (i.hasEagerState = !0,
                i.eagerState = a,
                Pr(a, o)) {
                    var l = e.interleaved;
                    l === null ? (i.next = i,
                    fm(e)) : (i.next = l.next,
                    l.next = i),
                    e.interleaved = i;
                    return
                }
            } catch {} finally {}
        n = Ub(t, e, i, r),
        n !== null && (i = Pn(),
        jr(n, t, r, i),
        a_(n, e, r))
    }
}
function s_(t) {
    var e = t.alternate;
    return t === gt || e !== null && e === gt
}
function o_(t, e) {
    Al = kd = !0;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next,
    n.next = e),
    t.pending = e
}
function a_(t, e, n) {
    if (n & 4194240) {
        var r = e.lanes;
        r &= t.pendingLanes,
        n |= r,
        e.lanes = n,
        Xg(t, n)
    }
}
var Ed = {
    readContext: _r,
    useCallback: bn,
    useContext: bn,
    useEffect: bn,
    useImperativeHandle: bn,
    useInsertionEffect: bn,
    useLayoutEffect: bn,
    useMemo: bn,
    useReducer: bn,
    useRef: bn,
    useState: bn,
    useDebugValue: bn,
    useDeferredValue: bn,
    useTransition: bn,
    useMutableSource: bn,
    useSyncExternalStore: bn,
    useId: bn,
    unstable_isNewReconciler: !1
}
  , kA = {
    readContext: _r,
    useCallback: function(t, e) {
        return Wr().memoizedState = [t, e === void 0 ? null : e],
        t
    },
    useContext: _r,
    useEffect: Mw,
    useImperativeHandle: function(t, e, n) {
        return n = n != null ? n.concat([t]) : null,
        xu(4194308, 4, Xb.bind(null, e, t), n)
    },
    useLayoutEffect: function(t, e) {
        return xu(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
        return xu(4, 2, t, e)
    },
    useMemo: function(t, e) {
        var n = Wr();
        return e = e === void 0 ? null : e,
        t = t(),
        n.memoizedState = [t, e],
        t
    },
    useReducer: function(t, e, n) {
        var r = Wr();
        return e = n !== void 0 ? n(e) : e,
        r.memoizedState = r.baseState = e,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
        },
        r.queue = t,
        t = t.dispatch = xA.bind(null, gt, t),
        [r.memoizedState, t]
    },
    useRef: function(t) {
        var e = Wr();
        return t = {
            current: t
        },
        e.memoizedState = t
    },
    useState: Iw,
    useDebugValue: xm,
    useDeferredValue: function(t) {
        return Wr().memoizedState = t
    },
    useTransition: function() {
        var t = Iw(!1)
          , e = t[0];
        return t = _A.bind(null, t[1]),
        Wr().memoizedState = t,
        [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, n) {
        var r = gt
          , i = Wr();
        if (ut) {
            if (n === void 0)
                throw Error(ee(407));
            n = n()
        } else {
            if (n = e(),
            cn === null)
                throw Error(ee(349));
            ro & 30 || Vb(r, e, n)
        }
        i.memoizedState = n;
        var s = {
            value: n,
            getSnapshot: e
        };
        return i.queue = s,
        Mw(qb.bind(null, r, s, t), [t]),
        r.flags |= 2048,
        Xl(9, Hb.bind(null, r, s, n, e), void 0, null),
        n
    },
    useId: function() {
        var t = Wr()
          , e = cn.identifierPrefix;
        if (ut) {
            var n = xi
              , r = _i;
            n = (r & ~(1 << 32 - Lr(r) - 1)).toString(32) + n,
            e = ":" + e + "R" + n,
            n = Ql++,
            0 < n && (e += "H" + n.toString(32)),
            e += ":"
        } else
            n = bA++,
            e = ":" + e + "r" + n.toString(32) + ":";
        return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , EA = {
    readContext: _r,
    useCallback: t_,
    useContext: _r,
    useEffect: _m,
    useImperativeHandle: e_,
    useInsertionEffect: Qb,
    useLayoutEffect: Jb,
    useMemo: n_,
    useReducer: Uf,
    useRef: Zb,
    useState: function() {
        return Uf(Jl)
    },
    useDebugValue: xm,
    useDeferredValue: function(t) {
        var e = xr();
        return r_(e, en.memoizedState, t)
    },
    useTransition: function() {
        var t = Uf(Jl)[0]
          , e = xr().memoizedState;
        return [t, e]
    },
    useMutableSource: $b,
    useSyncExternalStore: Kb,
    useId: i_,
    unstable_isNewReconciler: !1
}
  , AA = {
    readContext: _r,
    useCallback: t_,
    useContext: _r,
    useEffect: _m,
    useImperativeHandle: e_,
    useInsertionEffect: Qb,
    useLayoutEffect: Jb,
    useMemo: n_,
    useReducer: Wf,
    useRef: Zb,
    useState: function() {
        return Wf(Jl)
    },
    useDebugValue: xm,
    useDeferredValue: function(t) {
        var e = xr();
        return en === null ? e.memoizedState = t : r_(e, en.memoizedState, t)
    },
    useTransition: function() {
        var t = Wf(Jl)[0]
          , e = xr().memoizedState;
        return [t, e]
    },
    useMutableSource: $b,
    useSyncExternalStore: Kb,
    useId: i_,
    unstable_isNewReconciler: !1
};
function Ir(t, e) {
    if (t && t.defaultProps) {
        e = mt({}, e),
        t = t.defaultProps;
        for (var n in t)
            e[n] === void 0 && (e[n] = t[n]);
        return e
    }
    return e
}
function lp(t, e, n, r) {
    e = t.memoizedState,
    n = n(r, e),
    n = n == null ? e : mt({}, e, n),
    t.memoizedState = n,
    t.lanes === 0 && (t.updateQueue.baseState = n)
}
var hh = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? po(t) === t : !1
    },
    enqueueSetState: function(t, e, n) {
        t = t._reactInternals;
        var r = Pn()
          , i = cs(t)
          , s = Ai(r, i);
        s.payload = e,
        n != null && (s.callback = n),
        e = as(t, s, i),
        e !== null && (jr(e, t, i, r),
        bu(e, t, i))
    },
    enqueueReplaceState: function(t, e, n) {
        t = t._reactInternals;
        var r = Pn()
          , i = cs(t)
          , s = Ai(r, i);
        s.tag = 1,
        s.payload = e,
        n != null && (s.callback = n),
        e = as(t, s, i),
        e !== null && (jr(e, t, i, r),
        bu(e, t, i))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var n = Pn()
          , r = cs(t)
          , i = Ai(n, r);
        i.tag = 2,
        e != null && (i.callback = e),
        e = as(t, i, r),
        e !== null && (jr(e, t, r, n),
        bu(e, t, r))
    }
};
function Tw(t, e, n, r, i, s, o) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Vl(n, r) || !Vl(i, s) : !0
}
function l_(t, e, n) {
    var r = !1
      , i = ps
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = _r(s) : (i = Yn(e) ? to : Rn.current,
    r = e.contextTypes,
    s = (r = r != null) ? wa(t, i) : ps),
    e = new e(n,s),
    t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = hh,
    t.stateNode = e,
    e._reactInternals = t,
    r && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = i,
    t.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function Nw(t, e, n, r) {
    t = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && hh.enqueueReplaceState(e, e.state, null)
}
function cp(t, e, n, r) {
    var i = t.stateNode;
    i.props = n,
    i.state = t.memoizedState,
    i.refs = {},
    pm(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = _r(s) : (s = Yn(e) ? to : Rn.current,
    i.context = wa(t, s)),
    i.state = t.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (lp(t, e, s, n),
    i.state = t.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state,
    typeof i.componentWillMount == "function" && i.componentWillMount(),
    typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
    e !== i.state && hh.enqueueReplaceState(i, i.state, null),
    xd(t, n, i, r),
    i.state = t.memoizedState),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308)
}
function xa(t, e) {
    try {
        var n = ""
          , r = e;
        do
            n += eE(r),
            r = r.return;
        while (r);
        var i = n
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: i,
        digest: null
    }
}
function Ff(t, e, n) {
    return {
        value: t,
        source: null,
        stack: n ?? null,
        digest: e ?? null
    }
}
function up(t, e) {
    try {
        console.error(e.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var IA = typeof WeakMap == "function" ? WeakMap : Map;
function c_(t, e, n) {
    n = Ai(-1, n),
    n.tag = 3,
    n.payload = {
        element: null
    };
    var r = e.value;
    return n.callback = function() {
        Id || (Id = !0,
        bp = r),
        up(t, e)
    }
    ,
    n
}
function u_(t, e, n) {
    n = Ai(-1, n),
    n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        n.payload = function() {
            return r(i)
        }
        ,
        n.callback = function() {
            up(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        up(t, e),
        typeof r != "function" && (ls === null ? ls = new Set([this]) : ls.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    n
}
function Cw(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
        r = t.pingCache = new IA;
        var i = new Set;
        r.set(e, i)
    } else
        i = r.get(e),
        i === void 0 && (i = new Set,
        r.set(e, i));
    i.has(n) || (i.add(n),
    t = WA.bind(null, t, e, n),
    e.then(t, t))
}
function Rw(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function Lw(t, e, n, r, i) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = i,
    t) : (t === e ? t.flags |= 65536 : (t.flags |= 128,
    n.flags |= 131072,
    n.flags &= -52805,
    n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Ai(-1, 1),
    e.tag = 2,
    as(n, e, 1))),
    n.lanes |= 1),
    t)
}
var MA = Ri.ReactCurrentOwner
  , Hn = !1;
function jn(t, e, n, r) {
    e.child = t === null ? zb(e, null, n, r) : ba(e, t.child, n, r)
}
function jw(t, e, n, r, i) {
    n = n.render;
    var s = e.ref;
    return ca(e, i),
    r = vm(t, e, n, r, s, i),
    n = bm(),
    t !== null && !Hn ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~i,
    Ni(t, e, i)) : (ut && n && am(e),
    e.flags |= 1,
    jn(t, e, r, i),
    e.child)
}
function Bw(t, e, n, r, i) {
    if (t === null) {
        var s = n.type;
        return typeof s == "function" && !Nm(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        d_(t, e, s, r, i)) : (t = Au(n.type, null, r, e, e.mode, i),
        t.ref = e.ref,
        t.return = e,
        e.child = t)
    }
    if (s = t.child,
    !(t.lanes & i)) {
        var o = s.memoizedProps;
        if (n = n.compare,
        n = n !== null ? n : Vl,
        n(o, r) && t.ref === e.ref)
            return Ni(t, e, i)
    }
    return e.flags |= 1,
    t = us(s, r),
    t.ref = e.ref,
    t.return = e,
    e.child = t
}
function d_(t, e, n, r, i) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (Vl(s, r) && t.ref === e.ref)
            if (Hn = !1,
            e.pendingProps = r = s,
            (t.lanes & i) !== 0)
                t.flags & 131072 && (Hn = !0);
            else
                return e.lanes = t.lanes,
                Ni(t, e, i)
    }
    return dp(t, e, n, r, i)
}
function h_(t, e, n) {
    var r = e.pendingProps
      , i = r.children
      , s = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            tt(ta, Xn),
            Xn |= n;
        else {
            if (!(n & 1073741824))
                return t = s !== null ? s.baseLanes | n : n,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                tt(ta, Xn),
                Xn |= t,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            r = s !== null ? s.baseLanes : n,
            tt(ta, Xn),
            Xn |= r
        }
    else
        s !== null ? (r = s.baseLanes | n,
        e.memoizedState = null) : r = n,
        tt(ta, Xn),
        Xn |= r;
    return jn(t, e, i, n),
    e.child
}
function f_(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512,
    e.flags |= 2097152)
}
function dp(t, e, n, r, i) {
    var s = Yn(n) ? to : Rn.current;
    return s = wa(e, s),
    ca(e, i),
    n = vm(t, e, n, r, s, i),
    r = bm(),
    t !== null && !Hn ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~i,
    Ni(t, e, i)) : (ut && r && am(e),
    e.flags |= 1,
    jn(t, e, n, i),
    e.child)
}
function Pw(t, e, n, r, i) {
    if (Yn(n)) {
        var s = !0;
        yd(e)
    } else
        s = !1;
    if (ca(e, i),
    e.stateNode === null)
        Su(t, e),
        l_(e, n, r),
        cp(e, n, r, i),
        r = !0;
    else if (t === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = n.contextType;
        typeof c == "object" && c !== null ? c = _r(c) : (c = Yn(n) ? to : Rn.current,
        c = wa(e, c));
        var d = n.getDerivedStateFromProps
          , h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== c) && Nw(e, o, r, c),
        Vi = !1;
        var y = e.memoizedState;
        o.state = y,
        xd(e, r, o, i),
        l = e.memoizedState,
        a !== r || y !== l || Gn.current || Vi ? (typeof d == "function" && (lp(e, n, d, r),
        l = e.memoizedState),
        (a = Vi || Tw(e, n, a, r, y, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = r,
        e.memoizedState = l),
        o.props = r,
        o.state = l,
        o.context = c,
        r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        r = !1)
    } else {
        o = e.stateNode,
        Wb(t, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : Ir(e.type, a),
        o.props = c,
        h = e.pendingProps,
        y = o.context,
        l = n.contextType,
        typeof l == "object" && l !== null ? l = _r(l) : (l = Yn(n) ? to : Rn.current,
        l = wa(e, l));
        var m = n.getDerivedStateFromProps;
        (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || y !== l) && Nw(e, o, r, l),
        Vi = !1,
        y = e.memoizedState,
        o.state = y,
        xd(e, r, o, i);
        var v = e.memoizedState;
        a !== h || y !== v || Gn.current || Vi ? (typeof m == "function" && (lp(e, n, m, r),
        v = e.memoizedState),
        (c = Vi || Tw(e, n, c, r, y, v, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, v, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, v, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && y === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && y === t.memoizedState || (e.flags |= 1024),
        e.memoizedProps = r,
        e.memoizedState = v),
        o.props = r,
        o.state = v,
        o.context = l,
        r = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && y === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && y === t.memoizedState || (e.flags |= 1024),
        r = !1)
    }
    return hp(t, e, n, r, s, i)
}
function hp(t, e, n, r, i, s) {
    f_(t, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o)
        return i && _w(e, n, !1),
        Ni(t, e, s);
    r = e.stateNode,
    MA.current = e;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1,
    t !== null && o ? (e.child = ba(e, t.child, null, s),
    e.child = ba(e, null, a, s)) : jn(t, e, a, s),
    e.memoizedState = r.state,
    i && _w(e, n, !0),
    e.child
}
function p_(t) {
    var e = t.stateNode;
    e.pendingContext ? bw(t, e.pendingContext, e.pendingContext !== e.context) : e.context && bw(t, e.context, !1),
    gm(t, e.containerInfo)
}
function Ow(t, e, n, r, i) {
    return va(),
    cm(i),
    e.flags |= 256,
    jn(t, e, n, r),
    e.child
}
var fp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function pp(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function g_(t, e, n) {
    var r = e.pendingProps, i = ft.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1),
    tt(ft, i & 1),
    t === null)
        return op(e),
        t = e.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = r.children,
        t = r.fallback,
        s ? (r = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(r & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = gh(o, r, 0, null),
        t = Xs(t, r, n, null),
        s.return = e,
        t.return = e,
        s.sibling = t,
        e.child = s,
        e.child.memoizedState = pp(n),
        e.memoizedState = fp,
        t) : Sm(e, o));
    if (i = t.memoizedState,
    i !== null && (a = i.dehydrated,
    a !== null))
        return TA(t, e, o, r, a, i, n);
    if (s) {
        s = r.fallback,
        o = e.mode,
        i = t.child,
        a = i.sibling;
        var l = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child,
        r.childLanes = 0,
        r.pendingProps = l,
        e.deletions = null) : (r = us(i, l),
        r.subtreeFlags = i.subtreeFlags & 14680064),
        a !== null ? s = us(a, s) : (s = Xs(s, o, n, null),
        s.flags |= 2),
        s.return = e,
        r.return = e,
        r.sibling = s,
        e.child = r,
        r = s,
        s = e.child,
        o = t.child.memoizedState,
        o = o === null ? pp(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = t.childLanes & ~n,
        e.memoizedState = fp,
        r
    }
    return s = t.child,
    t = s.sibling,
    r = us(s, {
        mode: "visible",
        children: r.children
    }),
    !(e.mode & 1) && (r.lanes = n),
    r.return = e,
    r.sibling = null,
    t !== null && (n = e.deletions,
    n === null ? (e.deletions = [t],
    e.flags |= 16) : n.push(t)),
    e.child = r,
    e.memoizedState = null,
    r
}
function Sm(t, e) {
    return e = gh({
        mode: "visible",
        children: e
    }, t.mode, 0, null),
    e.return = t,
    t.child = e
}
function Zc(t, e, n, r) {
    return r !== null && cm(r),
    ba(e, t.child, null, n),
    t = Sm(e, e.pendingProps.children),
    t.flags |= 2,
    e.memoizedState = null,
    t
}
function TA(t, e, n, r, i, s, o) {
    if (n)
        return e.flags & 256 ? (e.flags &= -257,
        r = Ff(Error(ee(422))),
        Zc(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child,
        e.flags |= 128,
        null) : (s = r.fallback,
        i = e.mode,
        r = gh({
            mode: "visible",
            children: r.children
        }, i, 0, null),
        s = Xs(s, i, o, null),
        s.flags |= 2,
        r.return = e,
        s.return = e,
        r.sibling = s,
        e.child = r,
        e.mode & 1 && ba(e, t.child, null, o),
        e.child.memoizedState = pp(o),
        e.memoizedState = fp,
        s);
    if (!(e.mode & 1))
        return Zc(t, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset,
        r)
            var a = r.dgst;
        return r = a,
        s = Error(ee(419)),
        r = Ff(s, r, void 0),
        Zc(t, e, o, r)
    }
    if (a = (o & t.childLanes) !== 0,
    Hn || a) {
        if (r = cn,
        r !== null) {
            switch (o & -o) {
            case 4:
                i = 2;
                break;
            case 16:
                i = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                i = 32;
                break;
            case 536870912:
                i = 268435456;
                break;
            default:
                i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i,
            i !== 0 && i !== s.retryLane && (s.retryLane = i,
            Ti(t, i),
            jr(r, t, i, -1))
        }
        return Tm(),
        r = Ff(Error(ee(421))),
        Zc(t, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128,
    e.child = t.child,
    e = FA.bind(null, t),
    i._reactRetry = e,
    null) : (t = s.treeContext,
    rr = os(i.nextSibling),
    sr = e,
    ut = !0,
    Cr = null,
    t !== null && (mr[yr++] = _i,
    mr[yr++] = xi,
    mr[yr++] = no,
    _i = t.id,
    xi = t.overflow,
    no = e),
    e = Sm(e, r.children),
    e.flags |= 4096,
    e)
}
function Dw(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e),
    ap(t.return, e, n)
}
function $f(t, e, n, r, i) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = r,
    s.tail = n,
    s.tailMode = i)
}
function m_(t, e, n) {
    var r = e.pendingProps
      , i = r.revealOrder
      , s = r.tail;
    if (jn(t, e, r.children, n),
    r = ft.current,
    r & 2)
        r = r & 1 | 2,
        e.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && Dw(t, n, e);
                else if (t.tag === 19)
                    Dw(t, n, e);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === e)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === e)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        r &= 1
    }
    if (tt(ft, r),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (i) {
        case "forwards":
            for (n = e.child,
            i = null; n !== null; )
                t = n.alternate,
                t !== null && Sd(t) === null && (i = n),
                n = n.sibling;
            n = i,
            n === null ? (i = e.child,
            e.child = null) : (i = n.sibling,
            n.sibling = null),
            $f(e, !1, i, n, s);
            break;
        case "backwards":
            for (n = null,
            i = e.child,
            e.child = null; i !== null; ) {
                if (t = i.alternate,
                t !== null && Sd(t) === null) {
                    e.child = i;
                    break
                }
                t = i.sibling,
                i.sibling = n,
                n = i,
                i = t
            }
            $f(e, !0, n, null, s);
            break;
        case "together":
            $f(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Su(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Ni(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies),
    io |= e.lanes,
    !(n & e.childLanes))
        return null;
    if (t !== null && e.child !== t.child)
        throw Error(ee(153));
    if (e.child !== null) {
        for (t = e.child,
        n = us(t, t.pendingProps),
        e.child = n,
        n.return = e; t.sibling !== null; )
            t = t.sibling,
            n = n.sibling = us(t, t.pendingProps),
            n.return = e;
        n.sibling = null
    }
    return e.child
}
function NA(t, e, n) {
    switch (e.tag) {
    case 3:
        p_(e),
        va();
        break;
    case 5:
        Fb(e);
        break;
    case 1:
        Yn(e.type) && yd(e);
        break;
    case 4:
        gm(e, e.stateNode.containerInfo);
        break;
    case 10:
        var r = e.type._context
          , i = e.memoizedProps.value;
        tt(bd, r._currentValue),
        r._currentValue = i;
        break;
    case 13:
        if (r = e.memoizedState,
        r !== null)
            return r.dehydrated !== null ? (tt(ft, ft.current & 1),
            e.flags |= 128,
            null) : n & e.child.childLanes ? g_(t, e, n) : (tt(ft, ft.current & 1),
            t = Ni(t, e, n),
            t !== null ? t.sibling : null);
        tt(ft, ft.current & 1);
        break;
    case 19:
        if (r = (n & e.childLanes) !== 0,
        t.flags & 128) {
            if (r)
                return m_(t, e, n);
            e.flags |= 128
        }
        if (i = e.memoizedState,
        i !== null && (i.rendering = null,
        i.tail = null,
        i.lastEffect = null),
        tt(ft, ft.current),
        r)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        h_(t, e, n)
    }
    return Ni(t, e, n)
}
var y_, gp, w_, v_;
y_ = function(t, e) {
    for (var n = e.child; n !== null; ) {
        if (n.tag === 5 || n.tag === 6)
            t.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === e)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === e)
                return;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
}
;
gp = function() {}
;
w_ = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
        t = e.stateNode,
        Ws(ei.current);
        var s = null;
        switch (n) {
        case "input":
            i = O0(t, i),
            r = O0(t, r),
            s = [];
            break;
        case "select":
            i = mt({}, i, {
                value: void 0
            }),
            r = mt({}, r, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            i = U0(t, i),
            r = U0(t, r),
            s = [];
            break;
        default:
            typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = gd)
        }
        F0(n, r);
        var o;
        n = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (n || (n = {}),
                        n[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Dl.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in r) {
            var l = r[c];
            if (a = i?.[c],
            r.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}),
                            n[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}),
                            n[o] = l[o])
                    } else
                        n || (s || (s = []),
                        s.push(c, n)),
                        n = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Dl.hasOwnProperty(c) ? (l != null && c === "onScroll" && it("scroll", t),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        n && (s = s || []).push("style", n);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
v_ = function(t, e, n, r) {
    n !== r && (e.flags |= 4)
}
;
function Xa(t, e) {
    if (!ut)
        switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var n = null; e !== null; )
                e.alternate !== null && (n = e),
                e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = t.tail;
            for (var r = null; n !== null; )
                n.alternate !== null && (r = n),
                n = n.sibling;
            r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
        }
}
function _n(t) {
    var e = t.alternate !== null && t.alternate.child === t.child
      , n = 0
      , r = 0;
    if (e)
        for (var i = t.child; i !== null; )
            n |= i.lanes | i.childLanes,
            r |= i.subtreeFlags & 14680064,
            r |= i.flags & 14680064,
            i.return = t,
            i = i.sibling;
    else
        for (i = t.child; i !== null; )
            n |= i.lanes | i.childLanes,
            r |= i.subtreeFlags,
            r |= i.flags,
            i.return = t,
            i = i.sibling;
    return t.subtreeFlags |= r,
    t.childLanes = n,
    e
}
function CA(t, e, n) {
    var r = e.pendingProps;
    switch (lm(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return _n(e),
        null;
    case 1:
        return Yn(e.type) && md(),
        _n(e),
        null;
    case 3:
        return r = e.stateNode,
        _a(),
        ot(Gn),
        ot(Rn),
        ym(),
        r.pendingContext && (r.context = r.pendingContext,
        r.pendingContext = null),
        (t === null || t.child === null) && (Gc(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        Cr !== null && (Sp(Cr),
        Cr = null))),
        gp(t, e),
        _n(e),
        null;
    case 5:
        mm(e);
        var i = Ws(Zl.current);
        if (n = e.type,
        t !== null && e.stateNode != null)
            w_(t, e, n, r, i),
            t.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!r) {
                if (e.stateNode === null)
                    throw Error(ee(166));
                return _n(e),
                null
            }
            if (t = Ws(ei.current),
            Gc(e)) {
                r = e.stateNode,
                n = e.type;
                var s = e.memoizedProps;
                switch (r[Vr] = e,
                r[Gl] = s,
                t = (e.mode & 1) !== 0,
                n) {
                case "dialog":
                    it("cancel", r),
                    it("close", r);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    it("load", r);
                    break;
                case "video":
                case "audio":
                    for (i = 0; i < ll.length; i++)
                        it(ll[i], r);
                    break;
                case "source":
                    it("error", r);
                    break;
                case "img":
                case "image":
                case "link":
                    it("error", r),
                    it("load", r);
                    break;
                case "details":
                    it("toggle", r);
                    break;
                case "input":
                    qy(r, s),
                    it("invalid", r);
                    break;
                case "select":
                    r._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    it("invalid", r);
                    break;
                case "textarea":
                    Yy(r, s),
                    it("invalid", r)
                }
                F0(n, s),
                i = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && qc(r.textContent, a, t),
                        i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && qc(r.textContent, a, t),
                        i = ["children", "" + a]) : Dl.hasOwnProperty(o) && a != null && o === "onScroll" && it("scroll", r)
                    }
                switch (n) {
                case "input":
                    zc(r),
                    Gy(r, s, !0);
                    break;
                case "textarea":
                    zc(r),
                    Zy(r);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (r.onclick = gd)
                }
                r = i,
                e.updateQueue = r,
                r !== null && (e.flags |= 4)
            } else {
                o = i.nodeType === 9 ? i : i.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = qv(n)),
                t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, {
                    is: r.is
                }) : (t = o.createElement(n),
                n === "select" && (o = t,
                r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n),
                t[Vr] = e,
                t[Gl] = r,
                y_(t, e, !1, !1),
                e.stateNode = t;
                e: {
                    switch (o = $0(n, r),
                    n) {
                    case "dialog":
                        it("cancel", t),
                        it("close", t),
                        i = r;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        it("load", t),
                        i = r;
                        break;
                    case "video":
                    case "audio":
                        for (i = 0; i < ll.length; i++)
                            it(ll[i], t);
                        i = r;
                        break;
                    case "source":
                        it("error", t),
                        i = r;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        it("error", t),
                        it("load", t),
                        i = r;
                        break;
                    case "details":
                        it("toggle", t),
                        i = r;
                        break;
                    case "input":
                        qy(t, r),
                        i = O0(t, r),
                        it("invalid", t);
                        break;
                    case "option":
                        i = r;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!r.multiple
                        },
                        i = mt({}, r, {
                            value: void 0
                        }),
                        it("invalid", t);
                        break;
                    case "textarea":
                        Yy(t, r),
                        i = U0(t, r),
                        it("invalid", t);
                        break;
                    default:
                        i = r
                    }
                    F0(n, i),
                    a = i;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? Zv(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && Gv(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && zl(t, l) : typeof l == "number" && zl(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Dl.hasOwnProperty(s) ? l != null && s === "onScroll" && it("scroll", t) : l != null && qg(t, s, l, o))
                        }
                    switch (n) {
                    case "input":
                        zc(t),
                        Gy(t, r, !1);
                        break;
                    case "textarea":
                        zc(t),
                        Zy(t);
                        break;
                    case "option":
                        r.value != null && t.setAttribute("value", "" + fs(r.value));
                        break;
                    case "select":
                        t.multiple = !!r.multiple,
                        s = r.value,
                        s != null ? sa(t, !!r.multiple, s, !1) : r.defaultValue != null && sa(t, !!r.multiple, r.defaultValue, !0);
                        break;
                    default:
                        typeof i.onClick == "function" && (t.onclick = gd)
                    }
                    switch (n) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        r = !!r.autoFocus;
                        break e;
                    case "img":
                        r = !0;
                        break e;
                    default:
                        r = !1
                    }
                }
                r && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return _n(e),
        null;
    case 6:
        if (t && e.stateNode != null)
            v_(t, e, t.memoizedProps, r);
        else {
            if (typeof r != "string" && e.stateNode === null)
                throw Error(ee(166));
            if (n = Ws(Zl.current),
            Ws(ei.current),
            Gc(e)) {
                if (r = e.stateNode,
                n = e.memoizedProps,
                r[Vr] = e,
                (s = r.nodeValue !== n) && (t = sr,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        qc(r.nodeValue, n, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && qc(r.nodeValue, n, (t.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r),
                r[Vr] = e,
                e.stateNode = r
        }
        return _n(e),
        null;
    case 13:
        if (ot(ft),
        r = e.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (ut && rr !== null && e.mode & 1 && !(e.flags & 128))
                Ob(),
                va(),
                e.flags |= 98560,
                s = !1;
            else if (s = Gc(e),
            r !== null && r.dehydrated !== null) {
                if (t === null) {
                    if (!s)
                        throw Error(ee(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(ee(317));
                    s[Vr] = e
                } else
                    va(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                _n(e),
                s = !1
            } else
                Cr !== null && (Sp(Cr),
                Cr = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = n,
        e) : (r = r !== null,
        r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192,
        e.mode & 1 && (t === null || ft.current & 1 ? tn === 0 && (tn = 3) : Tm())),
        e.updateQueue !== null && (e.flags |= 4),
        _n(e),
        null);
    case 4:
        return _a(),
        gp(t, e),
        t === null && Hl(e.stateNode.containerInfo),
        _n(e),
        null;
    case 10:
        return hm(e.type._context),
        _n(e),
        null;
    case 17:
        return Yn(e.type) && md(),
        _n(e),
        null;
    case 19:
        if (ot(ft),
        s = e.memoizedState,
        s === null)
            return _n(e),
            null;
        if (r = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (r)
                Xa(s, !1);
            else {
                if (tn !== 0 || t !== null && t.flags & 128)
                    for (t = e.child; t !== null; ) {
                        if (o = Sd(t),
                        o !== null) {
                            for (e.flags |= 128,
                            Xa(s, !1),
                            r = o.updateQueue,
                            r !== null && (e.updateQueue = r,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            r = n,
                            n = e.child; n !== null; )
                                s = n,
                                t = r,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = t,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                t = o.dependencies,
                                s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                n = n.sibling;
                            return tt(ft, ft.current & 1 | 2),
                            e.child
                        }
                        t = t.sibling
                    }
                s.tail !== null && Mt() > Sa && (e.flags |= 128,
                r = !0,
                Xa(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!r)
                if (t = Sd(o),
                t !== null) {
                    if (e.flags |= 128,
                    r = !0,
                    n = t.updateQueue,
                    n !== null && (e.updateQueue = n,
                    e.flags |= 4),
                    Xa(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !ut)
                        return _n(e),
                        null
                } else
                    2 * Mt() - s.renderingStartTime > Sa && n !== 1073741824 && (e.flags |= 128,
                    r = !0,
                    Xa(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (n = s.last,
            n !== null ? n.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = Mt(),
        e.sibling = null,
        n = ft.current,
        tt(ft, r ? n & 1 | 2 : n & 1),
        e) : (_n(e),
        null);
    case 22:
    case 23:
        return Mm(),
        r = e.memoizedState !== null,
        t !== null && t.memoizedState !== null !== r && (e.flags |= 8192),
        r && e.mode & 1 ? Xn & 1073741824 && (_n(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : _n(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(ee(156, e.tag))
}
function RA(t, e) {
    switch (lm(e),
    e.tag) {
    case 1:
        return Yn(e.type) && md(),
        t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 3:
        return _a(),
        ot(Gn),
        ot(Rn),
        ym(),
        t = e.flags,
        t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128,
        e) : null;
    case 5:
        return mm(e),
        null;
    case 13:
        if (ot(ft),
        t = e.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(ee(340));
            va()
        }
        return t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 19:
        return ot(ft),
        null;
    case 4:
        return _a(),
        null;
    case 10:
        return hm(e.type._context),
        null;
    case 22:
    case 23:
        return Mm(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Qc = !1
  , Cn = !1
  , LA = typeof WeakSet == "function" ? WeakSet : Set
  , ce = null;
function ea(t, e) {
    var n = t.ref;
    if (n !== null)
        if (typeof n == "function")
            try {
                n(null)
            } catch (r) {
                At(t, e, r)
            }
        else
            n.current = null
}
function mp(t, e, n) {
    try {
        n()
    } catch (r) {
        At(t, e, r)
    }
}
var zw = !1;
function jA(t, e) {
    if (X0 = hd,
    t = kb(),
    om(t)) {
        if ("selectionStart"in t)
            var n = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                n = (n = t.ownerDocument) && n.defaultView || window;
                var r = n.getSelection && n.getSelection();
                if (r && r.rangeCount !== 0) {
                    n = r.anchorNode;
                    var i = r.anchorOffset
                      , s = r.focusNode;
                    r = r.focusOffset;
                    try {
                        n.nodeType,
                        s.nodeType
                    } catch {
                        n = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , d = 0
                      , h = t
                      , y = null;
                    t: for (; ; ) {
                        for (var m; h !== n || i !== 0 && h.nodeType !== 3 || (a = o + i),
                        h !== s || r !== 0 && h.nodeType !== 3 || (l = o + r),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (m = h.firstChild) !== null; )
                            y = h,
                            h = m;
                        for (; ; ) {
                            if (h === t)
                                break t;
                            if (y === n && ++c === i && (a = o),
                            y === s && ++d === r && (l = o),
                            (m = h.nextSibling) !== null)
                                break;
                            h = y,
                            y = h.parentNode
                        }
                        h = m
                    }
                    n = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    n = null
            }
        n = n || {
            start: 0,
            end: 0
        }
    } else
        n = null;
    for (ep = {
        focusedElem: t,
        selectionRange: n
    },
    hd = !1,
    ce = e; ce !== null; )
        if (e = ce,
        t = e.child,
        (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e,
            ce = t;
        else
            for (; ce !== null; ) {
                e = ce;
                try {
                    var v = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (v !== null) {
                                var E = v.memoizedProps
                                  , A = v.memoizedState
                                  , _ = e.stateNode
                                  , x = _.getSnapshotBeforeUpdate(e.elementType === e.type ? E : Ir(e.type, E), A);
                                _.__reactInternalSnapshotBeforeUpdate = x
                            }
                            break;
                        case 3:
                            var b = e.stateNode.containerInfo;
                            b.nodeType === 1 ? b.textContent = "" : b.nodeType === 9 && b.documentElement && b.removeChild(b.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(ee(163))
                        }
                } catch (R) {
                    At(e, e.return, R)
                }
                if (t = e.sibling,
                t !== null) {
                    t.return = e.return,
                    ce = t;
                    break
                }
                ce = e.return
            }
    return v = zw,
    zw = !1,
    v
}
function Il(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null,
    r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & t) === t) {
                var s = i.destroy;
                i.destroy = void 0,
                s !== void 0 && mp(e, n, s)
            }
            i = i.next
        } while (i !== r)
    }
}
function fh(t, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var n = e = e.next;
        do {
            if ((n.tag & t) === t) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== e)
    }
}
function yp(t) {
    var e = t.ref;
    if (e !== null) {
        var n = t.stateNode;
        switch (t.tag) {
        case 5:
            t = n;
            break;
        default:
            t = n
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}
function b_(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null,
    b_(e)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (e = t.stateNode,
    e !== null && (delete e[Vr],
    delete e[Gl],
    delete e[rp],
    delete e[mA],
    delete e[yA])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function __(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function Uw(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || __(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function wp(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
        t = t.stateNode,
        e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode,
        e.insertBefore(t, n)) : (e = n,
        e.appendChild(t)),
        n = n._reactRootContainer,
        n != null || e.onclick !== null || (e.onclick = gd));
    else if (r !== 4 && (t = t.child,
    t !== null))
        for (wp(t, e, n),
        t = t.sibling; t !== null; )
            wp(t, e, n),
            t = t.sibling
}
function vp(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6)
        t = t.stateNode,
        e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child,
    t !== null))
        for (vp(t, e, n),
        t = t.sibling; t !== null; )
            vp(t, e, n),
            t = t.sibling
}
var hn = null
  , Tr = !1;
function Li(t, e, n) {
    for (n = n.child; n !== null; )
        x_(t, e, n),
        n = n.sibling
}
function x_(t, e, n) {
    if (Xr && typeof Xr.onCommitFiberUnmount == "function")
        try {
            Xr.onCommitFiberUnmount(sh, n)
        } catch {}
    switch (n.tag) {
    case 5:
        Cn || ea(n, e);
    case 6:
        var r = hn
          , i = Tr;
        hn = null,
        Li(t, e, n),
        hn = r,
        Tr = i,
        hn !== null && (Tr ? (t = hn,
        n = n.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : hn.removeChild(n.stateNode));
        break;
    case 18:
        hn !== null && (Tr ? (t = hn,
        n = n.stateNode,
        t.nodeType === 8 ? Pf(t.parentNode, n) : t.nodeType === 1 && Pf(t, n),
        $l(t)) : Pf(hn, n.stateNode));
        break;
    case 4:
        r = hn,
        i = Tr,
        hn = n.stateNode.containerInfo,
        Tr = !0,
        Li(t, e, n),
        hn = r,
        Tr = i;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!Cn && (r = n.updateQueue,
        r !== null && (r = r.lastEffect,
        r !== null))) {
            i = r = r.next;
            do {
                var s = i
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && mp(n, e, o),
                i = i.next
            } while (i !== r)
        }
        Li(t, e, n);
        break;
    case 1:
        if (!Cn && (ea(n, e),
        r = n.stateNode,
        typeof r.componentWillUnmount == "function"))
            try {
                r.props = n.memoizedProps,
                r.state = n.memoizedState,
                r.componentWillUnmount()
            } catch (a) {
                At(n, e, a)
            }
        Li(t, e, n);
        break;
    case 21:
        Li(t, e, n);
        break;
    case 22:
        n.mode & 1 ? (Cn = (r = Cn) || n.memoizedState !== null,
        Li(t, e, n),
        Cn = r) : Li(t, e, n);
        break;
    default:
        Li(t, e, n)
    }
}
function Ww(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var n = t.stateNode;
        n === null && (n = t.stateNode = new LA),
        e.forEach(function(r) {
            var i = $A.bind(null, t, r);
            n.has(r) || (n.add(r),
            r.then(i, i))
        })
    }
}
function kr(t, e) {
    var n = e.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var s = t
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        hn = a.stateNode,
                        Tr = !1;
                        break e;
                    case 3:
                        hn = a.stateNode.containerInfo,
                        Tr = !0;
                        break e;
                    case 4:
                        hn = a.stateNode.containerInfo,
                        Tr = !0;
                        break e
                    }
                    a = a.return
                }
                if (hn === null)
                    throw Error(ee(160));
                x_(s, o, i),
                hn = null,
                Tr = !1;
                var l = i.alternate;
                l !== null && (l.return = null),
                i.return = null
            } catch (c) {
                At(i, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            S_(e, t),
            e = e.sibling
}
function S_(t, e) {
    var n = t.alternate
      , r = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (kr(e, t),
        zr(t),
        r & 4) {
            try {
                Il(3, t, t.return),
                fh(3, t)
            } catch (E) {
                At(t, t.return, E)
            }
            try {
                Il(5, t, t.return)
            } catch (E) {
                At(t, t.return, E)
            }
        }
        break;
    case 1:
        kr(e, t),
        zr(t),
        r & 512 && n !== null && ea(n, n.return);
        break;
    case 5:
        if (kr(e, t),
        zr(t),
        r & 512 && n !== null && ea(n, n.return),
        t.flags & 32) {
            var i = t.stateNode;
            try {
                zl(i, "")
            } catch (E) {
                At(t, t.return, E)
            }
        }
        if (r & 4 && (i = t.stateNode,
        i != null)) {
            var s = t.memoizedProps
              , o = n !== null ? n.memoizedProps : s
              , a = t.type
              , l = t.updateQueue;
            if (t.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && Vv(i, s),
                    $0(a, o);
                    var c = $0(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o]
                          , h = l[o + 1];
                        d === "style" ? Zv(i, h) : d === "dangerouslySetInnerHTML" ? Gv(i, h) : d === "children" ? zl(i, h) : qg(i, d, h, c)
                    }
                    switch (a) {
                    case "input":
                        D0(i, s);
                        break;
                    case "textarea":
                        Hv(i, s);
                        break;
                    case "select":
                        var y = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? sa(i, !!s.multiple, m, !1) : y !== !!s.multiple && (s.defaultValue != null ? sa(i, !!s.multiple, s.defaultValue, !0) : sa(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[Gl] = s
                } catch (E) {
                    At(t, t.return, E)
                }
        }
        break;
    case 6:
        if (kr(e, t),
        zr(t),
        r & 4) {
            if (t.stateNode === null)
                throw Error(ee(162));
            i = t.stateNode,
            s = t.memoizedProps;
            try {
                i.nodeValue = s
            } catch (E) {
                At(t, t.return, E)
            }
        }
        break;
    case 3:
        if (kr(e, t),
        zr(t),
        r & 4 && n !== null && n.memoizedState.isDehydrated)
            try {
                $l(e.containerInfo)
            } catch (E) {
                At(t, t.return, E)
            }
        break;
    case 4:
        kr(e, t),
        zr(t);
        break;
    case 13:
        kr(e, t),
        zr(t),
        i = t.child,
        i.flags & 8192 && (s = i.memoizedState !== null,
        i.stateNode.isHidden = s,
        !s || i.alternate !== null && i.alternate.memoizedState !== null || (Am = Mt())),
        r & 4 && Ww(t);
        break;
    case 22:
        if (d = n !== null && n.memoizedState !== null,
        t.mode & 1 ? (Cn = (c = Cn) || d,
        kr(e, t),
        Cn = c) : kr(e, t),
        zr(t),
        r & 8192) {
            if (c = t.memoizedState !== null,
            (t.stateNode.isHidden = c) && !d && t.mode & 1)
                for (ce = t,
                d = t.child; d !== null; ) {
                    for (h = ce = d; ce !== null; ) {
                        switch (y = ce,
                        m = y.child,
                        y.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Il(4, y, y.return);
                            break;
                        case 1:
                            ea(y, y.return);
                            var v = y.stateNode;
                            if (typeof v.componentWillUnmount == "function") {
                                r = y,
                                n = y.return;
                                try {
                                    e = r,
                                    v.props = e.memoizedProps,
                                    v.state = e.memoizedState,
                                    v.componentWillUnmount()
                                } catch (E) {
                                    At(r, n, E)
                                }
                            }
                            break;
                        case 5:
                            ea(y, y.return);
                            break;
                        case 22:
                            if (y.memoizedState !== null) {
                                $w(h);
                                continue
                            }
                        }
                        m !== null ? (m.return = y,
                        ce = m) : $w(h)
                    }
                    d = d.sibling
                }
            e: for (d = null,
            h = t; ; ) {
                if (h.tag === 5) {
                    if (d === null) {
                        d = h;
                        try {
                            i = h.stateNode,
                            c ? (s = i.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = Yv("display", o))
                        } catch (E) {
                            At(t, t.return, E)
                        }
                    }
                } else if (h.tag === 6) {
                    if (d === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (E) {
                            At(t, t.return, E)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === t)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === t)
                        break e;
                    d === h && (d = null),
                    h = h.return
                }
                d === h && (d = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        kr(e, t),
        zr(t),
        r & 4 && Ww(t);
        break;
    case 21:
        break;
    default:
        kr(e, t),
        zr(t)
    }
}
function zr(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var n = t.return; n !== null; ) {
                    if (__(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(ee(160))
            }
            switch (r.tag) {
            case 5:
                var i = r.stateNode;
                r.flags & 32 && (zl(i, ""),
                r.flags &= -33);
                var s = Uw(t);
                vp(t, s, i);
                break;
            case 3:
            case 4:
                var o = r.stateNode.containerInfo
                  , a = Uw(t);
                wp(t, a, o);
                break;
            default:
                throw Error(ee(161))
            }
        } catch (l) {
            At(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}
function BA(t, e, n) {
    ce = t,
    k_(t)
}
function k_(t, e, n) {
    for (var r = (t.mode & 1) !== 0; ce !== null; ) {
        var i = ce
          , s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || Qc;
            if (!o) {
                var a = i.alternate
                  , l = a !== null && a.memoizedState !== null || Cn;
                a = Qc;
                var c = Cn;
                if (Qc = o,
                (Cn = l) && !c)
                    for (ce = i; ce !== null; )
                        o = ce,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? Kw(i) : l !== null ? (l.return = o,
                        ce = l) : Kw(i);
                for (; s !== null; )
                    ce = s,
                    k_(s),
                    s = s.sibling;
                ce = i,
                Qc = a,
                Cn = c
            }
            Fw(t)
        } else
            i.subtreeFlags & 8772 && s !== null ? (s.return = i,
            ce = s) : Fw(t)
    }
}
function Fw(t) {
    for (; ce !== null; ) {
        var e = ce;
        if (e.flags & 8772) {
            var n = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Cn || fh(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !Cn)
                            if (n === null)
                                r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? n.memoizedProps : Ir(e.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && Aw(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (n = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    n = e.child.stateNode;
                                    break;
                                case 1:
                                    n = e.child.stateNode
                                }
                            Aw(e, o, n)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (n === null && e.flags & 4) {
                            n = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && n.focus();
                                break;
                            case "img":
                                l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var d = c.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && $l(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(ee(163))
                    }
                Cn || e.flags & 512 && yp(e)
            } catch (y) {
                At(e, e.return, y)
            }
        }
        if (e === t) {
            ce = null;
            break
        }
        if (n = e.sibling,
        n !== null) {
            n.return = e.return,
            ce = n;
            break
        }
        ce = e.return
    }
}
function $w(t) {
    for (; ce !== null; ) {
        var e = ce;
        if (e === t) {
            ce = null;
            break
        }
        var n = e.sibling;
        if (n !== null) {
            n.return = e.return,
            ce = n;
            break
        }
        ce = e.return
    }
}
function Kw(t) {
    for (; ce !== null; ) {
        var e = ce;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var n = e.return;
                try {
                    fh(4, e)
                } catch (l) {
                    At(e, n, l)
                }
                break;
            case 1:
                var r = e.stateNode;
                if (typeof r.componentDidMount == "function") {
                    var i = e.return;
                    try {
                        r.componentDidMount()
                    } catch (l) {
                        At(e, i, l)
                    }
                }
                var s = e.return;
                try {
                    yp(e)
                } catch (l) {
                    At(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    yp(e)
                } catch (l) {
                    At(e, o, l)
                }
            }
        } catch (l) {
            At(e, e.return, l)
        }
        if (e === t) {
            ce = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            ce = a;
            break
        }
        ce = e.return
    }
}
var PA = Math.ceil
  , Ad = Ri.ReactCurrentDispatcher
  , km = Ri.ReactCurrentOwner
  , vr = Ri.ReactCurrentBatchConfig
  , Oe = 0
  , cn = null
  , Yt = null
  , yn = 0
  , Xn = 0
  , ta = ws(0)
  , tn = 0
  , ec = null
  , io = 0
  , ph = 0
  , Em = 0
  , Ml = null
  , $n = null
  , Am = 0
  , Sa = 1 / 0
  , fi = null
  , Id = !1
  , bp = null
  , ls = null
  , Jc = !1
  , Ji = null
  , Md = 0
  , Tl = 0
  , _p = null
  , ku = -1
  , Eu = 0;
function Pn() {
    return Oe & 6 ? Mt() : ku !== -1 ? ku : ku = Mt()
}
function cs(t) {
    return t.mode & 1 ? Oe & 2 && yn !== 0 ? yn & -yn : vA.transition !== null ? (Eu === 0 && (Eu = lb()),
    Eu) : (t = Ke,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : gb(t.type)),
    t) : 1
}
function jr(t, e, n, r) {
    if (50 < Tl)
        throw Tl = 0,
        _p = null,
        Error(ee(185));
    pc(t, n, r),
    (!(Oe & 2) || t !== cn) && (t === cn && (!(Oe & 2) && (ph |= n),
    tn === 4 && Gi(t, yn)),
    Zn(t, r),
    n === 1 && Oe === 0 && !(e.mode & 1) && (Sa = Mt() + 500,
    uh && vs()))
}
function Zn(t, e) {
    var n = t.callbackNode;
    vE(t, e);
    var r = dd(t, t === cn ? yn : 0);
    if (r === 0)
        n !== null && Xy(n),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (e = r & -r,
    t.callbackPriority !== e) {
        if (n != null && Xy(n),
        e === 1)
            t.tag === 0 ? wA(Vw.bind(null, t)) : jb(Vw.bind(null, t)),
            pA(function() {
                !(Oe & 6) && vs()
            }),
            n = null;
        else {
            switch (cb(r)) {
            case 1:
                n = Jg;
                break;
            case 4:
                n = ob;
                break;
            case 16:
                n = ud;
                break;
            case 536870912:
                n = ab;
                break;
            default:
                n = ud
            }
            n = R_(n, E_.bind(null, t))
        }
        t.callbackPriority = e,
        t.callbackNode = n
    }
}
function E_(t, e) {
    if (ku = -1,
    Eu = 0,
    Oe & 6)
        throw Error(ee(327));
    var n = t.callbackNode;
    if (ua() && t.callbackNode !== n)
        return null;
    var r = dd(t, t === cn ? yn : 0);
    if (r === 0)
        return null;
    if (r & 30 || r & t.expiredLanes || e)
        e = Td(t, r);
    else {
        e = r;
        var i = Oe;
        Oe |= 2;
        var s = I_();
        (cn !== t || yn !== e) && (fi = null,
        Sa = Mt() + 500,
        Js(t, e));
        do
            try {
                zA();
                break
            } catch (a) {
                A_(t, a)
            }
        while (1);
        dm(),
        Ad.current = s,
        Oe = i,
        Yt !== null ? e = 0 : (cn = null,
        yn = 0,
        e = tn)
    }
    if (e !== 0) {
        if (e === 2 && (i = G0(t),
        i !== 0 && (r = i,
        e = xp(t, i))),
        e === 1)
            throw n = ec,
            Js(t, 0),
            Gi(t, r),
            Zn(t, Mt()),
            n;
        if (e === 6)
            Gi(t, r);
        else {
            if (i = t.current.alternate,
            !(r & 30) && !OA(i) && (e = Td(t, r),
            e === 2 && (s = G0(t),
            s !== 0 && (r = s,
            e = xp(t, s))),
            e === 1))
                throw n = ec,
                Js(t, 0),
                Gi(t, r),
                Zn(t, Mt()),
                n;
            switch (t.finishedWork = i,
            t.finishedLanes = r,
            e) {
            case 0:
            case 1:
                throw Error(ee(345));
            case 2:
                Is(t, $n, fi);
                break;
            case 3:
                if (Gi(t, r),
                (r & 130023424) === r && (e = Am + 500 - Mt(),
                10 < e)) {
                    if (dd(t, 0) !== 0)
                        break;
                    if (i = t.suspendedLanes,
                    (i & r) !== r) {
                        Pn(),
                        t.pingedLanes |= t.suspendedLanes & i;
                        break
                    }
                    t.timeoutHandle = np(Is.bind(null, t, $n, fi), e);
                    break
                }
                Is(t, $n, fi);
                break;
            case 4:
                if (Gi(t, r),
                (r & 4194240) === r)
                    break;
                for (e = t.eventTimes,
                i = -1; 0 < r; ) {
                    var o = 31 - Lr(r);
                    s = 1 << o,
                    o = e[o],
                    o > i && (i = o),
                    r &= ~s
                }
                if (r = i,
                r = Mt() - r,
                r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * PA(r / 1960)) - r,
                10 < r) {
                    t.timeoutHandle = np(Is.bind(null, t, $n, fi), r);
                    break
                }
                Is(t, $n, fi);
                break;
            case 5:
                Is(t, $n, fi);
                break;
            default:
                throw Error(ee(329))
            }
        }
    }
    return Zn(t, Mt()),
    t.callbackNode === n ? E_.bind(null, t) : null
}
function xp(t, e) {
    var n = Ml;
    return t.current.memoizedState.isDehydrated && (Js(t, e).flags |= 256),
    t = Td(t, e),
    t !== 2 && (e = $n,
    $n = n,
    e !== null && Sp(e)),
    t
}
function Sp(t) {
    $n === null ? $n = t : $n.push.apply($n, t)
}
function OA(t) {
    for (var e = t; ; ) {
        if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores,
            n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r]
                      , s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!Pr(s(), i))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = e.child,
        e.subtreeFlags & 16384 && n !== null)
            n.return = e,
            e = n;
        else {
            if (e === t)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Gi(t, e) {
    for (e &= ~Em,
    e &= ~ph,
    t.suspendedLanes |= e,
    t.pingedLanes &= ~e,
    t = t.expirationTimes; 0 < e; ) {
        var n = 31 - Lr(e)
          , r = 1 << n;
        t[n] = -1,
        e &= ~r
    }
}
function Vw(t) {
    if (Oe & 6)
        throw Error(ee(327));
    ua();
    var e = dd(t, 0);
    if (!(e & 1))
        return Zn(t, Mt()),
        null;
    var n = Td(t, e);
    if (t.tag !== 0 && n === 2) {
        var r = G0(t);
        r !== 0 && (e = r,
        n = xp(t, r))
    }
    if (n === 1)
        throw n = ec,
        Js(t, 0),
        Gi(t, e),
        Zn(t, Mt()),
        n;
    if (n === 6)
        throw Error(ee(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = e,
    Is(t, $n, fi),
    Zn(t, Mt()),
    null
}
function Im(t, e) {
    var n = Oe;
    Oe |= 1;
    try {
        return t(e)
    } finally {
        Oe = n,
        Oe === 0 && (Sa = Mt() + 500,
        uh && vs())
    }
}
function so(t) {
    Ji !== null && Ji.tag === 0 && !(Oe & 6) && ua();
    var e = Oe;
    Oe |= 1;
    var n = vr.transition
      , r = Ke;
    try {
        if (vr.transition = null,
        Ke = 1,
        t)
            return t()
    } finally {
        Ke = r,
        vr.transition = n,
        Oe = e,
        !(Oe & 6) && vs()
    }
}
function Mm() {
    Xn = ta.current,
    ot(ta)
}
function Js(t, e) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1,
    fA(n)),
    Yt !== null)
        for (n = Yt.return; n !== null; ) {
            var r = n;
            switch (lm(r),
            r.tag) {
            case 1:
                r = r.type.childContextTypes,
                r != null && md();
                break;
            case 3:
                _a(),
                ot(Gn),
                ot(Rn),
                ym();
                break;
            case 5:
                mm(r);
                break;
            case 4:
                _a();
                break;
            case 13:
                ot(ft);
                break;
            case 19:
                ot(ft);
                break;
            case 10:
                hm(r.type._context);
                break;
            case 22:
            case 23:
                Mm()
            }
            n = n.return
        }
    if (cn = t,
    Yt = t = us(t.current, null),
    yn = Xn = e,
    tn = 0,
    ec = null,
    Em = ph = io = 0,
    $n = Ml = null,
    Us !== null) {
        for (e = 0; e < Us.length; e++)
            if (n = Us[e],
            r = n.interleaved,
            r !== null) {
                n.interleaved = null;
                var i = r.next
                  , s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i,
                    r.next = o
                }
                n.pending = r
            }
        Us = null
    }
    return t
}
function A_(t, e) {
    do {
        var n = Yt;
        try {
            if (dm(),
            _u.current = Ed,
            kd) {
                for (var r = gt.memoizedState; r !== null; ) {
                    var i = r.queue;
                    i !== null && (i.pending = null),
                    r = r.next
                }
                kd = !1
            }
            if (ro = 0,
            an = en = gt = null,
            Al = !1,
            Ql = 0,
            km.current = null,
            n === null || n.return === null) {
                tn = 1,
                ec = e,
                Yt = null;
                break
            }
            e: {
                var s = t
                  , o = n.return
                  , a = n
                  , l = e;
                if (e = yn,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , d = a
                      , h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var y = d.alternate;
                        y ? (d.updateQueue = y.updateQueue,
                        d.memoizedState = y.memoizedState,
                        d.lanes = y.lanes) : (d.updateQueue = null,
                        d.memoizedState = null)
                    }
                    var m = Rw(o);
                    if (m !== null) {
                        m.flags &= -257,
                        Lw(m, o, a, s, e),
                        m.mode & 1 && Cw(s, c, e),
                        e = m,
                        l = c;
                        var v = e.updateQueue;
                        if (v === null) {
                            var E = new Set;
                            E.add(l),
                            e.updateQueue = E
                        } else
                            v.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Cw(s, c, e),
                            Tm();
                            break e
                        }
                        l = Error(ee(426))
                    }
                } else if (ut && a.mode & 1) {
                    var A = Rw(o);
                    if (A !== null) {
                        !(A.flags & 65536) && (A.flags |= 256),
                        Lw(A, o, a, s, e),
                        cm(xa(l, a));
                        break e
                    }
                }
                s = l = xa(l, a),
                tn !== 4 && (tn = 2),
                Ml === null ? Ml = [s] : Ml.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var _ = c_(s, l, e);
                        Ew(s, _);
                        break e;
                    case 1:
                        a = l;
                        var x = s.type
                          , b = s.stateNode;
                        if (!(s.flags & 128) && (typeof x.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (ls === null || !ls.has(b)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var R = u_(s, a, e);
                            Ew(s, R);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            T_(n)
        } catch (O) {
            e = O,
            Yt === n && n !== null && (Yt = n = n.return);
            continue
        }
        break
    } while (1)
}
function I_() {
    var t = Ad.current;
    return Ad.current = Ed,
    t === null ? Ed : t
}
function Tm() {
    (tn === 0 || tn === 3 || tn === 2) && (tn = 4),
    cn === null || !(io & 268435455) && !(ph & 268435455) || Gi(cn, yn)
}
function Td(t, e) {
    var n = Oe;
    Oe |= 2;
    var r = I_();
    (cn !== t || yn !== e) && (fi = null,
    Js(t, e));
    do
        try {
            DA();
            break
        } catch (i) {
            A_(t, i)
        }
    while (1);
    if (dm(),
    Oe = n,
    Ad.current = r,
    Yt !== null)
        throw Error(ee(261));
    return cn = null,
    yn = 0,
    tn
}
function DA() {
    for (; Yt !== null; )
        M_(Yt)
}
function zA() {
    for (; Yt !== null && !uE(); )
        M_(Yt)
}
function M_(t) {
    var e = C_(t.alternate, t, Xn);
    t.memoizedProps = t.pendingProps,
    e === null ? T_(t) : Yt = e,
    km.current = null
}
function T_(t) {
    var e = t;
    do {
        var n = e.alternate;
        if (t = e.return,
        e.flags & 32768) {
            if (n = RA(n, e),
            n !== null) {
                n.flags &= 32767,
                Yt = n;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                tn = 6,
                Yt = null;
                return
            }
        } else if (n = CA(n, e, Xn),
        n !== null) {
            Yt = n;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Yt = e;
            return
        }
        Yt = e = t
    } while (e !== null);
    tn === 0 && (tn = 5)
}
function Is(t, e, n) {
    var r = Ke
      , i = vr.transition;
    try {
        vr.transition = null,
        Ke = 1,
        UA(t, e, n, r)
    } finally {
        vr.transition = i,
        Ke = r
    }
    return null
}
function UA(t, e, n, r) {
    do
        ua();
    while (Ji !== null);
    if (Oe & 6)
        throw Error(ee(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    n === t.current)
        throw Error(ee(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (bE(t, s),
    t === cn && (Yt = cn = null,
    yn = 0),
    !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Jc || (Jc = !0,
    R_(ud, function() {
        return ua(),
        null
    })),
    s = (n.flags & 15990) !== 0,
    n.subtreeFlags & 15990 || s) {
        s = vr.transition,
        vr.transition = null;
        var o = Ke;
        Ke = 1;
        var a = Oe;
        Oe |= 4,
        km.current = null,
        jA(t, n),
        S_(n, t),
        oA(ep),
        hd = !!X0,
        ep = X0 = null,
        t.current = n,
        BA(n),
        dE(),
        Oe = a,
        Ke = o,
        vr.transition = s
    } else
        t.current = n;
    if (Jc && (Jc = !1,
    Ji = t,
    Md = i),
    s = t.pendingLanes,
    s === 0 && (ls = null),
    pE(n.stateNode),
    Zn(t, Mt()),
    e !== null)
        for (r = t.onRecoverableError,
        n = 0; n < e.length; n++)
            i = e[n],
            r(i.value, {
                componentStack: i.stack,
                digest: i.digest
            });
    if (Id)
        throw Id = !1,
        t = bp,
        bp = null,
        t;
    return Md & 1 && t.tag !== 0 && ua(),
    s = t.pendingLanes,
    s & 1 ? t === _p ? Tl++ : (Tl = 0,
    _p = t) : Tl = 0,
    vs(),
    null
}
function ua() {
    if (Ji !== null) {
        var t = cb(Md)
          , e = vr.transition
          , n = Ke;
        try {
            if (vr.transition = null,
            Ke = 16 > t ? 16 : t,
            Ji === null)
                var r = !1;
            else {
                if (t = Ji,
                Ji = null,
                Md = 0,
                Oe & 6)
                    throw Error(ee(331));
                var i = Oe;
                for (Oe |= 4,
                ce = t.current; ce !== null; ) {
                    var s = ce
                      , o = s.child;
                    if (ce.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (ce = c; ce !== null; ) {
                                    var d = ce;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Il(8, d, s)
                                    }
                                    var h = d.child;
                                    if (h !== null)
                                        h.return = d,
                                        ce = h;
                                    else
                                        for (; ce !== null; ) {
                                            d = ce;
                                            var y = d.sibling
                                              , m = d.return;
                                            if (b_(d),
                                            d === c) {
                                                ce = null;
                                                break
                                            }
                                            if (y !== null) {
                                                y.return = m,
                                                ce = y;
                                                break
                                            }
                                            ce = m
                                        }
                                }
                            }
                            var v = s.alternate;
                            if (v !== null) {
                                var E = v.child;
                                if (E !== null) {
                                    v.child = null;
                                    do {
                                        var A = E.sibling;
                                        E.sibling = null,
                                        E = A
                                    } while (E !== null)
                                }
                            }
                            ce = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        ce = o;
                    else
                        e: for (; ce !== null; ) {
                            if (s = ce,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Il(9, s, s.return)
                                }
                            var _ = s.sibling;
                            if (_ !== null) {
                                _.return = s.return,
                                ce = _;
                                break e
                            }
                            ce = s.return
                        }
                }
                var x = t.current;
                for (ce = x; ce !== null; ) {
                    o = ce;
                    var b = o.child;
                    if (o.subtreeFlags & 2064 && b !== null)
                        b.return = o,
                        ce = b;
                    else
                        e: for (o = x; ce !== null; ) {
                            if (a = ce,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        fh(9, a)
                                    }
                                } catch (O) {
                                    At(a, a.return, O)
                                }
                            if (a === o) {
                                ce = null;
                                break e
                            }
                            var R = a.sibling;
                            if (R !== null) {
                                R.return = a.return,
                                ce = R;
                                break e
                            }
                            ce = a.return
                        }
                }
                if (Oe = i,
                vs(),
                Xr && typeof Xr.onPostCommitFiberRoot == "function")
                    try {
                        Xr.onPostCommitFiberRoot(sh, t)
                    } catch {}
                r = !0
            }
            return r
        } finally {
            Ke = n,
            vr.transition = e
        }
    }
    return !1
}
function Hw(t, e, n) {
    e = xa(n, e),
    e = c_(t, e, 1),
    t = as(t, e, 1),
    e = Pn(),
    t !== null && (pc(t, 1, e),
    Zn(t, e))
}
function At(t, e, n) {
    if (t.tag === 3)
        Hw(t, t, n);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                Hw(e, t, n);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (ls === null || !ls.has(r))) {
                    t = xa(n, t),
                    t = u_(e, t, 1),
                    e = as(e, t, 1),
                    t = Pn(),
                    e !== null && (pc(e, 1, t),
                    Zn(e, t));
                    break
                }
            }
            e = e.return
        }
}
function WA(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e),
    e = Pn(),
    t.pingedLanes |= t.suspendedLanes & n,
    cn === t && (yn & n) === n && (tn === 4 || tn === 3 && (yn & 130023424) === yn && 500 > Mt() - Am ? Js(t, 0) : Em |= n),
    Zn(t, e)
}
function N_(t, e) {
    e === 0 && (t.mode & 1 ? (e = Fc,
    Fc <<= 1,
    !(Fc & 130023424) && (Fc = 4194304)) : e = 1);
    var n = Pn();
    t = Ti(t, e),
    t !== null && (pc(t, e, n),
    Zn(t, n))
}
function FA(t) {
    var e = t.memoizedState
      , n = 0;
    e !== null && (n = e.retryLane),
    N_(t, n)
}
function $A(t, e) {
    var n = 0;
    switch (t.tag) {
    case 13:
        var r = t.stateNode
          , i = t.memoizedState;
        i !== null && (n = i.retryLane);
        break;
    case 19:
        r = t.stateNode;
        break;
    default:
        throw Error(ee(314))
    }
    r !== null && r.delete(e),
    N_(t, n)
}
var C_;
C_ = function(t, e, n) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Gn.current)
            Hn = !0;
        else {
            if (!(t.lanes & n) && !(e.flags & 128))
                return Hn = !1,
                NA(t, e, n);
            Hn = !!(t.flags & 131072)
        }
    else
        Hn = !1,
        ut && e.flags & 1048576 && Bb(e, vd, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var r = e.type;
        Su(t, e),
        t = e.pendingProps;
        var i = wa(e, Rn.current);
        ca(e, n),
        i = vm(null, e, r, t, i, n);
        var s = bm();
        return e.flags |= 1,
        typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Yn(r) ? (s = !0,
        yd(e)) : s = !1,
        e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        pm(e),
        i.updater = hh,
        e.stateNode = i,
        i._reactInternals = e,
        cp(e, r, t, n),
        e = hp(null, e, r, !0, s, n)) : (e.tag = 0,
        ut && s && am(e),
        jn(null, e, i, n),
        e = e.child),
        e;
    case 16:
        r = e.elementType;
        e: {
            switch (Su(t, e),
            t = e.pendingProps,
            i = r._init,
            r = i(r._payload),
            e.type = r,
            i = e.tag = VA(r),
            t = Ir(r, t),
            i) {
            case 0:
                e = dp(null, e, r, t, n);
                break e;
            case 1:
                e = Pw(null, e, r, t, n);
                break e;
            case 11:
                e = jw(null, e, r, t, n);
                break e;
            case 14:
                e = Bw(null, e, r, Ir(r.type, t), n);
                break e
            }
            throw Error(ee(306, r, ""))
        }
        return e;
    case 0:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Ir(r, i),
        dp(t, e, r, i, n);
    case 1:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Ir(r, i),
        Pw(t, e, r, i, n);
    case 3:
        e: {
            if (p_(e),
            t === null)
                throw Error(ee(387));
            r = e.pendingProps,
            s = e.memoizedState,
            i = s.element,
            Wb(t, e),
            xd(e, r, null, n);
            var o = e.memoizedState;
            if (r = o.element,
            s.isDehydrated)
                if (s = {
                    element: r,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    i = xa(Error(ee(423)), e),
                    e = Ow(t, e, r, n, i);
                    break e
                } else if (r !== i) {
                    i = xa(Error(ee(424)), e),
                    e = Ow(t, e, r, n, i);
                    break e
                } else
                    for (rr = os(e.stateNode.containerInfo.firstChild),
                    sr = e,
                    ut = !0,
                    Cr = null,
                    n = zb(e, null, r, n),
                    e.child = n; n; )
                        n.flags = n.flags & -3 | 4096,
                        n = n.sibling;
            else {
                if (va(),
                r === i) {
                    e = Ni(t, e, n);
                    break e
                }
                jn(t, e, r, n)
            }
            e = e.child
        }
        return e;
    case 5:
        return Fb(e),
        t === null && op(e),
        r = e.type,
        i = e.pendingProps,
        s = t !== null ? t.memoizedProps : null,
        o = i.children,
        tp(r, i) ? o = null : s !== null && tp(r, s) && (e.flags |= 32),
        f_(t, e),
        jn(t, e, o, n),
        e.child;
    case 6:
        return t === null && op(e),
        null;
    case 13:
        return g_(t, e, n);
    case 4:
        return gm(e, e.stateNode.containerInfo),
        r = e.pendingProps,
        t === null ? e.child = ba(e, null, r, n) : jn(t, e, r, n),
        e.child;
    case 11:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Ir(r, i),
        jw(t, e, r, i, n);
    case 7:
        return jn(t, e, e.pendingProps, n),
        e.child;
    case 8:
        return jn(t, e, e.pendingProps.children, n),
        e.child;
    case 12:
        return jn(t, e, e.pendingProps.children, n),
        e.child;
    case 10:
        e: {
            if (r = e.type._context,
            i = e.pendingProps,
            s = e.memoizedProps,
            o = i.value,
            tt(bd, r._currentValue),
            r._currentValue = o,
            s !== null)
                if (Pr(s.value, o)) {
                    if (s.children === i.children && !Gn.current) {
                        e = Ni(t, e, n);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === r) {
                                    if (s.tag === 1) {
                                        l = Ai(-1, n & -n),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var d = c.pending;
                                            d === null ? l.next = l : (l.next = d.next,
                                            d.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= n,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= n),
                                    ap(s.return, n, e),
                                    a.lanes |= n;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(ee(341));
                            o.lanes |= n,
                            a = o.alternate,
                            a !== null && (a.lanes |= n),
                            ap(o, n, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            jn(t, e, i.children, n),
            e = e.child
        }
        return e;
    case 9:
        return i = e.type,
        r = e.pendingProps.children,
        ca(e, n),
        i = _r(i),
        r = r(i),
        e.flags |= 1,
        jn(t, e, r, n),
        e.child;
    case 14:
        return r = e.type,
        i = Ir(r, e.pendingProps),
        i = Ir(r.type, i),
        Bw(t, e, r, i, n);
    case 15:
        return d_(t, e, e.type, e.pendingProps, n);
    case 17:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Ir(r, i),
        Su(t, e),
        e.tag = 1,
        Yn(r) ? (t = !0,
        yd(e)) : t = !1,
        ca(e, n),
        l_(e, r, i),
        cp(e, r, i, n),
        hp(null, e, r, !0, t, n);
    case 19:
        return m_(t, e, n);
    case 22:
        return h_(t, e, n)
    }
    throw Error(ee(156, e.tag))
}
;
function R_(t, e) {
    return sb(t, e)
}
function KA(t, e, n, r) {
    this.tag = t,
    this.key = n,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = r,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function wr(t, e, n, r) {
    return new KA(t,e,n,r)
}
function Nm(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function VA(t) {
    if (typeof t == "function")
        return Nm(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === Yg)
            return 11;
        if (t === Zg)
            return 14
    }
    return 2
}
function us(t, e) {
    var n = t.alternate;
    return n === null ? (n = wr(t.tag, e, t.key, t.mode),
    n.elementType = t.elementType,
    n.type = t.type,
    n.stateNode = t.stateNode,
    n.alternate = t,
    t.alternate = n) : (n.pendingProps = e,
    n.type = t.type,
    n.flags = 0,
    n.subtreeFlags = 0,
    n.deletions = null),
    n.flags = t.flags & 14680064,
    n.childLanes = t.childLanes,
    n.lanes = t.lanes,
    n.child = t.child,
    n.memoizedProps = t.memoizedProps,
    n.memoizedState = t.memoizedState,
    n.updateQueue = t.updateQueue,
    e = t.dependencies,
    n.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    n.sibling = t.sibling,
    n.index = t.index,
    n.ref = t.ref,
    n
}
function Au(t, e, n, r, i, s) {
    var o = 2;
    if (r = t,
    typeof t == "function")
        Nm(t) && (o = 1);
    else if (typeof t == "string")
        o = 5;
    else
        e: switch (t) {
        case Vo:
            return Xs(n.children, i, s, e);
        case Gg:
            o = 8,
            i |= 8;
            break;
        case L0:
            return t = wr(12, n, e, i | 2),
            t.elementType = L0,
            t.lanes = s,
            t;
        case j0:
            return t = wr(13, n, e, i),
            t.elementType = j0,
            t.lanes = s,
            t;
        case B0:
            return t = wr(19, n, e, i),
            t.elementType = B0,
            t.lanes = s,
            t;
        case Fv:
            return gh(n, i, s, e);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case Uv:
                    o = 10;
                    break e;
                case Wv:
                    o = 9;
                    break e;
                case Yg:
                    o = 11;
                    break e;
                case Zg:
                    o = 14;
                    break e;
                case Ki:
                    o = 16,
                    r = null;
                    break e
                }
            throw Error(ee(130, t == null ? t : typeof t, ""))
        }
    return e = wr(o, n, e, i),
    e.elementType = t,
    e.type = r,
    e.lanes = s,
    e
}
function Xs(t, e, n, r) {
    return t = wr(7, t, r, e),
    t.lanes = n,
    t
}
function gh(t, e, n, r) {
    return t = wr(22, t, r, e),
    t.elementType = Fv,
    t.lanes = n,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function Kf(t, e, n) {
    return t = wr(6, t, null, e),
    t.lanes = n,
    t
}
function Vf(t, e, n) {
    return e = wr(4, t.children !== null ? t.children : [], t.key, e),
    e.lanes = n,
    e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    e
}
function HA(t, e, n, r, i) {
    this.tag = e,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Ef(0),
    this.expirationTimes = Ef(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Ef(0),
    this.identifierPrefix = r,
    this.onRecoverableError = i,
    this.mutableSourceEagerHydrationData = null
}
function Cm(t, e, n, r, i, s, o, a, l) {
    return t = new HA(t,e,n,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = wr(3, null, null, e),
    t.current = s,
    s.stateNode = t,
    s.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    pm(s),
    t
}
function qA(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Ko,
        key: r == null ? null : "" + r,
        children: t,
        containerInfo: e,
        implementation: n
    }
}
function L_(t) {
    if (!t)
        return ps;
    t = t._reactInternals;
    e: {
        if (po(t) !== t || t.tag !== 1)
            throw Error(ee(170));
        var e = t;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Yn(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(ee(171))
    }
    if (t.tag === 1) {
        var n = t.type;
        if (Yn(n))
            return Lb(t, n, e)
    }
    return e
}
function j_(t, e, n, r, i, s, o, a, l) {
    return t = Cm(n, r, !0, t, i, s, o, a, l),
    t.context = L_(null),
    n = t.current,
    r = Pn(),
    i = cs(n),
    s = Ai(r, i),
    s.callback = e ?? null,
    as(n, s, i),
    t.current.lanes = i,
    pc(t, i, r),
    Zn(t, r),
    t
}
function mh(t, e, n, r) {
    var i = e.current
      , s = Pn()
      , o = cs(i);
    return n = L_(n),
    e.context === null ? e.context = n : e.pendingContext = n,
    e = Ai(s, o),
    e.payload = {
        element: t
    },
    r = r === void 0 ? null : r,
    r !== null && (e.callback = r),
    t = as(i, e, o),
    t !== null && (jr(t, i, o, s),
    bu(t, i, o)),
    o
}
function Nd(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function qw(t, e) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var n = t.retryLane;
        t.retryLane = n !== 0 && n < e ? n : e
    }
}
function Rm(t, e) {
    qw(t, e),
    (t = t.alternate) && qw(t, e)
}
function GA() {
    return null
}
var B_ = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function Lm(t) {
    this._internalRoot = t
}
yh.prototype.render = Lm.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(ee(409));
    mh(t, e, null, null)
}
;
yh.prototype.unmount = Lm.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        so(function() {
            mh(null, t, null, null)
        }),
        e[Mi] = null
    }
}
;
function yh(t) {
    this._internalRoot = t
}
yh.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = hb();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var n = 0; n < qi.length && e !== 0 && e < qi[n].priority; n++)
            ;
        qi.splice(n, 0, t),
        n === 0 && pb(t)
    }
}
;
function jm(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function wh(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function Gw() {}
function YA(t, e, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var c = Nd(o);
                s.call(c)
            }
        }
        var o = j_(e, r, t, 0, null, !1, !1, "", Gw);
        return t._reactRootContainer = o,
        t[Mi] = o.current,
        Hl(t.nodeType === 8 ? t.parentNode : t),
        so(),
        o
    }
    for (; i = t.lastChild; )
        t.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var c = Nd(l);
            a.call(c)
        }
    }
    var l = Cm(t, 0, !1, null, null, !1, !1, "", Gw);
    return t._reactRootContainer = l,
    t[Mi] = l.current,
    Hl(t.nodeType === 8 ? t.parentNode : t),
    so(function() {
        mh(e, l, n, r)
    }),
    l
}
function vh(t, e, n, r, i) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = Nd(o);
                a.call(l)
            }
        }
        mh(e, o, t, i)
    } else
        o = YA(n, e, t, i, r);
    return Nd(o)
}
ub = function(t) {
    switch (t.tag) {
    case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var n = al(e.pendingLanes);
            n !== 0 && (Xg(e, n | 1),
            Zn(e, Mt()),
            !(Oe & 6) && (Sa = Mt() + 500,
            vs()))
        }
        break;
    case 13:
        so(function() {
            var r = Ti(t, 1);
            if (r !== null) {
                var i = Pn();
                jr(r, t, 1, i)
            }
        }),
        Rm(t, 1)
    }
}
;
em = function(t) {
    if (t.tag === 13) {
        var e = Ti(t, 134217728);
        if (e !== null) {
            var n = Pn();
            jr(e, t, 134217728, n)
        }
        Rm(t, 134217728)
    }
}
;
db = function(t) {
    if (t.tag === 13) {
        var e = cs(t)
          , n = Ti(t, e);
        if (n !== null) {
            var r = Pn();
            jr(n, t, e, r)
        }
        Rm(t, e)
    }
}
;
hb = function() {
    return Ke
}
;
fb = function(t, e) {
    var n = Ke;
    try {
        return Ke = t,
        e()
    } finally {
        Ke = n
    }
}
;
V0 = function(t, e, n) {
    switch (e) {
    case "input":
        if (D0(t, n),
        e = n.name,
        n.type === "radio" && e != null) {
            for (n = t; n.parentNode; )
                n = n.parentNode;
            for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < n.length; e++) {
                var r = n[e];
                if (r !== t && r.form === t.form) {
                    var i = ch(r);
                    if (!i)
                        throw Error(ee(90));
                    Kv(r),
                    D0(r, i)
                }
            }
        }
        break;
    case "textarea":
        Hv(t, n);
        break;
    case "select":
        e = n.value,
        e != null && sa(t, !!n.multiple, e, !1)
    }
}
;
Xv = Im;
eb = so;
var ZA = {
    usingClientEntryPoint: !1,
    Events: [mc, Yo, ch, Qv, Jv, Im]
}
  , el = {
    findFiberByHostInstance: zs,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , QA = {
    bundleType: el.bundleType,
    version: el.version,
    rendererPackageName: el.rendererPackageName,
    rendererConfig: el.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Ri.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = rb(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: el.findFiberByHostInstance || GA,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Xc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Xc.isDisabled && Xc.supportsFiber)
        try {
            sh = Xc.inject(QA),
            Xr = Xc
        } catch {}
}
cr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ZA;
cr.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!jm(e))
        throw Error(ee(200));
    return qA(t, e, null, n)
}
;
cr.createRoot = function(t, e) {
    if (!jm(t))
        throw Error(ee(299));
    var n = !1
      , r = ""
      , i = B_;
    return e != null && (e.unstable_strictMode === !0 && (n = !0),
    e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    e = Cm(t, 1, !1, null, null, n, !1, r, i),
    t[Mi] = e.current,
    Hl(t.nodeType === 8 ? t.parentNode : t),
    new Lm(e)
}
;
cr.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var e = t._reactInternals;
    if (e === void 0)
        throw typeof t.render == "function" ? Error(ee(188)) : (t = Object.keys(t).join(","),
        Error(ee(268, t)));
    return t = rb(e),
    t = t === null ? null : t.stateNode,
    t
}
;
cr.flushSync = function(t) {
    return so(t)
}
;
cr.hydrate = function(t, e, n) {
    if (!wh(e))
        throw Error(ee(200));
    return vh(null, t, e, !0, n)
}
;
cr.hydrateRoot = function(t, e, n) {
    if (!jm(t))
        throw Error(ee(405));
    var r = n != null && n.hydratedSources || null
      , i = !1
      , s = ""
      , o = B_;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0),
    n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
    n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    e = j_(e, null, t, 1, n ?? null, i, !1, s, o),
    t[Mi] = e.current,
    Hl(t),
    r)
        for (t = 0; t < r.length; t++)
            n = r[t],
            i = n._getVersion,
            i = i(n._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
    return new yh(e)
}
;
cr.render = function(t, e, n) {
    if (!wh(e))
        throw Error(ee(200));
    return vh(null, t, e, !1, n)
}
;
cr.unmountComponentAtNode = function(t) {
    if (!wh(t))
        throw Error(ee(40));
    return t._reactRootContainer ? (so(function() {
        vh(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[Mi] = null
        })
    }),
    !0) : !1
}
;
cr.unstable_batchedUpdates = Im;
cr.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!wh(n))
        throw Error(ee(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(ee(38));
    return vh(t, e, n, !1, r)
}
;
cr.version = "18.3.1-next-f1338f8080-20240426";
function P_() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(P_)
        } catch (t) {
            console.error(t)
        }
}
P_(),
Pv.exports = cr;
var O_ = Pv.exports
  , Yw = O_;
C0.createRoot = Yw.createRoot,
C0.hydrateRoot = Yw.hydrateRoot;
const ko = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function wc(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}
function tc(t) {
    if (!Number.isSafeInteger(t) || t < 0)
        throw new Error("positive integer expected, got " + t)
}
function Ci(t, ...e) {
    if (!wc(t))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length)
}
function D_(t) {
    if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
    tc(t.outputLen),
    tc(t.blockLen)
}
function ka(t, e=!0) {
    if (t.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
        throw new Error("Hash#digest() has already been called")
}
function z_(t, e) {
    Ci(t);
    const n = e.outputLen;
    if (t.length < n)
        throw new Error("digestInto() expects output buffer of length at least " + n)
}
function JA(t) {
    return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength / 4))
}
function gs(...t) {
    for (let e = 0; e < t.length; e++)
        t[e].fill(0)
}
function Hf(t) {
    return new DataView(t.buffer,t.byteOffset,t.byteLength)
}
function Ur(t, e) {
    return t << 32 - e | t >>> e
}
const XA = ( () => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function e4(t) {
    return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255
}
function t4(t) {
    for (let e = 0; e < t.length; e++)
        t[e] = e4(t[e]);
    return t
}
const Zw = XA ? t => t : t4
  , U_ = ( () => typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function")()
  , n4 = Array.from({
    length: 256
}, (t, e) => e.toString(16).padStart(2, "0"));
function eo(t) {
    if (Ci(t),
    U_)
        return t.toHex();
    let e = "";
    for (let n = 0; n < t.length; n++)
        e += n4[t[n]];
    return e
}
const li = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function Qw(t) {
    if (t >= li._0 && t <= li._9)
        return t - li._0;
    if (t >= li.A && t <= li.F)
        return t - (li.A - 10);
    if (t >= li.a && t <= li.f)
        return t - (li.a - 10)
}
function Cd(t) {
    if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
    if (U_)
        return Uint8Array.fromHex(t);
    const e = t.length
      , n = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(n);
    for (let i = 0, s = 0; i < n; i++,
    s += 2) {
        const o = Qw(t.charCodeAt(s))
          , a = Qw(t.charCodeAt(s + 1));
        if (o === void 0 || a === void 0) {
            const l = t[s] + t[s + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + s)
        }
        r[i] = o * 16 + a
    }
    return r
}
function r4(t) {
    if (typeof t != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(t))
}
function bh(t) {
    return typeof t == "string" && (t = r4(t)),
    Ci(t),
    t
}
function Hr(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        Ci(i),
        e += i.length
    }
    const n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
        const s = t[r];
        n.set(s, i),
        i += s.length
    }
    return n
}
class Bm {
}
function Pm(t) {
    const e = r => t().update(bh(r)).digest()
      , n = t();
    return e.outputLen = n.outputLen,
    e.blockLen = n.blockLen,
    e.create = () => t(),
    e
}
function Om(t=32) {
    if (ko && typeof ko.getRandomValues == "function")
        return ko.getRandomValues(new Uint8Array(t));
    if (ko && typeof ko.randomBytes == "function")
        return Uint8Array.from(ko.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined")
}
function i4(t, e, n, r) {
    if (typeof t.setBigUint64 == "function")
        return t.setBigUint64(e, n, r);
    const i = BigInt(32)
      , s = BigInt(4294967295)
      , o = Number(n >> i & s)
      , a = Number(n & s)
      , l = r ? 4 : 0
      , c = r ? 0 : 4;
    t.setUint32(e + l, o, r),
    t.setUint32(e + c, a, r)
}
function s4(t, e, n) {
    return t & e ^ ~t & n
}
function o4(t, e, n) {
    return t & e ^ t & n ^ e & n
}
class W_ extends Bm {
    constructor(e, n, r, i) {
        super(),
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.blockLen = e,
        this.outputLen = n,
        this.padOffset = r,
        this.isLE = i,
        this.buffer = new Uint8Array(e),
        this.view = Hf(this.buffer)
    }
    update(e) {
        ka(this),
        e = bh(e),
        Ci(e);
        const {view: n, buffer: r, blockLen: i} = this
          , s = e.length;
        for (let o = 0; o < s; ) {
            const a = Math.min(i - this.pos, s - o);
            if (a === i) {
                const l = Hf(e);
                for (; i <= s - o; o += i)
                    this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === i && (this.process(n, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        ka(this),
        z_(e, this),
        this.finished = !0;
        const {buffer: n, view: r, blockLen: i, isLE: s} = this;
        let {pos: o} = this;
        n[o++] = 128,
        gs(this.buffer.subarray(o)),
        this.padOffset > i - o && (this.process(r, 0),
        o = 0);
        for (let h = o; h < i; h++)
            n[h] = 0;
        i4(r, i - 8, BigInt(this.length * 8), s),
        this.process(r, 0);
        const a = Hf(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = l / 4
          , d = this.get();
        if (c > d.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < c; h++)
            a.setUint32(4 * h, d[h], s)
    }
    digest() {
        const {buffer: e, outputLen: n} = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a} = this;
        return e.destroyed = o,
        e.finished = s,
        e.length = i,
        e.pos = a,
        i % n && e.buffer.set(r),
        e
    }
    clone() {
        return this._cloneInto()
    }
}
const ji = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , xn = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209])
  , eu = BigInt(2 ** 32 - 1)
  , Jw = BigInt(32);
function a4(t, e=!1) {
    return e ? {
        h: Number(t & eu),
        l: Number(t >> Jw & eu)
    } : {
        h: Number(t >> Jw & eu) | 0,
        l: Number(t & eu) | 0
    }
}
function F_(t, e=!1) {
    const n = t.length;
    let r = new Uint32Array(n)
      , i = new Uint32Array(n);
    for (let s = 0; s < n; s++) {
        const {h: o, l: a} = a4(t[s], e);
        [r[s],i[s]] = [o, a]
    }
    return [r, i]
}
const Xw = (t, e, n) => t >>> n
  , e1 = (t, e, n) => t << 32 - n | e >>> n
  , Eo = (t, e, n) => t >>> n | e << 32 - n
  , Ao = (t, e, n) => t << 32 - n | e >>> n
  , tu = (t, e, n) => t << 64 - n | e >>> n - 32
  , nu = (t, e, n) => t >>> n - 32 | e << 64 - n
  , l4 = (t, e, n) => t << n | e >>> 32 - n
  , c4 = (t, e, n) => e << n | t >>> 32 - n
  , u4 = (t, e, n) => e << n - 32 | t >>> 64 - n
  , d4 = (t, e, n) => t << n - 32 | e >>> 64 - n;
function ci(t, e, n, r) {
    const i = (e >>> 0) + (r >>> 0);
    return {
        h: t + n + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const h4 = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0)
  , f4 = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0
  , p4 = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0)
  , g4 = (t, e, n, r, i) => e + n + r + i + (t / 2 ** 32 | 0) | 0
  , m4 = (t, e, n, r, i) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
  , y4 = (t, e, n, r, i, s) => e + n + r + i + s + (t / 2 ** 32 | 0) | 0
  , w4 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , Bi = new Uint32Array(64);
class v4 extends W_ {
    constructor(e=32) {
        super(64, e, 8, !1),
        this.A = ji[0] | 0,
        this.B = ji[1] | 0,
        this.C = ji[2] | 0,
        this.D = ji[3] | 0,
        this.E = ji[4] | 0,
        this.F = ji[5] | 0,
        this.G = ji[6] | 0,
        this.H = ji[7] | 0
    }
    get() {
        const {A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: l} = this;
        return [e, n, r, i, s, o, a, l]
    }
    set(e, n, r, i, s, o, a, l) {
        this.A = e | 0,
        this.B = n | 0,
        this.C = r | 0,
        this.D = i | 0,
        this.E = s | 0,
        this.F = o | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, n) {
        for (let h = 0; h < 16; h++,
        n += 4)
            Bi[h] = e.getUint32(n, !1);
        for (let h = 16; h < 64; h++) {
            const y = Bi[h - 15]
              , m = Bi[h - 2]
              , v = Ur(y, 7) ^ Ur(y, 18) ^ y >>> 3
              , E = Ur(m, 17) ^ Ur(m, 19) ^ m >>> 10;
            Bi[h] = E + Bi[h - 7] + v + Bi[h - 16] | 0
        }
        let {A: r, B: i, C: s, D: o, E: a, F: l, G: c, H: d} = this;
        for (let h = 0; h < 64; h++) {
            const y = Ur(a, 6) ^ Ur(a, 11) ^ Ur(a, 25)
              , m = d + y + s4(a, l, c) + w4[h] + Bi[h] | 0
              , E = (Ur(r, 2) ^ Ur(r, 13) ^ Ur(r, 22)) + o4(r, i, s) | 0;
            d = c,
            c = l,
            l = a,
            a = o + m | 0,
            o = s,
            s = i,
            i = r,
            r = m + E | 0
        }
        r = r + this.A | 0,
        i = i + this.B | 0,
        s = s + this.C | 0,
        o = o + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        c = c + this.G | 0,
        d = d + this.H | 0,
        this.set(r, i, s, o, a, l, c, d)
    }
    roundClean() {
        gs(Bi)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        gs(this.buffer)
    }
}
const $_ = ( () => F_(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))))()
  , b4 = ( () => $_[0])()
  , _4 = ( () => $_[1])()
  , Pi = new Uint32Array(80)
  , Oi = new Uint32Array(80);
class x4 extends W_ {
    constructor(e=64) {
        super(128, e, 16, !1),
        this.Ah = xn[0] | 0,
        this.Al = xn[1] | 0,
        this.Bh = xn[2] | 0,
        this.Bl = xn[3] | 0,
        this.Ch = xn[4] | 0,
        this.Cl = xn[5] | 0,
        this.Dh = xn[6] | 0,
        this.Dl = xn[7] | 0,
        this.Eh = xn[8] | 0,
        this.El = xn[9] | 0,
        this.Fh = xn[10] | 0,
        this.Fl = xn[11] | 0,
        this.Gh = xn[12] | 0,
        this.Gl = xn[13] | 0,
        this.Hh = xn[14] | 0,
        this.Hl = xn[15] | 0
    }
    get() {
        const {Ah: e, Al: n, Bh: r, Bl: i, Ch: s, Cl: o, Dh: a, Dl: l, Eh: c, El: d, Fh: h, Fl: y, Gh: m, Gl: v, Hh: E, Hl: A} = this;
        return [e, n, r, i, s, o, a, l, c, d, h, y, m, v, E, A]
    }
    set(e, n, r, i, s, o, a, l, c, d, h, y, m, v, E, A) {
        this.Ah = e | 0,
        this.Al = n | 0,
        this.Bh = r | 0,
        this.Bl = i | 0,
        this.Ch = s | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = c | 0,
        this.El = d | 0,
        this.Fh = h | 0,
        this.Fl = y | 0,
        this.Gh = m | 0,
        this.Gl = v | 0,
        this.Hh = E | 0,
        this.Hl = A | 0
    }
    process(e, n) {
        for (let b = 0; b < 16; b++,
        n += 4)
            Pi[b] = e.getUint32(n),
            Oi[b] = e.getUint32(n += 4);
        for (let b = 16; b < 80; b++) {
            const R = Pi[b - 15] | 0
              , O = Oi[b - 15] | 0
              , D = Eo(R, O, 1) ^ Eo(R, O, 8) ^ Xw(R, O, 7)
              , z = Ao(R, O, 1) ^ Ao(R, O, 8) ^ e1(R, O, 7)
              , K = Pi[b - 2] | 0
              , F = Oi[b - 2] | 0
              , G = Eo(K, F, 19) ^ tu(K, F, 61) ^ Xw(K, F, 6)
              , Z = Ao(K, F, 19) ^ nu(K, F, 61) ^ e1(K, F, 6)
              , X = p4(z, Z, Oi[b - 7], Oi[b - 16])
              , T = g4(X, D, G, Pi[b - 7], Pi[b - 16]);
            Pi[b] = T | 0,
            Oi[b] = X | 0
        }
        let {Ah: r, Al: i, Bh: s, Bl: o, Ch: a, Cl: l, Dh: c, Dl: d, Eh: h, El: y, Fh: m, Fl: v, Gh: E, Gl: A, Hh: _, Hl: x} = this;
        for (let b = 0; b < 80; b++) {
            const R = Eo(h, y, 14) ^ Eo(h, y, 18) ^ tu(h, y, 41)
              , O = Ao(h, y, 14) ^ Ao(h, y, 18) ^ nu(h, y, 41)
              , D = h & m ^ ~h & E
              , z = y & v ^ ~y & A
              , K = m4(x, O, z, _4[b], Oi[b])
              , F = y4(K, _, R, D, b4[b], Pi[b])
              , G = K | 0
              , Z = Eo(r, i, 28) ^ tu(r, i, 34) ^ tu(r, i, 39)
              , X = Ao(r, i, 28) ^ nu(r, i, 34) ^ nu(r, i, 39)
              , T = r & s ^ r & a ^ s & a
              , u = i & o ^ i & l ^ o & l;
            _ = E | 0,
            x = A | 0,
            E = m | 0,
            A = v | 0,
            m = h | 0,
            v = y | 0,
            {h, l: y} = ci(c | 0, d | 0, F | 0, G | 0),
            c = a | 0,
            d = l | 0,
            a = s | 0,
            l = o | 0,
            s = r | 0,
            o = i | 0;
            const p = h4(G, X, u);
            r = f4(p, F, Z, T),
            i = p | 0
        }
        ({h: r, l: i} = ci(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        {h: s, l: o} = ci(this.Bh | 0, this.Bl | 0, s | 0, o | 0),
        {h: a, l} = ci(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: c, l: d} = ci(this.Dh | 0, this.Dl | 0, c | 0, d | 0),
        {h, l: y} = ci(this.Eh | 0, this.El | 0, h | 0, y | 0),
        {h: m, l: v} = ci(this.Fh | 0, this.Fl | 0, m | 0, v | 0),
        {h: E, l: A} = ci(this.Gh | 0, this.Gl | 0, E | 0, A | 0),
        {h: _, l: x} = ci(this.Hh | 0, this.Hl | 0, _ | 0, x | 0),
        this.set(r, i, s, o, a, l, c, d, h, y, m, v, E, A, _, x)
    }
    roundClean() {
        gs(Pi, Oi)
    }
    destroy() {
        gs(this.buffer),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const K_ = Pm( () => new v4)
  , S4 = Pm( () => new x4);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Dm = BigInt(0)
  , kp = BigInt(1);
function oo(t, e="") {
    if (typeof t != "boolean") {
        const n = e && `"${e}"`;
        throw new Error(n + "expected boolean, got type=" + typeof t)
    }
    return t
}
function Rr(t, e, n="") {
    const r = wc(t)
      , i = t?.length
      , s = e !== void 0;
    if (!r || s && i !== e) {
        const o = n && `"${n}" `
          , a = s ? ` of length ${e}` : ""
          , l = r ? `length=${i}` : `type=${typeof t}`;
        throw new Error(o + "expected Uint8Array" + a + ", got " + l)
    }
    return t
}
function ru(t) {
    const e = t.toString(16);
    return e.length & 1 ? "0" + e : e
}
function V_(t) {
    if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
    return t === "" ? Dm : BigInt("0x" + t)
}
function _h(t) {
    return V_(eo(t))
}
function nc(t) {
    return Ci(t),
    V_(eo(Uint8Array.from(t).reverse()))
}
function zm(t, e) {
    return Cd(t.toString(16).padStart(e * 2, "0"))
}
function H_(t, e) {
    return zm(t, e).reverse()
}
function Et(t, e, n) {
    let r;
    if (typeof e == "string")
        try {
            r = Cd(e)
        } catch (s) {
            throw new Error(t + " must be hex string or Uint8Array, cause: " + s)
        }
    else if (wc(e))
        r = Uint8Array.from(e);
    else
        throw new Error(t + " must be hex string or Uint8Array");
    const i = r.length;
    if (typeof n == "number" && i !== n)
        throw new Error(t + " of length " + n + " expected, got " + i);
    return r
}
function t1(t) {
    return Uint8Array.from(t)
}
const qf = t => typeof t == "bigint" && Dm <= t;
function k4(t, e, n) {
    return qf(t) && qf(e) && qf(n) && e <= t && t < n
}
function Ep(t, e, n, r) {
    if (!k4(e, n, r))
        throw new Error("expected valid " + t + ": " + n + " <= n < " + r + ", got " + e)
}
function q_(t) {
    let e;
    for (e = 0; t > Dm; t >>= kp,
    e += 1)
        ;
    return e
}
const vc = t => (kp << BigInt(t)) - kp;
function E4(t, e, n) {
    if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof n != "function")
        throw new Error("hmacFn must be a function");
    const r = m => new Uint8Array(m)
      , i = m => Uint8Array.of(m);
    let s = r(t)
      , o = r(t)
      , a = 0;
    const l = () => {
        s.fill(1),
        o.fill(0),
        a = 0
    }
      , c = (...m) => n(o, s, ...m)
      , d = (m=r(0)) => {
        o = c(i(0), m),
        s = c(),
        m.length !== 0 && (o = c(i(1), m),
        s = c())
    }
      , h = () => {
        if (a++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let m = 0;
        const v = [];
        for (; m < e; ) {
            s = c();
            const E = s.slice();
            v.push(E),
            m += s.length
        }
        return Hr(...v)
    }
    ;
    return (m, v) => {
        l(),
        d(m);
        let E;
        for (; !(E = v(h())); )
            d();
        return l(),
        E
    }
}
function bc(t, e, n={}) {
    if (!t || typeof t != "object")
        throw new Error("expected valid options object");
    function r(i, s, o) {
        const a = t[i];
        if (o && a === void 0)
            return;
        const l = typeof a;
        if (l !== s || a === null)
            throw new Error(`param "${i}" is invalid: expected ${s}, got ${l}`)
    }
    Object.entries(e).forEach( ([i,s]) => r(i, s, !1)),
    Object.entries(n).forEach( ([i,s]) => r(i, s, !0))
}
function Rd(t) {
    const e = new WeakMap;
    return (n, ...r) => {
        const i = e.get(n);
        if (i !== void 0)
            return i;
        const s = t(n, ...r);
        return e.set(n, s),
        s
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qn = BigInt(0)
  , wn = BigInt(1)
  , Fs = BigInt(2)
  , G_ = BigInt(3)
  , Y_ = BigInt(4)
  , Z_ = BigInt(5)
  , A4 = BigInt(7)
  , Q_ = BigInt(8)
  , I4 = BigInt(9)
  , J_ = BigInt(16);
function qt(t, e) {
    const n = t % e;
    return n >= qn ? n : e + n
}
function kt(t, e, n) {
    let r = t;
    for (; e-- > qn; )
        r *= r,
        r %= n;
    return r
}
function n1(t, e) {
    if (t === qn)
        throw new Error("invert: expected non-zero number");
    if (e <= qn)
        throw new Error("invert: expected positive modulus, got " + e);
    let n = qt(t, e)
      , r = e
      , i = qn
      , s = wn;
    for (; n !== qn; ) {
        const a = r / n
          , l = r % n
          , c = i - s * a;
        r = n,
        n = l,
        i = s,
        s = c
    }
    if (r !== wn)
        throw new Error("invert: does not exist");
    return qt(i, e)
}
function Um(t, e, n) {
    if (!t.eql(t.sqr(e), n))
        throw new Error("Cannot find square root")
}
function X_(t, e) {
    const n = (t.ORDER + wn) / Y_
      , r = t.pow(e, n);
    return Um(t, r, e),
    r
}
function M4(t, e) {
    const n = (t.ORDER - Z_) / Q_
      , r = t.mul(e, Fs)
      , i = t.pow(r, n)
      , s = t.mul(e, i)
      , o = t.mul(t.mul(s, Fs), i)
      , a = t.mul(s, t.sub(o, t.ONE));
    return Um(t, a, e),
    a
}
function T4(t) {
    const e = go(t)
      , n = ex(t)
      , r = n(e, e.neg(e.ONE))
      , i = n(e, r)
      , s = n(e, e.neg(r))
      , o = (t + A4) / J_;
    return (a, l) => {
        let c = a.pow(l, o)
          , d = a.mul(c, r);
        const h = a.mul(c, i)
          , y = a.mul(c, s)
          , m = a.eql(a.sqr(d), l)
          , v = a.eql(a.sqr(h), l);
        c = a.cmov(c, d, m),
        d = a.cmov(y, h, v);
        const E = a.eql(a.sqr(d), l)
          , A = a.cmov(c, d, E);
        return Um(a, A, l),
        A
    }
}
function ex(t) {
    if (t < G_)
        throw new Error("sqrt is not defined for small field");
    let e = t - wn
      , n = 0;
    for (; e % Fs === qn; )
        e /= Fs,
        n++;
    let r = Fs;
    const i = go(t);
    for (; r1(i, r) === 1; )
        if (r++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
    if (n === 1)
        return X_;
    let s = i.pow(r, e);
    const o = (e + wn) / Fs;
    return function(l, c) {
        if (l.is0(c))
            return c;
        if (r1(l, c) !== 1)
            throw new Error("Cannot find square root");
        let d = n
          , h = l.mul(l.ONE, s)
          , y = l.pow(c, e)
          , m = l.pow(c, o);
        for (; !l.eql(y, l.ONE); ) {
            if (l.is0(y))
                return l.ZERO;
            let v = 1
              , E = l.sqr(y);
            for (; !l.eql(E, l.ONE); )
                if (v++,
                E = l.sqr(E),
                v === d)
                    throw new Error("Cannot find square root");
            const A = wn << BigInt(d - v - 1)
              , _ = l.pow(h, A);
            d = v,
            h = l.sqr(_),
            y = l.mul(y, h),
            m = l.mul(m, _)
        }
        return m
    }
}
function N4(t) {
    return t % Y_ === G_ ? X_ : t % Q_ === Z_ ? M4 : t % J_ === I4 ? T4(t) : ex(t)
}
const C4 = (t, e) => (qt(t, e) & wn) === wn
  , R4 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function L4(t) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }
      , n = R4.reduce( (r, i) => (r[i] = "function",
    r), e);
    return bc(t, n),
    t
}
function j4(t, e, n) {
    if (n < qn)
        throw new Error("invalid exponent, negatives unsupported");
    if (n === qn)
        return t.ONE;
    if (n === wn)
        return e;
    let r = t.ONE
      , i = e;
    for (; n > qn; )
        n & wn && (r = t.mul(r, i)),
        i = t.sqr(i),
        n >>= wn;
    return r
}
function tx(t, e, n=!1) {
    const r = new Array(e.length).fill(n ? t.ZERO : void 0)
      , i = e.reduce( (o, a, l) => t.is0(a) ? o : (r[l] = o,
    t.mul(o, a)), t.ONE)
      , s = t.inv(i);
    return e.reduceRight( (o, a, l) => t.is0(a) ? o : (r[l] = t.mul(o, r[l]),
    t.mul(o, a)), s),
    r
}
function r1(t, e) {
    const n = (t.ORDER - wn) / Fs
      , r = t.pow(e, n)
      , i = t.eql(r, t.ONE)
      , s = t.eql(r, t.ZERO)
      , o = t.eql(r, t.neg(t.ONE));
    if (!i && !s && !o)
        throw new Error("invalid Legendre symbol result");
    return i ? 1 : s ? 0 : -1
}
function nx(t, e) {
    e !== void 0 && tc(e);
    const n = e !== void 0 ? e : t.toString(2).length
      , r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    }
}
function go(t, e, n=!1, r={}) {
    if (t <= qn)
        throw new Error("invalid field: expected ORDER > 0, got " + t);
    let i, s, o = !1, a;
    if (typeof e == "object" && e != null) {
        if (r.sqrt || n)
            throw new Error("cannot specify opts in two arguments");
        const y = e;
        y.BITS && (i = y.BITS),
        y.sqrt && (s = y.sqrt),
        typeof y.isLE == "boolean" && (n = y.isLE),
        typeof y.modFromBytes == "boolean" && (o = y.modFromBytes),
        a = y.allowedLengths
    } else
        typeof e == "number" && (i = e),
        r.sqrt && (s = r.sqrt);
    const {nBitLength: l, nByteLength: c} = nx(t, i);
    if (c > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let d;
    const h = Object.freeze({
        ORDER: t,
        isLE: n,
        BITS: l,
        BYTES: c,
        MASK: vc(l),
        ZERO: qn,
        ONE: wn,
        allowedLengths: a,
        create: y => qt(y, t),
        isValid: y => {
            if (typeof y != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof y);
            return qn <= y && y < t
        }
        ,
        is0: y => y === qn,
        isValidNot0: y => !h.is0(y) && h.isValid(y),
        isOdd: y => (y & wn) === wn,
        neg: y => qt(-y, t),
        eql: (y, m) => y === m,
        sqr: y => qt(y * y, t),
        add: (y, m) => qt(y + m, t),
        sub: (y, m) => qt(y - m, t),
        mul: (y, m) => qt(y * m, t),
        pow: (y, m) => j4(h, y, m),
        div: (y, m) => qt(y * n1(m, t), t),
        sqrN: y => y * y,
        addN: (y, m) => y + m,
        subN: (y, m) => y - m,
        mulN: (y, m) => y * m,
        inv: y => n1(y, t),
        sqrt: s || (y => (d || (d = N4(t)),
        d(h, y))),
        toBytes: y => n ? H_(y, c) : zm(y, c),
        fromBytes: (y, m=!0) => {
            if (a) {
                if (!a.includes(y.length) || y.length > c)
                    throw new Error("Field.fromBytes: expected " + a + " bytes, got " + y.length);
                const E = new Uint8Array(c);
                E.set(y, n ? 0 : E.length - y.length),
                y = E
            }
            if (y.length !== c)
                throw new Error("Field.fromBytes: expected " + c + " bytes, got " + y.length);
            let v = n ? nc(y) : _h(y);
            if (o && (v = qt(v, t)),
            !m && !h.isValid(v))
                throw new Error("invalid field element: outside of range 0..ORDER");
            return v
        }
        ,
        invertBatch: y => tx(h, y),
        cmov: (y, m, v) => v ? m : y
    });
    return Object.freeze(h)
}
function rx(t) {
    if (typeof t != "bigint")
        throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8)
}
function ix(t) {
    const e = rx(t);
    return e + Math.ceil(e / 2)
}
function B4(t, e, n=!1) {
    const r = t.length
      , i = rx(e)
      , s = ix(e);
    if (r < 16 || r < s || r > 1024)
        throw new Error("expected " + s + "-1024 bytes of input, got " + r);
    const o = n ? nc(t) : _h(t)
      , a = qt(o, e - wn) + wn;
    return n ? H_(a, i) : zm(a, i)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ea = BigInt(0)
  , $s = BigInt(1);
function Ld(t, e) {
    const n = e.negate();
    return t ? n : e
}
function Ks(t, e) {
    const n = tx(t.Fp, e.map(r => r.Z));
    return e.map( (r, i) => t.fromAffine(r.toAffine(n[i])))
}
function sx(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + t)
}
function Gf(t, e) {
    sx(t, e);
    const n = Math.ceil(e / t) + 1
      , r = 2 ** (t - 1)
      , i = 2 ** t
      , s = vc(t)
      , o = BigInt(t);
    return {
        windows: n,
        windowSize: r,
        mask: s,
        maxNumber: i,
        shiftBy: o
    }
}
function i1(t, e, n) {
    const {windowSize: r, mask: i, maxNumber: s, shiftBy: o} = n;
    let a = Number(t & i)
      , l = t >> o;
    a > r && (a -= s,
    l += $s);
    const c = e * r
      , d = c + Math.abs(a) - 1
      , h = a === 0
      , y = a < 0
      , m = e % 2 !== 0;
    return {
        nextN: l,
        offset: d,
        isZero: h,
        isNeg: y,
        isNegF: m,
        offsetF: c
    }
}
function P4(t, e) {
    if (!Array.isArray(t))
        throw new Error("array expected");
    t.forEach( (n, r) => {
        if (!(n instanceof e))
            throw new Error("invalid point at index " + r)
    }
    )
}
function O4(t, e) {
    if (!Array.isArray(t))
        throw new Error("array of scalars expected");
    t.forEach( (n, r) => {
        if (!e.isValid(n))
            throw new Error("invalid scalar at index " + r)
    }
    )
}
const Yf = new WeakMap
  , ox = new WeakMap;
function Zf(t) {
    return ox.get(t) || 1
}
function s1(t) {
    if (t !== Ea)
        throw new Error("invalid wNAF")
}
class ax {
    constructor(e, n) {
        this.BASE = e.BASE,
        this.ZERO = e.ZERO,
        this.Fn = e.Fn,
        this.bits = n
    }
    _unsafeLadder(e, n, r=this.ZERO) {
        let i = e;
        for (; n > Ea; )
            n & $s && (r = r.add(i)),
            i = i.double(),
            n >>= $s;
        return r
    }
    precomputeWindow(e, n) {
        const {windows: r, windowSize: i} = Gf(n, this.bits)
          , s = [];
        let o = e
          , a = o;
        for (let l = 0; l < r; l++) {
            a = o,
            s.push(a);
            for (let c = 1; c < i; c++)
                a = a.add(o),
                s.push(a);
            o = a.double()
        }
        return s
    }
    wNAF(e, n, r) {
        if (!this.Fn.isValid(r))
            throw new Error("invalid scalar");
        let i = this.ZERO
          , s = this.BASE;
        const o = Gf(e, this.bits);
        for (let a = 0; a < o.windows; a++) {
            const {nextN: l, offset: c, isZero: d, isNeg: h, isNegF: y, offsetF: m} = i1(r, a, o);
            r = l,
            d ? s = s.add(Ld(y, n[m])) : i = i.add(Ld(h, n[c]))
        }
        return s1(r),
        {
            p: i,
            f: s
        }
    }
    wNAFUnsafe(e, n, r, i=this.ZERO) {
        const s = Gf(e, this.bits);
        for (let o = 0; o < s.windows && r !== Ea; o++) {
            const {nextN: a, offset: l, isZero: c, isNeg: d} = i1(r, o, s);
            if (r = a,
            !c) {
                const h = n[l];
                i = i.add(d ? h.negate() : h)
            }
        }
        return s1(r),
        i
    }
    getPrecomputes(e, n, r) {
        let i = Yf.get(n);
        return i || (i = this.precomputeWindow(n, e),
        e !== 1 && (typeof r == "function" && (i = r(i)),
        Yf.set(n, i))),
        i
    }
    cached(e, n, r) {
        const i = Zf(e);
        return this.wNAF(i, this.getPrecomputes(i, e, r), n)
    }
    unsafe(e, n, r, i) {
        const s = Zf(e);
        return s === 1 ? this._unsafeLadder(e, n, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, e, r), n, i)
    }
    createCache(e, n) {
        sx(n, this.bits),
        ox.set(e, n),
        Yf.delete(e)
    }
    hasCache(e) {
        return Zf(e) !== 1
    }
}
function D4(t, e, n, r) {
    let i = e
      , s = t.ZERO
      , o = t.ZERO;
    for (; n > Ea || r > Ea; )
        n & $s && (s = s.add(i)),
        r & $s && (o = o.add(i)),
        i = i.double(),
        n >>= $s,
        r >>= $s;
    return {
        p1: s,
        p2: o
    }
}
function lx(t, e, n, r) {
    P4(n, t),
    O4(r, e);
    const i = n.length
      , s = r.length;
    if (i !== s)
        throw new Error("arrays of points and scalars must have equal length");
    const o = t.ZERO
      , a = q_(BigInt(i));
    let l = 1;
    a > 12 ? l = a - 3 : a > 4 ? l = a - 2 : a > 0 && (l = 2);
    const c = vc(l)
      , d = new Array(Number(c) + 1).fill(o)
      , h = Math.floor((e.BITS - 1) / l) * l;
    let y = o;
    for (let m = h; m >= 0; m -= l) {
        d.fill(o);
        for (let E = 0; E < s; E++) {
            const A = r[E]
              , _ = Number(A >> BigInt(m) & c);
            d[_] = d[_].add(n[E])
        }
        let v = o;
        for (let E = d.length - 1, A = o; E > 0; E--)
            A = A.add(d[E]),
            v = v.add(A);
        if (y = y.add(v),
        m !== 0)
            for (let E = 0; E < l; E++)
                y = y.double()
    }
    return y
}
function o1(t, e, n) {
    if (e) {
        if (e.ORDER !== t)
            throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return L4(e),
        e
    } else
        return go(t, {
            isLE: n
        })
}
function cx(t, e, n={}, r) {
    if (r === void 0 && (r = t === "edwards"),
    !e || typeof e != "object")
        throw new Error(`expected valid ${t} CURVE object`);
    for (const l of ["p", "n", "h"]) {
        const c = e[l];
        if (!(typeof c == "bigint" && c > Ea))
            throw new Error(`CURVE.${l} must be positive bigint`)
    }
    const i = o1(e.p, n.Fp, r)
      , s = o1(e.n, n.Fn, r)
      , a = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
    for (const l of a)
        if (!i.isValid(e[l]))
            throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);
    return e = Object.freeze(Object.assign({}, e)),
    {
        CURVE: e,
        Fp: i,
        Fn: s
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Di = BigInt(0)
  , sn = BigInt(1)
  , Qf = BigInt(2)
  , z4 = BigInt(8);
function U4(t, e, n, r) {
    const i = t.sqr(n)
      , s = t.sqr(r)
      , o = t.add(t.mul(e.a, i), s)
      , a = t.add(t.ONE, t.mul(e.d, t.mul(i, s)));
    return t.eql(o, a)
}
function W4(t, e={}) {
    const n = cx("edwards", t, e, e.FpFnLE)
      , {Fp: r, Fn: i} = n;
    let s = n.CURVE;
    const {h: o} = s;
    bc(e, {}, {
        uvRatio: "function"
    });
    const a = Qf << BigInt(i.BYTES * 8) - sn
      , l = A => r.create(A)
      , c = e.uvRatio || ( (A, _) => {
        try {
            return {
                isValid: !0,
                value: r.sqrt(r.div(A, _))
            }
        } catch {
            return {
                isValid: !1,
                value: Di
            }
        }
    }
    );
    if (!U4(r, s, s.Gx, s.Gy))
        throw new Error("bad curve params: generator point");
    function d(A, _, x=!1) {
        const b = x ? sn : Di;
        return Ep("coordinate " + A, _, b, a),
        _
    }
    function h(A) {
        if (!(A instanceof v))
            throw new Error("ExtendedPoint expected")
    }
    const y = Rd( (A, _) => {
        const {X: x, Y: b, Z: R} = A
          , O = A.is0();
        _ == null && (_ = O ? z4 : r.inv(R));
        const D = l(x * _)
          , z = l(b * _)
          , K = r.mul(R, _);
        if (O)
            return {
                x: Di,
                y: sn
            };
        if (K !== sn)
            throw new Error("invZ was invalid");
        return {
            x: D,
            y: z
        }
    }
    )
      , m = Rd(A => {
        const {a: _, d: x} = s;
        if (A.is0())
            throw new Error("bad point: ZERO");
        const {X: b, Y: R, Z: O, T: D} = A
          , z = l(b * b)
          , K = l(R * R)
          , F = l(O * O)
          , G = l(F * F)
          , Z = l(z * _)
          , X = l(F * l(Z + K))
          , T = l(G + l(x * l(z * K)));
        if (X !== T)
            throw new Error("bad point: equation left != right (1)");
        const u = l(b * R)
          , p = l(O * D);
        if (u !== p)
            throw new Error("bad point: equation left != right (2)");
        return !0
    }
    );
    class v {
        constructor(_, x, b, R) {
            this.X = d("x", _),
            this.Y = d("y", x),
            this.Z = d("z", b, !0),
            this.T = d("t", R),
            Object.freeze(this)
        }
        static CURVE() {
            return s
        }
        static fromAffine(_) {
            if (_ instanceof v)
                throw new Error("extended point not allowed");
            const {x, y: b} = _ || {};
            return d("x", x),
            d("y", b),
            new v(x,b,sn,l(x * b))
        }
        static fromBytes(_, x=!1) {
            const b = r.BYTES
              , {a: R, d: O} = s;
            _ = t1(Rr(_, b, "point")),
            oo(x, "zip215");
            const D = t1(_)
              , z = _[b - 1];
            D[b - 1] = z & -129;
            const K = nc(D)
              , F = x ? a : r.ORDER;
            Ep("point.y", K, Di, F);
            const G = l(K * K)
              , Z = l(G - sn)
              , X = l(O * G - R);
            let {isValid: T, value: u} = c(Z, X);
            if (!T)
                throw new Error("bad point: invalid y coordinate");
            const p = (u & sn) === sn
              , k = (z & 128) !== 0;
            if (!x && u === Di && k)
                throw new Error("bad point: x=0 and x_0=1");
            return k !== p && (u = l(-u)),
            v.fromAffine({
                x: u,
                y: K
            })
        }
        static fromHex(_, x=!1) {
            return v.fromBytes(Et("point", _), x)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        precompute(_=8, x=!0) {
            return E.createCache(this, _),
            x || this.multiply(Qf),
            this
        }
        assertValidity() {
            m(this)
        }
        equals(_) {
            h(_);
            const {X: x, Y: b, Z: R} = this
              , {X: O, Y: D, Z: z} = _
              , K = l(x * z)
              , F = l(O * R)
              , G = l(b * z)
              , Z = l(D * R);
            return K === F && G === Z
        }
        is0() {
            return this.equals(v.ZERO)
        }
        negate() {
            return new v(l(-this.X),this.Y,this.Z,l(-this.T))
        }
        double() {
            const {a: _} = s
              , {X: x, Y: b, Z: R} = this
              , O = l(x * x)
              , D = l(b * b)
              , z = l(Qf * l(R * R))
              , K = l(_ * O)
              , F = x + b
              , G = l(l(F * F) - O - D)
              , Z = K + D
              , X = Z - z
              , T = K - D
              , u = l(G * X)
              , p = l(Z * T)
              , k = l(G * T)
              , C = l(X * Z);
            return new v(u,p,C,k)
        }
        add(_) {
            h(_);
            const {a: x, d: b} = s
              , {X: R, Y: O, Z: D, T: z} = this
              , {X: K, Y: F, Z: G, T: Z} = _
              , X = l(R * K)
              , T = l(O * F)
              , u = l(z * b * Z)
              , p = l(D * G)
              , k = l((R + O) * (K + F) - X - T)
              , C = p - u
              , I = p + u
              , L = l(T - x * X)
              , P = l(k * C)
              , N = l(I * L)
              , g = l(k * L)
              , B = l(C * I);
            return new v(P,N,B,g)
        }
        subtract(_) {
            return this.add(_.negate())
        }
        multiply(_) {
            if (!i.isValidNot0(_))
                throw new Error("invalid scalar: expected 1 <= sc < curve.n");
            const {p: x, f: b} = E.cached(this, _, R => Ks(v, R));
            return Ks(v, [x, b])[0]
        }
        multiplyUnsafe(_, x=v.ZERO) {
            if (!i.isValid(_))
                throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            return _ === Di ? v.ZERO : this.is0() || _ === sn ? this : E.unsafe(this, _, b => Ks(v, b), x)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0()
        }
        isTorsionFree() {
            return E.unsafe(this, s.n).is0()
        }
        toAffine(_) {
            return y(this, _)
        }
        clearCofactor() {
            return o === sn ? this : this.multiplyUnsafe(o)
        }
        toBytes() {
            const {x: _, y: x} = this.toAffine()
              , b = r.toBytes(x);
            return b[b.length - 1] |= _ & sn ? 128 : 0,
            b
        }
        toHex() {
            return eo(this.toBytes())
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`
        }
        get ex() {
            return this.X
        }
        get ey() {
            return this.Y
        }
        get ez() {
            return this.Z
        }
        get et() {
            return this.T
        }
        static normalizeZ(_) {
            return Ks(v, _)
        }
        static msm(_, x) {
            return lx(v, i, _, x)
        }
        _setWindowSize(_) {
            this.precompute(_)
        }
        toRawBytes() {
            return this.toBytes()
        }
    }
    v.BASE = new v(s.Gx,s.Gy,sn,l(s.Gx * s.Gy)),
    v.ZERO = new v(Di,sn,sn,Di),
    v.Fp = r,
    v.Fn = i;
    const E = new ax(v,i.BITS);
    return v.BASE.precompute(8),
    v
}
function F4(t, e, n={}) {
    if (typeof e != "function")
        throw new Error('"hash" function param is required');
    bc(n, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
    });
    const {prehash: r} = n
      , {BASE: i, Fp: s, Fn: o} = t
      , a = n.randomBytes || Om
      , l = n.adjustScalarBytes || (F => F)
      , c = n.domain || ( (F, G, Z) => {
        if (oo(Z, "phflag"),
        G.length || Z)
            throw new Error("Contexts/pre-hash are not supported");
        return F
    }
    );
    function d(F) {
        return o.create(nc(F))
    }
    function h(F) {
        const G = b.secretKey;
        F = Et("private key", F, G);
        const Z = Et("hashed private key", e(F), 2 * G)
          , X = l(Z.slice(0, G))
          , T = Z.slice(G, 2 * G)
          , u = d(X);
        return {
            head: X,
            prefix: T,
            scalar: u
        }
    }
    function y(F) {
        const {head: G, prefix: Z, scalar: X} = h(F)
          , T = i.multiply(X)
          , u = T.toBytes();
        return {
            head: G,
            prefix: Z,
            scalar: X,
            point: T,
            pointBytes: u
        }
    }
    function m(F) {
        return y(F).pointBytes
    }
    function v(F=Uint8Array.of(), ...G) {
        const Z = Hr(...G);
        return d(e(c(Z, Et("context", F), !!r)))
    }
    function E(F, G, Z={}) {
        F = Et("message", F),
        r && (F = r(F));
        const {prefix: X, scalar: T, pointBytes: u} = y(G)
          , p = v(Z.context, X, F)
          , k = i.multiply(p).toBytes()
          , C = v(Z.context, k, u, F)
          , I = o.create(p + C * T);
        if (!o.isValid(I))
            throw new Error("sign failed: invalid s");
        const L = Hr(k, o.toBytes(I));
        return Rr(L, b.signature, "result")
    }
    const A = {
        zip215: !0
    };
    function _(F, G, Z, X=A) {
        const {context: T, zip215: u} = X
          , p = b.signature;
        F = Et("signature", F, p),
        G = Et("message", G),
        Z = Et("publicKey", Z, b.publicKey),
        u !== void 0 && oo(u, "zip215"),
        r && (G = r(G));
        const k = p / 2
          , C = F.subarray(0, k)
          , I = nc(F.subarray(k, p));
        let L, P, N;
        try {
            L = t.fromBytes(Z, u),
            P = t.fromBytes(C, u),
            N = i.multiplyUnsafe(I)
        } catch {
            return !1
        }
        if (!u && L.isSmallOrder())
            return !1;
        const g = v(T, P.toBytes(), L.toBytes(), G);
        return P.add(L.multiplyUnsafe(g)).subtract(N).clearCofactor().is0()
    }
    const x = s.BYTES
      , b = {
        secretKey: x,
        publicKey: x,
        signature: 2 * x,
        seed: x
    };
    function R(F=a(b.seed)) {
        return Rr(F, b.seed, "seed")
    }
    function O(F) {
        const G = K.randomSecretKey(F);
        return {
            secretKey: G,
            publicKey: m(G)
        }
    }
    function D(F) {
        return wc(F) && F.length === o.BYTES
    }
    function z(F, G) {
        try {
            return !!t.fromBytes(F, G)
        } catch {
            return !1
        }
    }
    const K = {
        getExtendedPublicKey: y,
        randomSecretKey: R,
        isValidSecretKey: D,
        isValidPublicKey: z,
        toMontgomery(F) {
            const {y: G} = t.fromBytes(F)
              , Z = b.publicKey
              , X = Z === 32;
            if (!X && Z !== 57)
                throw new Error("only defined for 25519 and 448");
            const T = X ? s.div(sn + G, sn - G) : s.div(G - sn, G + sn);
            return s.toBytes(T)
        },
        toMontgomerySecret(F) {
            const G = b.secretKey;
            Rr(F, G);
            const Z = e(F.subarray(0, G));
            return l(Z).subarray(0, G)
        },
        randomPrivateKey: R,
        precompute(F=8, G=t.BASE) {
            return G.precompute(F, !1)
        }
    };
    return Object.freeze({
        keygen: O,
        getPublicKey: m,
        sign: E,
        verify: _,
        utils: K,
        Point: t,
        lengths: b
    })
}
function $4(t) {
    const e = {
        a: t.a,
        d: t.d,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy
    }
      , n = t.Fp
      , r = go(e.n, t.nBitLength, !0)
      , i = {
        Fp: n,
        Fn: r,
        uvRatio: t.uvRatio
    }
      , s = {
        randomBytes: t.randomBytes,
        adjustScalarBytes: t.adjustScalarBytes,
        domain: t.domain,
        prehash: t.prehash,
        mapToCurve: t.mapToCurve
    };
    return {
        CURVE: e,
        curveOpts: i,
        hash: t.hash,
        eddsaOpts: s
    }
}
function K4(t, e) {
    const n = e.Point;
    return Object.assign({}, e, {
        ExtendedPoint: n,
        CURVE: t,
        nBitLength: n.Fn.BITS,
        nByteLength: n.Fn.BYTES
    })
}
function V4(t) {
    const {CURVE: e, curveOpts: n, hash: r, eddsaOpts: i} = $4(t)
      , s = W4(e, n)
      , o = F4(s, r, i);
    return K4(t, o)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const H4 = BigInt(1)
  , a1 = BigInt(2);
BigInt(3);
const q4 = BigInt(5)
  , G4 = BigInt(8)
  , Wm = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed")
  , ux = ( () => ({
    p: Wm,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: G4,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function Y4(t) {
    const e = BigInt(10)
      , n = BigInt(20)
      , r = BigInt(40)
      , i = BigInt(80)
      , s = Wm
      , a = t * t % s * t % s
      , l = kt(a, a1, s) * a % s
      , c = kt(l, H4, s) * t % s
      , d = kt(c, q4, s) * c % s
      , h = kt(d, e, s) * d % s
      , y = kt(h, n, s) * h % s
      , m = kt(y, r, s) * y % s
      , v = kt(m, i, s) * m % s
      , E = kt(v, i, s) * m % s
      , A = kt(E, e, s) * d % s;
    return {
        pow_p_5_8: kt(A, a1, s) * t % s,
        b2: a
    }
}
function Z4(t) {
    return t[0] &= 248,
    t[31] &= 127,
    t[31] |= 64,
    t
}
const l1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function Q4(t, e) {
    const n = Wm
      , r = qt(e * e * e, n)
      , i = qt(r * r * e, n)
      , s = Y4(t * i).pow_p_5_8;
    let o = qt(t * r * s, n);
    const a = qt(e * o * o, n)
      , l = o
      , c = qt(o * l1, n)
      , d = a === t
      , h = a === qt(-t, n)
      , y = a === qt(-t * l1, n);
    return d && (o = l),
    (h || y) && (o = c),
    C4(o, n) && (o = qt(-o, n)),
    {
        isValid: d || h,
        value: o
    }
}
const J4 = ( () => go(ux.p, {
    isLE: !0
}))()
  , X4 = ( () => ({
    ...ux,
    Fp: J4,
    hash: S4,
    adjustScalarBytes: Z4,
    uvRatio: Q4
}))()
  , za = ( () => V4(X4))();
var Fm = {
    exports: {}
};
const eI = {}
  , tI = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: eI
}, Symbol.toStringTag, {
    value: "Module"
}))
  , nI = ms(tI);
Fm.exports;
(function(t) {
    (function(e, n) {
        function r(T, u) {
            if (!T)
                throw new Error(u || "Assertion failed")
        }
        function i(T, u) {
            T.super_ = u;
            var p = function() {};
            p.prototype = u.prototype,
            T.prototype = new p,
            T.prototype.constructor = T
        }
        function s(T, u, p) {
            if (s.isBN(T))
                return T;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            T !== null && ((u === "le" || u === "be") && (p = u,
            u = 10),
            this._init(T || 0, u || 10, p || "be"))
        }
        typeof e == "object" ? e.exports = s : n.BN = s,
        s.BN = s,
        s.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = nI.Buffer
        } catch {}
        s.isBN = function(u) {
            return u instanceof s ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === s.wordSize && Array.isArray(u.words)
        }
        ,
        s.max = function(u, p) {
            return u.cmp(p) > 0 ? u : p
        }
        ,
        s.min = function(u, p) {
            return u.cmp(p) < 0 ? u : p
        }
        ,
        s.prototype._init = function(u, p, k) {
            if (typeof u == "number")
                return this._initNumber(u, p, k);
            if (typeof u == "object")
                return this._initArray(u, p, k);
            p === "hex" && (p = 16),
            r(p === (p | 0) && p >= 2 && p <= 36),
            u = u.toString().replace(/\s+/g, "");
            var C = 0;
            u[0] === "-" && (C++,
            this.negative = 1),
            C < u.length && (p === 16 ? this._parseHex(u, C, k) : (this._parseBase(u, p, C),
            k === "le" && this._initArray(this.toArray(), p, k)))
        }
        ,
        s.prototype._initNumber = function(u, p, k) {
            u < 0 && (this.negative = 1,
            u = -u),
            u < 67108864 ? (this.words = [u & 67108863],
            this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863],
            this.length = 2) : (r(u < 9007199254740992),
            this.words = [u & 67108863, u / 67108864 & 67108863, 1],
            this.length = 3),
            k === "le" && this._initArray(this.toArray(), p, k)
        }
        ,
        s.prototype._initArray = function(u, p, k) {
            if (r(typeof u.length == "number"),
            u.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(u.length / 3),
            this.words = new Array(this.length);
            for (var C = 0; C < this.length; C++)
                this.words[C] = 0;
            var I, L, P = 0;
            if (k === "be")
                for (C = u.length - 1,
                I = 0; C >= 0; C -= 3)
                    L = u[C] | u[C - 1] << 8 | u[C - 2] << 16,
                    this.words[I] |= L << P & 67108863,
                    this.words[I + 1] = L >>> 26 - P & 67108863,
                    P += 24,
                    P >= 26 && (P -= 26,
                    I++);
            else if (k === "le")
                for (C = 0,
                I = 0; C < u.length; C += 3)
                    L = u[C] | u[C + 1] << 8 | u[C + 2] << 16,
                    this.words[I] |= L << P & 67108863,
                    this.words[I + 1] = L >>> 26 - P & 67108863,
                    P += 24,
                    P >= 26 && (P -= 26,
                    I++);
            return this._strip()
        }
        ;
        function a(T, u) {
            var p = T.charCodeAt(u);
            if (p >= 48 && p <= 57)
                return p - 48;
            if (p >= 65 && p <= 70)
                return p - 55;
            if (p >= 97 && p <= 102)
                return p - 87;
            r(!1, "Invalid character in " + T)
        }
        function l(T, u, p) {
            var k = a(T, p);
            return p - 1 >= u && (k |= a(T, p - 1) << 4),
            k
        }
        s.prototype._parseHex = function(u, p, k) {
            this.length = Math.ceil((u.length - p) / 6),
            this.words = new Array(this.length);
            for (var C = 0; C < this.length; C++)
                this.words[C] = 0;
            var I = 0, L = 0, P;
            if (k === "be")
                for (C = u.length - 1; C >= p; C -= 2)
                    P = l(u, p, C) << I,
                    this.words[L] |= P & 67108863,
                    I >= 18 ? (I -= 18,
                    L += 1,
                    this.words[L] |= P >>> 26) : I += 8;
            else {
                var N = u.length - p;
                for (C = N % 2 === 0 ? p + 1 : p; C < u.length; C += 2)
                    P = l(u, p, C) << I,
                    this.words[L] |= P & 67108863,
                    I >= 18 ? (I -= 18,
                    L += 1,
                    this.words[L] |= P >>> 26) : I += 8
            }
            this._strip()
        }
        ;
        function c(T, u, p, k) {
            for (var C = 0, I = 0, L = Math.min(T.length, p), P = u; P < L; P++) {
                var N = T.charCodeAt(P) - 48;
                C *= k,
                N >= 49 ? I = N - 49 + 10 : N >= 17 ? I = N - 17 + 10 : I = N,
                r(N >= 0 && I < k, "Invalid character"),
                C += I
            }
            return C
        }
        s.prototype._parseBase = function(u, p, k) {
            this.words = [0],
            this.length = 1;
            for (var C = 0, I = 1; I <= 67108863; I *= p)
                C++;
            C--,
            I = I / p | 0;
            for (var L = u.length - k, P = L % C, N = Math.min(L, L - P) + k, g = 0, B = k; B < N; B += C)
                g = c(u, B, B + C, p),
                this.imuln(I),
                this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
            if (P !== 0) {
                var ie = 1;
                for (g = c(u, B, u.length, p),
                B = 0; B < P; B++)
                    ie *= p;
                this.imuln(ie),
                this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g)
            }
            this._strip()
        }
        ,
        s.prototype.copy = function(u) {
            u.words = new Array(this.length);
            for (var p = 0; p < this.length; p++)
                u.words[p] = this.words[p];
            u.length = this.length,
            u.negative = this.negative,
            u.red = this.red
        }
        ;
        function d(T, u) {
            T.words = u.words,
            T.length = u.length,
            T.negative = u.negative,
            T.red = u.red
        }
        if (s.prototype._move = function(u) {
            d(u, this)
        }
        ,
        s.prototype.clone = function() {
            var u = new s(null);
            return this.copy(u),
            u
        }
        ,
        s.prototype._expand = function(u) {
            for (; this.length < u; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        s.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        s.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function")
            try {
                s.prototype[Symbol.for("nodejs.util.inspect.custom")] = h
            } catch {
                s.prototype.inspect = h
            }
        else
            s.prototype.inspect = h;
        function h() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var y = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , m = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , v = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(u, p) {
            u = u || 10,
            p = p | 0 || 1;
            var k;
            if (u === 16 || u === "hex") {
                k = "";
                for (var C = 0, I = 0, L = 0; L < this.length; L++) {
                    var P = this.words[L]
                      , N = ((P << C | I) & 16777215).toString(16);
                    I = P >>> 24 - C & 16777215,
                    C += 2,
                    C >= 26 && (C -= 26,
                    L--),
                    I !== 0 || L !== this.length - 1 ? k = y[6 - N.length] + N + k : k = N + k
                }
                for (I !== 0 && (k = I.toString(16) + k); k.length % p !== 0; )
                    k = "0" + k;
                return this.negative !== 0 && (k = "-" + k),
                k
            }
            if (u === (u | 0) && u >= 2 && u <= 36) {
                var g = m[u]
                  , B = v[u];
                k = "";
                var ie = this.clone();
                for (ie.negative = 0; !ie.isZero(); ) {
                    var te = ie.modrn(B).toString(u);
                    ie = ie.idivn(B),
                    ie.isZero() ? k = te + k : k = y[g - te.length] + te + k
                }
                for (this.isZero() && (k = "0" + k); k.length % p !== 0; )
                    k = "0" + k;
                return this.negative !== 0 && (k = "-" + k),
                k
            }
            r(!1, "Base should be between 2 and 36")
        }
        ,
        s.prototype.toNumber = function() {
            var u = this.words[0];
            return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -u : u
        }
        ,
        s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        o && (s.prototype.toBuffer = function(u, p) {
            return this.toArrayLike(o, u, p)
        }
        ),
        s.prototype.toArray = function(u, p) {
            return this.toArrayLike(Array, u, p)
        }
        ;
        var E = function(u, p) {
            return u.allocUnsafe ? u.allocUnsafe(p) : new u(p)
        };
        s.prototype.toArrayLike = function(u, p, k) {
            this._strip();
            var C = this.byteLength()
              , I = k || Math.max(1, C);
            r(C <= I, "byte array longer than desired length"),
            r(I > 0, "Requested array length <= 0");
            var L = E(u, I)
              , P = p === "le" ? "LE" : "BE";
            return this["_toArrayLike" + P](L, C),
            L
        }
        ,
        s.prototype._toArrayLikeLE = function(u, p) {
            for (var k = 0, C = 0, I = 0, L = 0; I < this.length; I++) {
                var P = this.words[I] << L | C;
                u[k++] = P & 255,
                k < u.length && (u[k++] = P >> 8 & 255),
                k < u.length && (u[k++] = P >> 16 & 255),
                L === 6 ? (k < u.length && (u[k++] = P >> 24 & 255),
                C = 0,
                L = 0) : (C = P >>> 24,
                L += 2)
            }
            if (k < u.length)
                for (u[k++] = C; k < u.length; )
                    u[k++] = 0
        }
        ,
        s.prototype._toArrayLikeBE = function(u, p) {
            for (var k = u.length - 1, C = 0, I = 0, L = 0; I < this.length; I++) {
                var P = this.words[I] << L | C;
                u[k--] = P & 255,
                k >= 0 && (u[k--] = P >> 8 & 255),
                k >= 0 && (u[k--] = P >> 16 & 255),
                L === 6 ? (k >= 0 && (u[k--] = P >> 24 & 255),
                C = 0,
                L = 0) : (C = P >>> 24,
                L += 2)
            }
            if (k >= 0)
                for (u[k--] = C; k >= 0; )
                    u[k--] = 0
        }
        ,
        Math.clz32 ? s.prototype._countBits = function(u) {
            return 32 - Math.clz32(u)
        }
        : s.prototype._countBits = function(u) {
            var p = u
              , k = 0;
            return p >= 4096 && (k += 13,
            p >>>= 13),
            p >= 64 && (k += 7,
            p >>>= 7),
            p >= 8 && (k += 4,
            p >>>= 4),
            p >= 2 && (k += 2,
            p >>>= 2),
            k + p
        }
        ,
        s.prototype._zeroBits = function(u) {
            if (u === 0)
                return 26;
            var p = u
              , k = 0;
            return p & 8191 || (k += 13,
            p >>>= 13),
            p & 127 || (k += 7,
            p >>>= 7),
            p & 15 || (k += 4,
            p >>>= 4),
            p & 3 || (k += 2,
            p >>>= 2),
            p & 1 || k++,
            k
        }
        ,
        s.prototype.bitLength = function() {
            var u = this.words[this.length - 1]
              , p = this._countBits(u);
            return (this.length - 1) * 26 + p
        }
        ;
        function A(T) {
            for (var u = new Array(T.bitLength()), p = 0; p < u.length; p++) {
                var k = p / 26 | 0
                  , C = p % 26;
                u[p] = T.words[k] >>> C & 1
            }
            return u
        }
        s.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var u = 0, p = 0; p < this.length; p++) {
                var k = this._zeroBits(this.words[p]);
                if (u += k,
                k !== 26)
                    break
            }
            return u
        }
        ,
        s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        s.prototype.toTwos = function(u) {
            return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone()
        }
        ,
        s.prototype.fromTwos = function(u) {
            return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone()
        }
        ,
        s.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        s.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        s.prototype.iuor = function(u) {
            for (; this.length < u.length; )
                this.words[this.length++] = 0;
            for (var p = 0; p < u.length; p++)
                this.words[p] = this.words[p] | u.words[p];
            return this._strip()
        }
        ,
        s.prototype.ior = function(u) {
            return r((this.negative | u.negative) === 0),
            this.iuor(u)
        }
        ,
        s.prototype.or = function(u) {
            return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this)
        }
        ,
        s.prototype.uor = function(u) {
            return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this)
        }
        ,
        s.prototype.iuand = function(u) {
            var p;
            this.length > u.length ? p = u : p = this;
            for (var k = 0; k < p.length; k++)
                this.words[k] = this.words[k] & u.words[k];
            return this.length = p.length,
            this._strip()
        }
        ,
        s.prototype.iand = function(u) {
            return r((this.negative | u.negative) === 0),
            this.iuand(u)
        }
        ,
        s.prototype.and = function(u) {
            return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this)
        }
        ,
        s.prototype.uand = function(u) {
            return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this)
        }
        ,
        s.prototype.iuxor = function(u) {
            var p, k;
            this.length > u.length ? (p = this,
            k = u) : (p = u,
            k = this);
            for (var C = 0; C < k.length; C++)
                this.words[C] = p.words[C] ^ k.words[C];
            if (this !== p)
                for (; C < p.length; C++)
                    this.words[C] = p.words[C];
            return this.length = p.length,
            this._strip()
        }
        ,
        s.prototype.ixor = function(u) {
            return r((this.negative | u.negative) === 0),
            this.iuxor(u)
        }
        ,
        s.prototype.xor = function(u) {
            return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this)
        }
        ,
        s.prototype.uxor = function(u) {
            return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this)
        }
        ,
        s.prototype.inotn = function(u) {
            r(typeof u == "number" && u >= 0);
            var p = Math.ceil(u / 26) | 0
              , k = u % 26;
            this._expand(p),
            k > 0 && p--;
            for (var C = 0; C < p; C++)
                this.words[C] = ~this.words[C] & 67108863;
            return k > 0 && (this.words[C] = ~this.words[C] & 67108863 >> 26 - k),
            this._strip()
        }
        ,
        s.prototype.notn = function(u) {
            return this.clone().inotn(u)
        }
        ,
        s.prototype.setn = function(u, p) {
            r(typeof u == "number" && u >= 0);
            var k = u / 26 | 0
              , C = u % 26;
            return this._expand(k + 1),
            p ? this.words[k] = this.words[k] | 1 << C : this.words[k] = this.words[k] & ~(1 << C),
            this._strip()
        }
        ,
        s.prototype.iadd = function(u) {
            var p;
            if (this.negative !== 0 && u.negative === 0)
                return this.negative = 0,
                p = this.isub(u),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && u.negative !== 0)
                return u.negative = 0,
                p = this.isub(u),
                u.negative = 1,
                p._normSign();
            var k, C;
            this.length > u.length ? (k = this,
            C = u) : (k = u,
            C = this);
            for (var I = 0, L = 0; L < C.length; L++)
                p = (k.words[L] | 0) + (C.words[L] | 0) + I,
                this.words[L] = p & 67108863,
                I = p >>> 26;
            for (; I !== 0 && L < k.length; L++)
                p = (k.words[L] | 0) + I,
                this.words[L] = p & 67108863,
                I = p >>> 26;
            if (this.length = k.length,
            I !== 0)
                this.words[this.length] = I,
                this.length++;
            else if (k !== this)
                for (; L < k.length; L++)
                    this.words[L] = k.words[L];
            return this
        }
        ,
        s.prototype.add = function(u) {
            var p;
            return u.negative !== 0 && this.negative === 0 ? (u.negative = 0,
            p = this.sub(u),
            u.negative ^= 1,
            p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            p = u.sub(this),
            this.negative = 1,
            p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this)
        }
        ,
        s.prototype.isub = function(u) {
            if (u.negative !== 0) {
                u.negative = 0;
                var p = this.iadd(u);
                return u.negative = 1,
                p._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(u),
                this.negative = 1,
                this._normSign();
            var k = this.cmp(u);
            if (k === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var C, I;
            k > 0 ? (C = this,
            I = u) : (C = u,
            I = this);
            for (var L = 0, P = 0; P < I.length; P++)
                p = (C.words[P] | 0) - (I.words[P] | 0) + L,
                L = p >> 26,
                this.words[P] = p & 67108863;
            for (; L !== 0 && P < C.length; P++)
                p = (C.words[P] | 0) + L,
                L = p >> 26,
                this.words[P] = p & 67108863;
            if (L === 0 && P < C.length && C !== this)
                for (; P < C.length; P++)
                    this.words[P] = C.words[P];
            return this.length = Math.max(this.length, P),
            C !== this && (this.negative = 1),
            this._strip()
        }
        ,
        s.prototype.sub = function(u) {
            return this.clone().isub(u)
        }
        ;
        function _(T, u, p) {
            p.negative = u.negative ^ T.negative;
            var k = T.length + u.length | 0;
            p.length = k,
            k = k - 1 | 0;
            var C = T.words[0] | 0
              , I = u.words[0] | 0
              , L = C * I
              , P = L & 67108863
              , N = L / 67108864 | 0;
            p.words[0] = P;
            for (var g = 1; g < k; g++) {
                for (var B = N >>> 26, ie = N & 67108863, te = Math.min(g, u.length - 1), oe = Math.max(0, g - T.length + 1); oe <= te; oe++) {
                    var xe = g - oe | 0;
                    C = T.words[xe] | 0,
                    I = u.words[oe] | 0,
                    L = C * I + ie,
                    B += L / 67108864 | 0,
                    ie = L & 67108863
                }
                p.words[g] = ie | 0,
                N = B | 0
            }
            return N !== 0 ? p.words[g] = N | 0 : p.length--,
            p._strip()
        }
        var x = function(u, p, k) {
            var C = u.words, I = p.words, L = k.words, P = 0, N, g, B, ie = C[0] | 0, te = ie & 8191, oe = ie >>> 13, xe = C[1] | 0, ve = xe & 8191, ye = xe >>> 13, vt = C[2] | 0, qe = vt & 8191, Ze = vt >>> 13, fr = C[3] | 0, Qe = fr & 8191, bt = fr >>> 13, Bc = C[4] | 0, lt = Bc & 8191, _t = Bc >>> 13, Pc = C[5] | 0, dt = Pc & 8191, nt = Pc >>> 13, Qn = C[6] | 0, ct = Qn & 8191, xt = Qn >>> 13, Sr = C[7] | 0, St = Sr & 8191, M = Sr >>> 13, f = C[8] | 0, w = f & 8191, j = f >>> 13, U = C[9] | 0, $ = U & 8191, q = U >>> 13, Ee = I[0] | 0, Se = Ee & 8191, be = Ee >>> 13, rt = I[1] | 0, we = rt & 8191, Tt = rt >>> 13, Ly = I[2] | 0, Nt = Ly & 8191, Ct = Ly >>> 13, jy = I[3] | 0, Rt = jy & 8191, Lt = jy >>> 13, By = I[4] | 0, jt = By & 8191, Bt = By >>> 13, Py = I[5] | 0, Pt = Py & 8191, Ot = Py >>> 13, Oy = I[6] | 0, Dt = Oy & 8191, zt = Oy >>> 13, Dy = I[7] | 0, Ut = Dy & 8191, Wt = Dy >>> 13, zy = I[8] | 0, Ft = zy & 8191, $t = zy >>> 13, Uy = I[9] | 0, Kt = Uy & 8191, Vt = Uy >>> 13;
            k.negative = u.negative ^ p.negative,
            k.length = 19,
            N = Math.imul(te, Se),
            g = Math.imul(te, be),
            g = g + Math.imul(oe, Se) | 0,
            B = Math.imul(oe, be);
            var Xh = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (Xh >>> 26) | 0,
            Xh &= 67108863,
            N = Math.imul(ve, Se),
            g = Math.imul(ve, be),
            g = g + Math.imul(ye, Se) | 0,
            B = Math.imul(ye, be),
            N = N + Math.imul(te, we) | 0,
            g = g + Math.imul(te, Tt) | 0,
            g = g + Math.imul(oe, we) | 0,
            B = B + Math.imul(oe, Tt) | 0;
            var ef = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (ef >>> 26) | 0,
            ef &= 67108863,
            N = Math.imul(qe, Se),
            g = Math.imul(qe, be),
            g = g + Math.imul(Ze, Se) | 0,
            B = Math.imul(Ze, be),
            N = N + Math.imul(ve, we) | 0,
            g = g + Math.imul(ve, Tt) | 0,
            g = g + Math.imul(ye, we) | 0,
            B = B + Math.imul(ye, Tt) | 0,
            N = N + Math.imul(te, Nt) | 0,
            g = g + Math.imul(te, Ct) | 0,
            g = g + Math.imul(oe, Nt) | 0,
            B = B + Math.imul(oe, Ct) | 0;
            var tf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (tf >>> 26) | 0,
            tf &= 67108863,
            N = Math.imul(Qe, Se),
            g = Math.imul(Qe, be),
            g = g + Math.imul(bt, Se) | 0,
            B = Math.imul(bt, be),
            N = N + Math.imul(qe, we) | 0,
            g = g + Math.imul(qe, Tt) | 0,
            g = g + Math.imul(Ze, we) | 0,
            B = B + Math.imul(Ze, Tt) | 0,
            N = N + Math.imul(ve, Nt) | 0,
            g = g + Math.imul(ve, Ct) | 0,
            g = g + Math.imul(ye, Nt) | 0,
            B = B + Math.imul(ye, Ct) | 0,
            N = N + Math.imul(te, Rt) | 0,
            g = g + Math.imul(te, Lt) | 0,
            g = g + Math.imul(oe, Rt) | 0,
            B = B + Math.imul(oe, Lt) | 0;
            var nf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (nf >>> 26) | 0,
            nf &= 67108863,
            N = Math.imul(lt, Se),
            g = Math.imul(lt, be),
            g = g + Math.imul(_t, Se) | 0,
            B = Math.imul(_t, be),
            N = N + Math.imul(Qe, we) | 0,
            g = g + Math.imul(Qe, Tt) | 0,
            g = g + Math.imul(bt, we) | 0,
            B = B + Math.imul(bt, Tt) | 0,
            N = N + Math.imul(qe, Nt) | 0,
            g = g + Math.imul(qe, Ct) | 0,
            g = g + Math.imul(Ze, Nt) | 0,
            B = B + Math.imul(Ze, Ct) | 0,
            N = N + Math.imul(ve, Rt) | 0,
            g = g + Math.imul(ve, Lt) | 0,
            g = g + Math.imul(ye, Rt) | 0,
            B = B + Math.imul(ye, Lt) | 0,
            N = N + Math.imul(te, jt) | 0,
            g = g + Math.imul(te, Bt) | 0,
            g = g + Math.imul(oe, jt) | 0,
            B = B + Math.imul(oe, Bt) | 0;
            var rf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (rf >>> 26) | 0,
            rf &= 67108863,
            N = Math.imul(dt, Se),
            g = Math.imul(dt, be),
            g = g + Math.imul(nt, Se) | 0,
            B = Math.imul(nt, be),
            N = N + Math.imul(lt, we) | 0,
            g = g + Math.imul(lt, Tt) | 0,
            g = g + Math.imul(_t, we) | 0,
            B = B + Math.imul(_t, Tt) | 0,
            N = N + Math.imul(Qe, Nt) | 0,
            g = g + Math.imul(Qe, Ct) | 0,
            g = g + Math.imul(bt, Nt) | 0,
            B = B + Math.imul(bt, Ct) | 0,
            N = N + Math.imul(qe, Rt) | 0,
            g = g + Math.imul(qe, Lt) | 0,
            g = g + Math.imul(Ze, Rt) | 0,
            B = B + Math.imul(Ze, Lt) | 0,
            N = N + Math.imul(ve, jt) | 0,
            g = g + Math.imul(ve, Bt) | 0,
            g = g + Math.imul(ye, jt) | 0,
            B = B + Math.imul(ye, Bt) | 0,
            N = N + Math.imul(te, Pt) | 0,
            g = g + Math.imul(te, Ot) | 0,
            g = g + Math.imul(oe, Pt) | 0,
            B = B + Math.imul(oe, Ot) | 0;
            var sf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (sf >>> 26) | 0,
            sf &= 67108863,
            N = Math.imul(ct, Se),
            g = Math.imul(ct, be),
            g = g + Math.imul(xt, Se) | 0,
            B = Math.imul(xt, be),
            N = N + Math.imul(dt, we) | 0,
            g = g + Math.imul(dt, Tt) | 0,
            g = g + Math.imul(nt, we) | 0,
            B = B + Math.imul(nt, Tt) | 0,
            N = N + Math.imul(lt, Nt) | 0,
            g = g + Math.imul(lt, Ct) | 0,
            g = g + Math.imul(_t, Nt) | 0,
            B = B + Math.imul(_t, Ct) | 0,
            N = N + Math.imul(Qe, Rt) | 0,
            g = g + Math.imul(Qe, Lt) | 0,
            g = g + Math.imul(bt, Rt) | 0,
            B = B + Math.imul(bt, Lt) | 0,
            N = N + Math.imul(qe, jt) | 0,
            g = g + Math.imul(qe, Bt) | 0,
            g = g + Math.imul(Ze, jt) | 0,
            B = B + Math.imul(Ze, Bt) | 0,
            N = N + Math.imul(ve, Pt) | 0,
            g = g + Math.imul(ve, Ot) | 0,
            g = g + Math.imul(ye, Pt) | 0,
            B = B + Math.imul(ye, Ot) | 0,
            N = N + Math.imul(te, Dt) | 0,
            g = g + Math.imul(te, zt) | 0,
            g = g + Math.imul(oe, Dt) | 0,
            B = B + Math.imul(oe, zt) | 0;
            var of = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (of >>> 26) | 0,
            of &= 67108863,
            N = Math.imul(St, Se),
            g = Math.imul(St, be),
            g = g + Math.imul(M, Se) | 0,
            B = Math.imul(M, be),
            N = N + Math.imul(ct, we) | 0,
            g = g + Math.imul(ct, Tt) | 0,
            g = g + Math.imul(xt, we) | 0,
            B = B + Math.imul(xt, Tt) | 0,
            N = N + Math.imul(dt, Nt) | 0,
            g = g + Math.imul(dt, Ct) | 0,
            g = g + Math.imul(nt, Nt) | 0,
            B = B + Math.imul(nt, Ct) | 0,
            N = N + Math.imul(lt, Rt) | 0,
            g = g + Math.imul(lt, Lt) | 0,
            g = g + Math.imul(_t, Rt) | 0,
            B = B + Math.imul(_t, Lt) | 0,
            N = N + Math.imul(Qe, jt) | 0,
            g = g + Math.imul(Qe, Bt) | 0,
            g = g + Math.imul(bt, jt) | 0,
            B = B + Math.imul(bt, Bt) | 0,
            N = N + Math.imul(qe, Pt) | 0,
            g = g + Math.imul(qe, Ot) | 0,
            g = g + Math.imul(Ze, Pt) | 0,
            B = B + Math.imul(Ze, Ot) | 0,
            N = N + Math.imul(ve, Dt) | 0,
            g = g + Math.imul(ve, zt) | 0,
            g = g + Math.imul(ye, Dt) | 0,
            B = B + Math.imul(ye, zt) | 0,
            N = N + Math.imul(te, Ut) | 0,
            g = g + Math.imul(te, Wt) | 0,
            g = g + Math.imul(oe, Ut) | 0,
            B = B + Math.imul(oe, Wt) | 0;
            var af = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (af >>> 26) | 0,
            af &= 67108863,
            N = Math.imul(w, Se),
            g = Math.imul(w, be),
            g = g + Math.imul(j, Se) | 0,
            B = Math.imul(j, be),
            N = N + Math.imul(St, we) | 0,
            g = g + Math.imul(St, Tt) | 0,
            g = g + Math.imul(M, we) | 0,
            B = B + Math.imul(M, Tt) | 0,
            N = N + Math.imul(ct, Nt) | 0,
            g = g + Math.imul(ct, Ct) | 0,
            g = g + Math.imul(xt, Nt) | 0,
            B = B + Math.imul(xt, Ct) | 0,
            N = N + Math.imul(dt, Rt) | 0,
            g = g + Math.imul(dt, Lt) | 0,
            g = g + Math.imul(nt, Rt) | 0,
            B = B + Math.imul(nt, Lt) | 0,
            N = N + Math.imul(lt, jt) | 0,
            g = g + Math.imul(lt, Bt) | 0,
            g = g + Math.imul(_t, jt) | 0,
            B = B + Math.imul(_t, Bt) | 0,
            N = N + Math.imul(Qe, Pt) | 0,
            g = g + Math.imul(Qe, Ot) | 0,
            g = g + Math.imul(bt, Pt) | 0,
            B = B + Math.imul(bt, Ot) | 0,
            N = N + Math.imul(qe, Dt) | 0,
            g = g + Math.imul(qe, zt) | 0,
            g = g + Math.imul(Ze, Dt) | 0,
            B = B + Math.imul(Ze, zt) | 0,
            N = N + Math.imul(ve, Ut) | 0,
            g = g + Math.imul(ve, Wt) | 0,
            g = g + Math.imul(ye, Ut) | 0,
            B = B + Math.imul(ye, Wt) | 0,
            N = N + Math.imul(te, Ft) | 0,
            g = g + Math.imul(te, $t) | 0,
            g = g + Math.imul(oe, Ft) | 0,
            B = B + Math.imul(oe, $t) | 0;
            var lf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (lf >>> 26) | 0,
            lf &= 67108863,
            N = Math.imul($, Se),
            g = Math.imul($, be),
            g = g + Math.imul(q, Se) | 0,
            B = Math.imul(q, be),
            N = N + Math.imul(w, we) | 0,
            g = g + Math.imul(w, Tt) | 0,
            g = g + Math.imul(j, we) | 0,
            B = B + Math.imul(j, Tt) | 0,
            N = N + Math.imul(St, Nt) | 0,
            g = g + Math.imul(St, Ct) | 0,
            g = g + Math.imul(M, Nt) | 0,
            B = B + Math.imul(M, Ct) | 0,
            N = N + Math.imul(ct, Rt) | 0,
            g = g + Math.imul(ct, Lt) | 0,
            g = g + Math.imul(xt, Rt) | 0,
            B = B + Math.imul(xt, Lt) | 0,
            N = N + Math.imul(dt, jt) | 0,
            g = g + Math.imul(dt, Bt) | 0,
            g = g + Math.imul(nt, jt) | 0,
            B = B + Math.imul(nt, Bt) | 0,
            N = N + Math.imul(lt, Pt) | 0,
            g = g + Math.imul(lt, Ot) | 0,
            g = g + Math.imul(_t, Pt) | 0,
            B = B + Math.imul(_t, Ot) | 0,
            N = N + Math.imul(Qe, Dt) | 0,
            g = g + Math.imul(Qe, zt) | 0,
            g = g + Math.imul(bt, Dt) | 0,
            B = B + Math.imul(bt, zt) | 0,
            N = N + Math.imul(qe, Ut) | 0,
            g = g + Math.imul(qe, Wt) | 0,
            g = g + Math.imul(Ze, Ut) | 0,
            B = B + Math.imul(Ze, Wt) | 0,
            N = N + Math.imul(ve, Ft) | 0,
            g = g + Math.imul(ve, $t) | 0,
            g = g + Math.imul(ye, Ft) | 0,
            B = B + Math.imul(ye, $t) | 0,
            N = N + Math.imul(te, Kt) | 0,
            g = g + Math.imul(te, Vt) | 0,
            g = g + Math.imul(oe, Kt) | 0,
            B = B + Math.imul(oe, Vt) | 0;
            var cf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (cf >>> 26) | 0,
            cf &= 67108863,
            N = Math.imul($, we),
            g = Math.imul($, Tt),
            g = g + Math.imul(q, we) | 0,
            B = Math.imul(q, Tt),
            N = N + Math.imul(w, Nt) | 0,
            g = g + Math.imul(w, Ct) | 0,
            g = g + Math.imul(j, Nt) | 0,
            B = B + Math.imul(j, Ct) | 0,
            N = N + Math.imul(St, Rt) | 0,
            g = g + Math.imul(St, Lt) | 0,
            g = g + Math.imul(M, Rt) | 0,
            B = B + Math.imul(M, Lt) | 0,
            N = N + Math.imul(ct, jt) | 0,
            g = g + Math.imul(ct, Bt) | 0,
            g = g + Math.imul(xt, jt) | 0,
            B = B + Math.imul(xt, Bt) | 0,
            N = N + Math.imul(dt, Pt) | 0,
            g = g + Math.imul(dt, Ot) | 0,
            g = g + Math.imul(nt, Pt) | 0,
            B = B + Math.imul(nt, Ot) | 0,
            N = N + Math.imul(lt, Dt) | 0,
            g = g + Math.imul(lt, zt) | 0,
            g = g + Math.imul(_t, Dt) | 0,
            B = B + Math.imul(_t, zt) | 0,
            N = N + Math.imul(Qe, Ut) | 0,
            g = g + Math.imul(Qe, Wt) | 0,
            g = g + Math.imul(bt, Ut) | 0,
            B = B + Math.imul(bt, Wt) | 0,
            N = N + Math.imul(qe, Ft) | 0,
            g = g + Math.imul(qe, $t) | 0,
            g = g + Math.imul(Ze, Ft) | 0,
            B = B + Math.imul(Ze, $t) | 0,
            N = N + Math.imul(ve, Kt) | 0,
            g = g + Math.imul(ve, Vt) | 0,
            g = g + Math.imul(ye, Kt) | 0,
            B = B + Math.imul(ye, Vt) | 0;
            var uf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (uf >>> 26) | 0,
            uf &= 67108863,
            N = Math.imul($, Nt),
            g = Math.imul($, Ct),
            g = g + Math.imul(q, Nt) | 0,
            B = Math.imul(q, Ct),
            N = N + Math.imul(w, Rt) | 0,
            g = g + Math.imul(w, Lt) | 0,
            g = g + Math.imul(j, Rt) | 0,
            B = B + Math.imul(j, Lt) | 0,
            N = N + Math.imul(St, jt) | 0,
            g = g + Math.imul(St, Bt) | 0,
            g = g + Math.imul(M, jt) | 0,
            B = B + Math.imul(M, Bt) | 0,
            N = N + Math.imul(ct, Pt) | 0,
            g = g + Math.imul(ct, Ot) | 0,
            g = g + Math.imul(xt, Pt) | 0,
            B = B + Math.imul(xt, Ot) | 0,
            N = N + Math.imul(dt, Dt) | 0,
            g = g + Math.imul(dt, zt) | 0,
            g = g + Math.imul(nt, Dt) | 0,
            B = B + Math.imul(nt, zt) | 0,
            N = N + Math.imul(lt, Ut) | 0,
            g = g + Math.imul(lt, Wt) | 0,
            g = g + Math.imul(_t, Ut) | 0,
            B = B + Math.imul(_t, Wt) | 0,
            N = N + Math.imul(Qe, Ft) | 0,
            g = g + Math.imul(Qe, $t) | 0,
            g = g + Math.imul(bt, Ft) | 0,
            B = B + Math.imul(bt, $t) | 0,
            N = N + Math.imul(qe, Kt) | 0,
            g = g + Math.imul(qe, Vt) | 0,
            g = g + Math.imul(Ze, Kt) | 0,
            B = B + Math.imul(Ze, Vt) | 0;
            var df = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (df >>> 26) | 0,
            df &= 67108863,
            N = Math.imul($, Rt),
            g = Math.imul($, Lt),
            g = g + Math.imul(q, Rt) | 0,
            B = Math.imul(q, Lt),
            N = N + Math.imul(w, jt) | 0,
            g = g + Math.imul(w, Bt) | 0,
            g = g + Math.imul(j, jt) | 0,
            B = B + Math.imul(j, Bt) | 0,
            N = N + Math.imul(St, Pt) | 0,
            g = g + Math.imul(St, Ot) | 0,
            g = g + Math.imul(M, Pt) | 0,
            B = B + Math.imul(M, Ot) | 0,
            N = N + Math.imul(ct, Dt) | 0,
            g = g + Math.imul(ct, zt) | 0,
            g = g + Math.imul(xt, Dt) | 0,
            B = B + Math.imul(xt, zt) | 0,
            N = N + Math.imul(dt, Ut) | 0,
            g = g + Math.imul(dt, Wt) | 0,
            g = g + Math.imul(nt, Ut) | 0,
            B = B + Math.imul(nt, Wt) | 0,
            N = N + Math.imul(lt, Ft) | 0,
            g = g + Math.imul(lt, $t) | 0,
            g = g + Math.imul(_t, Ft) | 0,
            B = B + Math.imul(_t, $t) | 0,
            N = N + Math.imul(Qe, Kt) | 0,
            g = g + Math.imul(Qe, Vt) | 0,
            g = g + Math.imul(bt, Kt) | 0,
            B = B + Math.imul(bt, Vt) | 0;
            var hf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (hf >>> 26) | 0,
            hf &= 67108863,
            N = Math.imul($, jt),
            g = Math.imul($, Bt),
            g = g + Math.imul(q, jt) | 0,
            B = Math.imul(q, Bt),
            N = N + Math.imul(w, Pt) | 0,
            g = g + Math.imul(w, Ot) | 0,
            g = g + Math.imul(j, Pt) | 0,
            B = B + Math.imul(j, Ot) | 0,
            N = N + Math.imul(St, Dt) | 0,
            g = g + Math.imul(St, zt) | 0,
            g = g + Math.imul(M, Dt) | 0,
            B = B + Math.imul(M, zt) | 0,
            N = N + Math.imul(ct, Ut) | 0,
            g = g + Math.imul(ct, Wt) | 0,
            g = g + Math.imul(xt, Ut) | 0,
            B = B + Math.imul(xt, Wt) | 0,
            N = N + Math.imul(dt, Ft) | 0,
            g = g + Math.imul(dt, $t) | 0,
            g = g + Math.imul(nt, Ft) | 0,
            B = B + Math.imul(nt, $t) | 0,
            N = N + Math.imul(lt, Kt) | 0,
            g = g + Math.imul(lt, Vt) | 0,
            g = g + Math.imul(_t, Kt) | 0,
            B = B + Math.imul(_t, Vt) | 0;
            var ff = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (ff >>> 26) | 0,
            ff &= 67108863,
            N = Math.imul($, Pt),
            g = Math.imul($, Ot),
            g = g + Math.imul(q, Pt) | 0,
            B = Math.imul(q, Ot),
            N = N + Math.imul(w, Dt) | 0,
            g = g + Math.imul(w, zt) | 0,
            g = g + Math.imul(j, Dt) | 0,
            B = B + Math.imul(j, zt) | 0,
            N = N + Math.imul(St, Ut) | 0,
            g = g + Math.imul(St, Wt) | 0,
            g = g + Math.imul(M, Ut) | 0,
            B = B + Math.imul(M, Wt) | 0,
            N = N + Math.imul(ct, Ft) | 0,
            g = g + Math.imul(ct, $t) | 0,
            g = g + Math.imul(xt, Ft) | 0,
            B = B + Math.imul(xt, $t) | 0,
            N = N + Math.imul(dt, Kt) | 0,
            g = g + Math.imul(dt, Vt) | 0,
            g = g + Math.imul(nt, Kt) | 0,
            B = B + Math.imul(nt, Vt) | 0;
            var pf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (pf >>> 26) | 0,
            pf &= 67108863,
            N = Math.imul($, Dt),
            g = Math.imul($, zt),
            g = g + Math.imul(q, Dt) | 0,
            B = Math.imul(q, zt),
            N = N + Math.imul(w, Ut) | 0,
            g = g + Math.imul(w, Wt) | 0,
            g = g + Math.imul(j, Ut) | 0,
            B = B + Math.imul(j, Wt) | 0,
            N = N + Math.imul(St, Ft) | 0,
            g = g + Math.imul(St, $t) | 0,
            g = g + Math.imul(M, Ft) | 0,
            B = B + Math.imul(M, $t) | 0,
            N = N + Math.imul(ct, Kt) | 0,
            g = g + Math.imul(ct, Vt) | 0,
            g = g + Math.imul(xt, Kt) | 0,
            B = B + Math.imul(xt, Vt) | 0;
            var gf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (gf >>> 26) | 0,
            gf &= 67108863,
            N = Math.imul($, Ut),
            g = Math.imul($, Wt),
            g = g + Math.imul(q, Ut) | 0,
            B = Math.imul(q, Wt),
            N = N + Math.imul(w, Ft) | 0,
            g = g + Math.imul(w, $t) | 0,
            g = g + Math.imul(j, Ft) | 0,
            B = B + Math.imul(j, $t) | 0,
            N = N + Math.imul(St, Kt) | 0,
            g = g + Math.imul(St, Vt) | 0,
            g = g + Math.imul(M, Kt) | 0,
            B = B + Math.imul(M, Vt) | 0;
            var mf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (mf >>> 26) | 0,
            mf &= 67108863,
            N = Math.imul($, Ft),
            g = Math.imul($, $t),
            g = g + Math.imul(q, Ft) | 0,
            B = Math.imul(q, $t),
            N = N + Math.imul(w, Kt) | 0,
            g = g + Math.imul(w, Vt) | 0,
            g = g + Math.imul(j, Kt) | 0,
            B = B + Math.imul(j, Vt) | 0;
            var yf = (P + N | 0) + ((g & 8191) << 13) | 0;
            P = (B + (g >>> 13) | 0) + (yf >>> 26) | 0,
            yf &= 67108863,
            N = Math.imul($, Kt),
            g = Math.imul($, Vt),
            g = g + Math.imul(q, Kt) | 0,
            B = Math.imul(q, Vt);
            var wf = (P + N | 0) + ((g & 8191) << 13) | 0;
            return P = (B + (g >>> 13) | 0) + (wf >>> 26) | 0,
            wf &= 67108863,
            L[0] = Xh,
            L[1] = ef,
            L[2] = tf,
            L[3] = nf,
            L[4] = rf,
            L[5] = sf,
            L[6] = of,
            L[7] = af,
            L[8] = lf,
            L[9] = cf,
            L[10] = uf,
            L[11] = df,
            L[12] = hf,
            L[13] = ff,
            L[14] = pf,
            L[15] = gf,
            L[16] = mf,
            L[17] = yf,
            L[18] = wf,
            P !== 0 && (L[19] = P,
            k.length++),
            k
        };
        Math.imul || (x = _);
        function b(T, u, p) {
            p.negative = u.negative ^ T.negative,
            p.length = T.length + u.length;
            for (var k = 0, C = 0, I = 0; I < p.length - 1; I++) {
                var L = C;
                C = 0;
                for (var P = k & 67108863, N = Math.min(I, u.length - 1), g = Math.max(0, I - T.length + 1); g <= N; g++) {
                    var B = I - g
                      , ie = T.words[B] | 0
                      , te = u.words[g] | 0
                      , oe = ie * te
                      , xe = oe & 67108863;
                    L = L + (oe / 67108864 | 0) | 0,
                    xe = xe + P | 0,
                    P = xe & 67108863,
                    L = L + (xe >>> 26) | 0,
                    C += L >>> 26,
                    L &= 67108863
                }
                p.words[I] = P,
                k = L,
                L = C
            }
            return k !== 0 ? p.words[I] = k : p.length--,
            p._strip()
        }
        function R(T, u, p) {
            return b(T, u, p)
        }
        s.prototype.mulTo = function(u, p) {
            var k, C = this.length + u.length;
            return this.length === 10 && u.length === 10 ? k = x(this, u, p) : C < 63 ? k = _(this, u, p) : C < 1024 ? k = b(this, u, p) : k = R(this, u, p),
            k
        }
        ,
        s.prototype.mul = function(u) {
            var p = new s(null);
            return p.words = new Array(this.length + u.length),
            this.mulTo(u, p)
        }
        ,
        s.prototype.mulf = function(u) {
            var p = new s(null);
            return p.words = new Array(this.length + u.length),
            R(this, u, p)
        }
        ,
        s.prototype.imul = function(u) {
            return this.clone().mulTo(u, this)
        }
        ,
        s.prototype.imuln = function(u) {
            var p = u < 0;
            p && (u = -u),
            r(typeof u == "number"),
            r(u < 67108864);
            for (var k = 0, C = 0; C < this.length; C++) {
                var I = (this.words[C] | 0) * u
                  , L = (I & 67108863) + (k & 67108863);
                k >>= 26,
                k += I / 67108864 | 0,
                k += L >>> 26,
                this.words[C] = L & 67108863
            }
            return k !== 0 && (this.words[C] = k,
            this.length++),
            this.length = u === 0 ? 1 : this.length,
            p ? this.ineg() : this
        }
        ,
        s.prototype.muln = function(u) {
            return this.clone().imuln(u)
        }
        ,
        s.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        s.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        s.prototype.pow = function(u) {
            var p = A(u);
            if (p.length === 0)
                return new s(1);
            for (var k = this, C = 0; C < p.length && p[C] === 0; C++,
            k = k.sqr())
                ;
            if (++C < p.length)
                for (var I = k.sqr(); C < p.length; C++,
                I = I.sqr())
                    p[C] !== 0 && (k = k.mul(I));
            return k
        }
        ,
        s.prototype.iushln = function(u) {
            r(typeof u == "number" && u >= 0);
            var p = u % 26, k = (u - p) / 26, C = 67108863 >>> 26 - p << 26 - p, I;
            if (p !== 0) {
                var L = 0;
                for (I = 0; I < this.length; I++) {
                    var P = this.words[I] & C
                      , N = (this.words[I] | 0) - P << p;
                    this.words[I] = N | L,
                    L = P >>> 26 - p
                }
                L && (this.words[I] = L,
                this.length++)
            }
            if (k !== 0) {
                for (I = this.length - 1; I >= 0; I--)
                    this.words[I + k] = this.words[I];
                for (I = 0; I < k; I++)
                    this.words[I] = 0;
                this.length += k
            }
            return this._strip()
        }
        ,
        s.prototype.ishln = function(u) {
            return r(this.negative === 0),
            this.iushln(u)
        }
        ,
        s.prototype.iushrn = function(u, p, k) {
            r(typeof u == "number" && u >= 0);
            var C;
            p ? C = (p - p % 26) / 26 : C = 0;
            var I = u % 26
              , L = Math.min((u - I) / 26, this.length)
              , P = 67108863 ^ 67108863 >>> I << I
              , N = k;
            if (C -= L,
            C = Math.max(0, C),
            N) {
                for (var g = 0; g < L; g++)
                    N.words[g] = this.words[g];
                N.length = L
            }
            if (L !== 0)
                if (this.length > L)
                    for (this.length -= L,
                    g = 0; g < this.length; g++)
                        this.words[g] = this.words[g + L];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var B = 0;
            for (g = this.length - 1; g >= 0 && (B !== 0 || g >= C); g--) {
                var ie = this.words[g] | 0;
                this.words[g] = B << 26 - I | ie >>> I,
                B = ie & P
            }
            return N && B !== 0 && (N.words[N.length++] = B),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        s.prototype.ishrn = function(u, p, k) {
            return r(this.negative === 0),
            this.iushrn(u, p, k)
        }
        ,
        s.prototype.shln = function(u) {
            return this.clone().ishln(u)
        }
        ,
        s.prototype.ushln = function(u) {
            return this.clone().iushln(u)
        }
        ,
        s.prototype.shrn = function(u) {
            return this.clone().ishrn(u)
        }
        ,
        s.prototype.ushrn = function(u) {
            return this.clone().iushrn(u)
        }
        ,
        s.prototype.testn = function(u) {
            r(typeof u == "number" && u >= 0);
            var p = u % 26
              , k = (u - p) / 26
              , C = 1 << p;
            if (this.length <= k)
                return !1;
            var I = this.words[k];
            return !!(I & C)
        }
        ,
        s.prototype.imaskn = function(u) {
            r(typeof u == "number" && u >= 0);
            var p = u % 26
              , k = (u - p) / 26;
            if (r(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= k)
                return this;
            if (p !== 0 && k++,
            this.length = Math.min(k, this.length),
            p !== 0) {
                var C = 67108863 ^ 67108863 >>> p << p;
                this.words[this.length - 1] &= C
            }
            return this._strip()
        }
        ,
        s.prototype.maskn = function(u) {
            return this.clone().imaskn(u)
        }
        ,
        s.prototype.iaddn = function(u) {
            return r(typeof u == "number"),
            r(u < 67108864),
            u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(u),
            this.negative = 1,
            this) : this._iaddn(u)
        }
        ,
        s.prototype._iaddn = function(u) {
            this.words[0] += u;
            for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
                this.words[p] -= 67108864,
                p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
            return this.length = Math.max(this.length, p + 1),
            this
        }
        ,
        s.prototype.isubn = function(u) {
            if (r(typeof u == "number"),
            r(u < 67108864),
            u < 0)
                return this.iaddn(-u);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(u),
                this.negative = 1,
                this;
            if (this.words[0] -= u,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var p = 0; p < this.length && this.words[p] < 0; p++)
                    this.words[p] += 67108864,
                    this.words[p + 1] -= 1;
            return this._strip()
        }
        ,
        s.prototype.addn = function(u) {
            return this.clone().iaddn(u)
        }
        ,
        s.prototype.subn = function(u) {
            return this.clone().isubn(u)
        }
        ,
        s.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        s.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        s.prototype._ishlnsubmul = function(u, p, k) {
            var C = u.length + k, I;
            this._expand(C);
            var L, P = 0;
            for (I = 0; I < u.length; I++) {
                L = (this.words[I + k] | 0) + P;
                var N = (u.words[I] | 0) * p;
                L -= N & 67108863,
                P = (L >> 26) - (N / 67108864 | 0),
                this.words[I + k] = L & 67108863
            }
            for (; I < this.length - k; I++)
                L = (this.words[I + k] | 0) + P,
                P = L >> 26,
                this.words[I + k] = L & 67108863;
            if (P === 0)
                return this._strip();
            for (r(P === -1),
            P = 0,
            I = 0; I < this.length; I++)
                L = -(this.words[I] | 0) + P,
                P = L >> 26,
                this.words[I] = L & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        s.prototype._wordDiv = function(u, p) {
            var k = this.length - u.length
              , C = this.clone()
              , I = u
              , L = I.words[I.length - 1] | 0
              , P = this._countBits(L);
            k = 26 - P,
            k !== 0 && (I = I.ushln(k),
            C.iushln(k),
            L = I.words[I.length - 1] | 0);
            var N = C.length - I.length, g;
            if (p !== "mod") {
                g = new s(null),
                g.length = N + 1,
                g.words = new Array(g.length);
                for (var B = 0; B < g.length; B++)
                    g.words[B] = 0
            }
            var ie = C.clone()._ishlnsubmul(I, 1, N);
            ie.negative === 0 && (C = ie,
            g && (g.words[N] = 1));
            for (var te = N - 1; te >= 0; te--) {
                var oe = (C.words[I.length + te] | 0) * 67108864 + (C.words[I.length + te - 1] | 0);
                for (oe = Math.min(oe / L | 0, 67108863),
                C._ishlnsubmul(I, oe, te); C.negative !== 0; )
                    oe--,
                    C.negative = 0,
                    C._ishlnsubmul(I, 1, te),
                    C.isZero() || (C.negative ^= 1);
                g && (g.words[te] = oe)
            }
            return g && g._strip(),
            C._strip(),
            p !== "div" && k !== 0 && C.iushrn(k),
            {
                div: g || null,
                mod: C
            }
        }
        ,
        s.prototype.divmod = function(u, p, k) {
            if (r(!u.isZero()),
            this.isZero())
                return {
                    div: new s(0),
                    mod: new s(0)
                };
            var C, I, L;
            return this.negative !== 0 && u.negative === 0 ? (L = this.neg().divmod(u, p),
            p !== "mod" && (C = L.div.neg()),
            p !== "div" && (I = L.mod.neg(),
            k && I.negative !== 0 && I.iadd(u)),
            {
                div: C,
                mod: I
            }) : this.negative === 0 && u.negative !== 0 ? (L = this.divmod(u.neg(), p),
            p !== "mod" && (C = L.div.neg()),
            {
                div: C,
                mod: L.mod
            }) : this.negative & u.negative ? (L = this.neg().divmod(u.neg(), p),
            p !== "div" && (I = L.mod.neg(),
            k && I.negative !== 0 && I.isub(u)),
            {
                div: L.div,
                mod: I
            }) : u.length > this.length || this.cmp(u) < 0 ? {
                div: new s(0),
                mod: this
            } : u.length === 1 ? p === "div" ? {
                div: this.divn(u.words[0]),
                mod: null
            } : p === "mod" ? {
                div: null,
                mod: new s(this.modrn(u.words[0]))
            } : {
                div: this.divn(u.words[0]),
                mod: new s(this.modrn(u.words[0]))
            } : this._wordDiv(u, p)
        }
        ,
        s.prototype.div = function(u) {
            return this.divmod(u, "div", !1).div
        }
        ,
        s.prototype.mod = function(u) {
            return this.divmod(u, "mod", !1).mod
        }
        ,
        s.prototype.umod = function(u) {
            return this.divmod(u, "mod", !0).mod
        }
        ,
        s.prototype.divRound = function(u) {
            var p = this.divmod(u);
            if (p.mod.isZero())
                return p.div;
            var k = p.div.negative !== 0 ? p.mod.isub(u) : p.mod
              , C = u.ushrn(1)
              , I = u.andln(1)
              , L = k.cmp(C);
            return L < 0 || I === 1 && L === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1)
        }
        ,
        s.prototype.modrn = function(u) {
            var p = u < 0;
            p && (u = -u),
            r(u <= 67108863);
            for (var k = (1 << 26) % u, C = 0, I = this.length - 1; I >= 0; I--)
                C = (k * C + (this.words[I] | 0)) % u;
            return p ? -C : C
        }
        ,
        s.prototype.modn = function(u) {
            return this.modrn(u)
        }
        ,
        s.prototype.idivn = function(u) {
            var p = u < 0;
            p && (u = -u),
            r(u <= 67108863);
            for (var k = 0, C = this.length - 1; C >= 0; C--) {
                var I = (this.words[C] | 0) + k * 67108864;
                this.words[C] = I / u | 0,
                k = I % u
            }
            return this._strip(),
            p ? this.ineg() : this
        }
        ,
        s.prototype.divn = function(u) {
            return this.clone().idivn(u)
        }
        ,
        s.prototype.egcd = function(u) {
            r(u.negative === 0),
            r(!u.isZero());
            var p = this
              , k = u.clone();
            p.negative !== 0 ? p = p.umod(u) : p = p.clone();
            for (var C = new s(1), I = new s(0), L = new s(0), P = new s(1), N = 0; p.isEven() && k.isEven(); )
                p.iushrn(1),
                k.iushrn(1),
                ++N;
            for (var g = k.clone(), B = p.clone(); !p.isZero(); ) {
                for (var ie = 0, te = 1; !(p.words[0] & te) && ie < 26; ++ie,
                te <<= 1)
                    ;
                if (ie > 0)
                    for (p.iushrn(ie); ie-- > 0; )
                        (C.isOdd() || I.isOdd()) && (C.iadd(g),
                        I.isub(B)),
                        C.iushrn(1),
                        I.iushrn(1);
                for (var oe = 0, xe = 1; !(k.words[0] & xe) && oe < 26; ++oe,
                xe <<= 1)
                    ;
                if (oe > 0)
                    for (k.iushrn(oe); oe-- > 0; )
                        (L.isOdd() || P.isOdd()) && (L.iadd(g),
                        P.isub(B)),
                        L.iushrn(1),
                        P.iushrn(1);
                p.cmp(k) >= 0 ? (p.isub(k),
                C.isub(L),
                I.isub(P)) : (k.isub(p),
                L.isub(C),
                P.isub(I))
            }
            return {
                a: L,
                b: P,
                gcd: k.iushln(N)
            }
        }
        ,
        s.prototype._invmp = function(u) {
            r(u.negative === 0),
            r(!u.isZero());
            var p = this
              , k = u.clone();
            p.negative !== 0 ? p = p.umod(u) : p = p.clone();
            for (var C = new s(1), I = new s(0), L = k.clone(); p.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
                for (var P = 0, N = 1; !(p.words[0] & N) && P < 26; ++P,
                N <<= 1)
                    ;
                if (P > 0)
                    for (p.iushrn(P); P-- > 0; )
                        C.isOdd() && C.iadd(L),
                        C.iushrn(1);
                for (var g = 0, B = 1; !(k.words[0] & B) && g < 26; ++g,
                B <<= 1)
                    ;
                if (g > 0)
                    for (k.iushrn(g); g-- > 0; )
                        I.isOdd() && I.iadd(L),
                        I.iushrn(1);
                p.cmp(k) >= 0 ? (p.isub(k),
                C.isub(I)) : (k.isub(p),
                I.isub(C))
            }
            var ie;
            return p.cmpn(1) === 0 ? ie = C : ie = I,
            ie.cmpn(0) < 0 && ie.iadd(u),
            ie
        }
        ,
        s.prototype.gcd = function(u) {
            if (this.isZero())
                return u.abs();
            if (u.isZero())
                return this.abs();
            var p = this.clone()
              , k = u.clone();
            p.negative = 0,
            k.negative = 0;
            for (var C = 0; p.isEven() && k.isEven(); C++)
                p.iushrn(1),
                k.iushrn(1);
            do {
                for (; p.isEven(); )
                    p.iushrn(1);
                for (; k.isEven(); )
                    k.iushrn(1);
                var I = p.cmp(k);
                if (I < 0) {
                    var L = p;
                    p = k,
                    k = L
                } else if (I === 0 || k.cmpn(1) === 0)
                    break;
                p.isub(k)
            } while (!0);
            return k.iushln(C)
        }
        ,
        s.prototype.invm = function(u) {
            return this.egcd(u).a.umod(u)
        }
        ,
        s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        s.prototype.andln = function(u) {
            return this.words[0] & u
        }
        ,
        s.prototype.bincn = function(u) {
            r(typeof u == "number");
            var p = u % 26
              , k = (u - p) / 26
              , C = 1 << p;
            if (this.length <= k)
                return this._expand(k + 1),
                this.words[k] |= C,
                this;
            for (var I = C, L = k; I !== 0 && L < this.length; L++) {
                var P = this.words[L] | 0;
                P += I,
                I = P >>> 26,
                P &= 67108863,
                this.words[L] = P
            }
            return I !== 0 && (this.words[L] = I,
            this.length++),
            this
        }
        ,
        s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        s.prototype.cmpn = function(u) {
            var p = u < 0;
            if (this.negative !== 0 && !p)
                return -1;
            if (this.negative === 0 && p)
                return 1;
            this._strip();
            var k;
            if (this.length > 1)
                k = 1;
            else {
                p && (u = -u),
                r(u <= 67108863, "Number is too big");
                var C = this.words[0] | 0;
                k = C === u ? 0 : C < u ? -1 : 1
            }
            return this.negative !== 0 ? -k | 0 : k
        }
        ,
        s.prototype.cmp = function(u) {
            if (this.negative !== 0 && u.negative === 0)
                return -1;
            if (this.negative === 0 && u.negative !== 0)
                return 1;
            var p = this.ucmp(u);
            return this.negative !== 0 ? -p | 0 : p
        }
        ,
        s.prototype.ucmp = function(u) {
            if (this.length > u.length)
                return 1;
            if (this.length < u.length)
                return -1;
            for (var p = 0, k = this.length - 1; k >= 0; k--) {
                var C = this.words[k] | 0
                  , I = u.words[k] | 0;
                if (C !== I) {
                    C < I ? p = -1 : C > I && (p = 1);
                    break
                }
            }
            return p
        }
        ,
        s.prototype.gtn = function(u) {
            return this.cmpn(u) === 1
        }
        ,
        s.prototype.gt = function(u) {
            return this.cmp(u) === 1
        }
        ,
        s.prototype.gten = function(u) {
            return this.cmpn(u) >= 0
        }
        ,
        s.prototype.gte = function(u) {
            return this.cmp(u) >= 0
        }
        ,
        s.prototype.ltn = function(u) {
            return this.cmpn(u) === -1
        }
        ,
        s.prototype.lt = function(u) {
            return this.cmp(u) === -1
        }
        ,
        s.prototype.lten = function(u) {
            return this.cmpn(u) <= 0
        }
        ,
        s.prototype.lte = function(u) {
            return this.cmp(u) <= 0
        }
        ,
        s.prototype.eqn = function(u) {
            return this.cmpn(u) === 0
        }
        ,
        s.prototype.eq = function(u) {
            return this.cmp(u) === 0
        }
        ,
        s.red = function(u) {
            return new Z(u)
        }
        ,
        s.prototype.toRed = function(u) {
            return r(!this.red, "Already a number in reduction context"),
            r(this.negative === 0, "red works only with positives"),
            u.convertTo(this)._forceRed(u)
        }
        ,
        s.prototype.fromRed = function() {
            return r(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        s.prototype._forceRed = function(u) {
            return this.red = u,
            this
        }
        ,
        s.prototype.forceRed = function(u) {
            return r(!this.red, "Already a number in reduction context"),
            this._forceRed(u)
        }
        ,
        s.prototype.redAdd = function(u) {
            return r(this.red, "redAdd works only with red numbers"),
            this.red.add(this, u)
        }
        ,
        s.prototype.redIAdd = function(u) {
            return r(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, u)
        }
        ,
        s.prototype.redSub = function(u) {
            return r(this.red, "redSub works only with red numbers"),
            this.red.sub(this, u)
        }
        ,
        s.prototype.redISub = function(u) {
            return r(this.red, "redISub works only with red numbers"),
            this.red.isub(this, u)
        }
        ,
        s.prototype.redShl = function(u) {
            return r(this.red, "redShl works only with red numbers"),
            this.red.shl(this, u)
        }
        ,
        s.prototype.redMul = function(u) {
            return r(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, u),
            this.red.mul(this, u)
        }
        ,
        s.prototype.redIMul = function(u) {
            return r(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, u),
            this.red.imul(this, u)
        }
        ,
        s.prototype.redSqr = function() {
            return r(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        s.prototype.redISqr = function() {
            return r(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        s.prototype.redSqrt = function() {
            return r(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        s.prototype.redInvm = function() {
            return r(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        s.prototype.redNeg = function() {
            return r(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        s.prototype.redPow = function(u) {
            return r(this.red && !u.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, u)
        }
        ;
        var O = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function D(T, u) {
            this.name = T,
            this.p = new s(u,16),
            this.n = this.p.bitLength(),
            this.k = new s(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        D.prototype._tmp = function() {
            var u = new s(null);
            return u.words = new Array(Math.ceil(this.n / 13)),
            u
        }
        ,
        D.prototype.ireduce = function(u) {
            var p = u, k;
            do
                this.split(p, this.tmp),
                p = this.imulK(p),
                p = p.iadd(this.tmp),
                k = p.bitLength();
            while (k > this.n);
            var C = k < this.n ? -1 : p.ucmp(this.p);
            return C === 0 ? (p.words[0] = 0,
            p.length = 1) : C > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(),
            p
        }
        ,
        D.prototype.split = function(u, p) {
            u.iushrn(this.n, 0, p)
        }
        ,
        D.prototype.imulK = function(u) {
            return u.imul(this.k)
        }
        ;
        function z() {
            D.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(z, D),
        z.prototype.split = function(u, p) {
            for (var k = 4194303, C = Math.min(u.length, 9), I = 0; I < C; I++)
                p.words[I] = u.words[I];
            if (p.length = C,
            u.length <= 9) {
                u.words[0] = 0,
                u.length = 1;
                return
            }
            var L = u.words[9];
            for (p.words[p.length++] = L & k,
            I = 10; I < u.length; I++) {
                var P = u.words[I] | 0;
                u.words[I - 10] = (P & k) << 4 | L >>> 22,
                L = P
            }
            L >>>= 22,
            u.words[I - 10] = L,
            L === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9
        }
        ,
        z.prototype.imulK = function(u) {
            u.words[u.length] = 0,
            u.words[u.length + 1] = 0,
            u.length += 2;
            for (var p = 0, k = 0; k < u.length; k++) {
                var C = u.words[k] | 0;
                p += C * 977,
                u.words[k] = p & 67108863,
                p = C * 64 + (p / 67108864 | 0)
            }
            return u.words[u.length - 1] === 0 && (u.length--,
            u.words[u.length - 1] === 0 && u.length--),
            u
        }
        ;
        function K() {
            D.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(K, D);
        function F() {
            D.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(F, D);
        function G() {
            D.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(G, D),
        G.prototype.imulK = function(u) {
            for (var p = 0, k = 0; k < u.length; k++) {
                var C = (u.words[k] | 0) * 19 + p
                  , I = C & 67108863;
                C >>>= 26,
                u.words[k] = I,
                p = C
            }
            return p !== 0 && (u.words[u.length++] = p),
            u
        }
        ,
        s._prime = function(u) {
            if (O[u])
                return O[u];
            var p;
            if (u === "k256")
                p = new z;
            else if (u === "p224")
                p = new K;
            else if (u === "p192")
                p = new F;
            else if (u === "p25519")
                p = new G;
            else
                throw new Error("Unknown prime " + u);
            return O[u] = p,
            p
        }
        ;
        function Z(T) {
            if (typeof T == "string") {
                var u = s._prime(T);
                this.m = u.p,
                this.prime = u
            } else
                r(T.gtn(1), "modulus must be greater than 1"),
                this.m = T,
                this.prime = null
        }
        Z.prototype._verify1 = function(u) {
            r(u.negative === 0, "red works only with positives"),
            r(u.red, "red works only with red numbers")
        }
        ,
        Z.prototype._verify2 = function(u, p) {
            r((u.negative | p.negative) === 0, "red works only with positives"),
            r(u.red && u.red === p.red, "red works only with red numbers")
        }
        ,
        Z.prototype.imod = function(u) {
            return this.prime ? this.prime.ireduce(u)._forceRed(this) : (d(u, u.umod(this.m)._forceRed(this)),
            u)
        }
        ,
        Z.prototype.neg = function(u) {
            return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this)
        }
        ,
        Z.prototype.add = function(u, p) {
            this._verify2(u, p);
            var k = u.add(p);
            return k.cmp(this.m) >= 0 && k.isub(this.m),
            k._forceRed(this)
        }
        ,
        Z.prototype.iadd = function(u, p) {
            this._verify2(u, p);
            var k = u.iadd(p);
            return k.cmp(this.m) >= 0 && k.isub(this.m),
            k
        }
        ,
        Z.prototype.sub = function(u, p) {
            this._verify2(u, p);
            var k = u.sub(p);
            return k.cmpn(0) < 0 && k.iadd(this.m),
            k._forceRed(this)
        }
        ,
        Z.prototype.isub = function(u, p) {
            this._verify2(u, p);
            var k = u.isub(p);
            return k.cmpn(0) < 0 && k.iadd(this.m),
            k
        }
        ,
        Z.prototype.shl = function(u, p) {
            return this._verify1(u),
            this.imod(u.ushln(p))
        }
        ,
        Z.prototype.imul = function(u, p) {
            return this._verify2(u, p),
            this.imod(u.imul(p))
        }
        ,
        Z.prototype.mul = function(u, p) {
            return this._verify2(u, p),
            this.imod(u.mul(p))
        }
        ,
        Z.prototype.isqr = function(u) {
            return this.imul(u, u.clone())
        }
        ,
        Z.prototype.sqr = function(u) {
            return this.mul(u, u)
        }
        ,
        Z.prototype.sqrt = function(u) {
            if (u.isZero())
                return u.clone();
            var p = this.m.andln(3);
            if (r(p % 2 === 1),
            p === 3) {
                var k = this.m.add(new s(1)).iushrn(2);
                return this.pow(u, k)
            }
            for (var C = this.m.subn(1), I = 0; !C.isZero() && C.andln(1) === 0; )
                I++,
                C.iushrn(1);
            r(!C.isZero());
            var L = new s(1).toRed(this)
              , P = L.redNeg()
              , N = this.m.subn(1).iushrn(1)
              , g = this.m.bitLength();
            for (g = new s(2 * g * g).toRed(this); this.pow(g, N).cmp(P) !== 0; )
                g.redIAdd(P);
            for (var B = this.pow(g, C), ie = this.pow(u, C.addn(1).iushrn(1)), te = this.pow(u, C), oe = I; te.cmp(L) !== 0; ) {
                for (var xe = te, ve = 0; xe.cmp(L) !== 0; ve++)
                    xe = xe.redSqr();
                r(ve < oe);
                var ye = this.pow(B, new s(1).iushln(oe - ve - 1));
                ie = ie.redMul(ye),
                B = ye.redSqr(),
                te = te.redMul(B),
                oe = ve
            }
            return ie
        }
        ,
        Z.prototype.invm = function(u) {
            var p = u._invmp(this.m);
            return p.negative !== 0 ? (p.negative = 0,
            this.imod(p).redNeg()) : this.imod(p)
        }
        ,
        Z.prototype.pow = function(u, p) {
            if (p.isZero())
                return new s(1).toRed(this);
            if (p.cmpn(1) === 0)
                return u.clone();
            var k = 4
              , C = new Array(1 << k);
            C[0] = new s(1).toRed(this),
            C[1] = u;
            for (var I = 2; I < C.length; I++)
                C[I] = this.mul(C[I - 1], u);
            var L = C[0]
              , P = 0
              , N = 0
              , g = p.bitLength() % 26;
            for (g === 0 && (g = 26),
            I = p.length - 1; I >= 0; I--) {
                for (var B = p.words[I], ie = g - 1; ie >= 0; ie--) {
                    var te = B >> ie & 1;
                    if (L !== C[0] && (L = this.sqr(L)),
                    te === 0 && P === 0) {
                        N = 0;
                        continue
                    }
                    P <<= 1,
                    P |= te,
                    N++,
                    !(N !== k && (I !== 0 || ie !== 0)) && (L = this.mul(L, C[P]),
                    N = 0,
                    P = 0)
                }
                g = 26
            }
            return L
        }
        ,
        Z.prototype.convertTo = function(u) {
            var p = u.umod(this.m);
            return p === u ? p.clone() : p
        }
        ,
        Z.prototype.convertFrom = function(u) {
            var p = u.clone();
            return p.red = null,
            p
        }
        ,
        s.mont = function(u) {
            return new X(u)
        }
        ;
        function X(T) {
            Z.call(this, T),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new s(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        i(X, Z),
        X.prototype.convertTo = function(u) {
            return this.imod(u.ushln(this.shift))
        }
        ,
        X.prototype.convertFrom = function(u) {
            var p = this.imod(u.mul(this.rinv));
            return p.red = null,
            p
        }
        ,
        X.prototype.imul = function(u, p) {
            if (u.isZero() || p.isZero())
                return u.words[0] = 0,
                u.length = 1,
                u;
            var k = u.imul(p)
              , C = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , I = k.isub(C).iushrn(this.shift)
              , L = I;
            return I.cmp(this.m) >= 0 ? L = I.isub(this.m) : I.cmpn(0) < 0 && (L = I.iadd(this.m)),
            L._forceRed(this)
        }
        ,
        X.prototype.mul = function(u, p) {
            if (u.isZero() || p.isZero())
                return new s(0)._forceRed(this);
            var k = u.mul(p)
              , C = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , I = k.isub(C).iushrn(this.shift)
              , L = I;
            return I.cmp(this.m) >= 0 ? L = I.isub(this.m) : I.cmpn(0) < 0 && (L = I.iadd(this.m)),
            L._forceRed(this)
        }
        ,
        X.prototype.invm = function(u) {
            var p = this.imod(u._invmp(this.m).mul(this.r2));
            return p._forceRed(this)
        }
    }
    )(t, Ye)
}
)(Fm);
var dx = Fm.exports;
const c1 = ho(dx);
var Ap = {
    exports: {}
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
    var n = pe
      , r = n.Buffer;
    function i(o, a) {
        for (var l in o)
            a[l] = o[l]
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t.exports = n : (i(n, e),
    e.Buffer = s);
    function s(o, a, l) {
        return r(o, a, l)
    }
    s.prototype = Object.create(r.prototype),
    i(r, s),
    s.from = function(o, a, l) {
        if (typeof o == "number")
            throw new TypeError("Argument must not be a number");
        return r(o, a, l)
    }
    ,
    s.alloc = function(o, a, l) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        var c = r(o);
        return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0),
        c
    }
    ,
    s.allocUnsafe = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return r(o)
    }
    ,
    s.allocUnsafeSlow = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return n.SlowBuffer(o)
    }
}
)(Ap, Ap.exports);
var hx = Ap.exports
  , iu = hx.Buffer;
function rI(t) {
    if (t.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), n = 0; n < e.length; n++)
        e[n] = 255;
    for (var r = 0; r < t.length; r++) {
        var i = t.charAt(r)
          , s = i.charCodeAt(0);
        if (e[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        e[s] = r
    }
    var o = t.length
      , a = t.charAt(0)
      , l = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function d(m) {
        if ((Array.isArray(m) || m instanceof Uint8Array) && (m = iu.from(m)),
        !iu.isBuffer(m))
            throw new TypeError("Expected Buffer");
        if (m.length === 0)
            return "";
        for (var v = 0, E = 0, A = 0, _ = m.length; A !== _ && m[A] === 0; )
            A++,
            v++;
        for (var x = (_ - A) * c + 1 >>> 0, b = new Uint8Array(x); A !== _; ) {
            for (var R = m[A], O = 0, D = x - 1; (R !== 0 || O < E) && D !== -1; D--,
            O++)
                R += 256 * b[D] >>> 0,
                b[D] = R % o >>> 0,
                R = R / o >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            E = O,
            A++
        }
        for (var z = x - E; z !== x && b[z] === 0; )
            z++;
        for (var K = a.repeat(v); z < x; ++z)
            K += t.charAt(b[z]);
        return K
    }
    function h(m) {
        if (typeof m != "string")
            throw new TypeError("Expected String");
        if (m.length === 0)
            return iu.alloc(0);
        for (var v = 0, E = 0, A = 0; m[v] === a; )
            E++,
            v++;
        for (var _ = (m.length - v) * l + 1 >>> 0, x = new Uint8Array(_); v < m.length; ) {
            var b = m.charCodeAt(v);
            if (b > 255)
                return;
            var R = e[b];
            if (R === 255)
                return;
            for (var O = 0, D = _ - 1; (R !== 0 || O < A) && D !== -1; D--,
            O++)
                R += o * x[D] >>> 0,
                x[D] = R % 256 >>> 0,
                R = R / 256 >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            A = O,
            v++
        }
        for (var z = _ - A; z !== _ && x[z] === 0; )
            z++;
        var K = iu.allocUnsafe(E + (_ - z));
        K.fill(0, 0, E);
        for (var F = E; z !== _; )
            K[F++] = x[z++];
        return K
    }
    function y(m) {
        var v = h(m);
        if (v)
            return v;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: y
    }
}
var iI = rI
  , sI = iI
  , oI = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , aI = sI(oI);
const gn = ho(aI)
  , u1 = K_;
var pn = {}
  , su = hx.Buffer;
function lI(t) {
    if (t.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), n = 0; n < e.length; n++)
        e[n] = 255;
    for (var r = 0; r < t.length; r++) {
        var i = t.charAt(r)
          , s = i.charCodeAt(0);
        if (e[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        e[s] = r
    }
    var o = t.length
      , a = t.charAt(0)
      , l = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function d(m) {
        if ((Array.isArray(m) || m instanceof Uint8Array) && (m = su.from(m)),
        !su.isBuffer(m))
            throw new TypeError("Expected Buffer");
        if (m.length === 0)
            return "";
        for (var v = 0, E = 0, A = 0, _ = m.length; A !== _ && m[A] === 0; )
            A++,
            v++;
        for (var x = (_ - A) * c + 1 >>> 0, b = new Uint8Array(x); A !== _; ) {
            for (var R = m[A], O = 0, D = x - 1; (R !== 0 || O < E) && D !== -1; D--,
            O++)
                R += 256 * b[D] >>> 0,
                b[D] = R % o >>> 0,
                R = R / o >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            E = O,
            A++
        }
        for (var z = x - E; z !== x && b[z] === 0; )
            z++;
        for (var K = a.repeat(v); z < x; ++z)
            K += t.charAt(b[z]);
        return K
    }
    function h(m) {
        if (typeof m != "string")
            throw new TypeError("Expected String");
        if (m.length === 0)
            return su.alloc(0);
        for (var v = 0, E = 0, A = 0; m[v] === a; )
            E++,
            v++;
        for (var _ = (m.length - v) * l + 1 >>> 0, x = new Uint8Array(_); v < m.length; ) {
            var b = m.charCodeAt(v);
            if (b > 255)
                return;
            var R = e[b];
            if (R === 255)
                return;
            for (var O = 0, D = _ - 1; (R !== 0 || O < A) && D !== -1; D--,
            O++)
                R += o * x[D] >>> 0,
                x[D] = R % 256 >>> 0,
                R = R / 256 >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            A = O,
            v++
        }
        for (var z = _ - A; z !== _ && x[z] === 0; )
            z++;
        var K = su.allocUnsafe(E + (_ - z));
        K.fill(0, 0, E);
        for (var F = E; z !== _; )
            K[F++] = x[z++];
        return K
    }
    function y(m) {
        var v = h(m);
        if (v)
            return v;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: y
    }
}
var cI = lI
  , uI = cI
  , dI = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , hI = uI(dI);
function wi(t, e, n) {
    return e <= t && t <= n
}
function xh(t) {
    if (t === void 0)
        return {};
    if (t === Object(t))
        return t;
    throw TypeError("Could not convert argument to dictionary")
}
function fI(t) {
    for (var e = String(t), n = e.length, r = 0, i = []; r < n; ) {
        var s = e.charCodeAt(r);
        if (s < 55296 || s > 57343)
            i.push(s);
        else if (56320 <= s && s <= 57343)
            i.push(65533);
        else if (55296 <= s && s <= 56319)
            if (r === n - 1)
                i.push(65533);
            else {
                var o = t.charCodeAt(r + 1);
                if (56320 <= o && o <= 57343) {
                    var a = s & 1023
                      , l = o & 1023;
                    i.push(65536 + (a << 10) + l),
                    r += 1
                } else
                    i.push(65533)
            }
        r += 1
    }
    return i
}
function pI(t) {
    for (var e = "", n = 0; n < t.length; ++n) {
        var r = t[n];
        r <= 65535 ? e += String.fromCharCode(r) : (r -= 65536,
        e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320))
    }
    return e
}
var jd = -1;
function $m(t) {
    this.tokens = [].slice.call(t)
}
$m.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : jd
    },
    prepend: function(t) {
        if (Array.isArray(t))
            for (var e = t; e.length; )
                this.tokens.unshift(e.pop());
        else
            this.tokens.unshift(t)
    },
    push: function(t) {
        if (Array.isArray(t))
            for (var e = t; e.length; )
                this.tokens.push(e.shift());
        else
            this.tokens.push(t)
    }
};
var Aa = -1;
function Jf(t, e) {
    if (t)
        throw TypeError("Decoder error");
    return e || 65533
}
var Bd = "utf-8";
function Pd(t, e) {
    if (!(this instanceof Pd))
        return new Pd(t,e);
    if (t = t !== void 0 ? String(t).toLowerCase() : Bd,
    t !== Bd)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = xh(e),
    this._streaming = !1,
    this._BOMseen = !1,
    this._decoder = null,
    this._fatal = !!e.fatal,
    this._ignoreBOM = !!e.ignoreBOM,
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }),
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    }),
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
Pd.prototype = {
    decode: function(e, n) {
        var r;
        typeof e == "object" && e instanceof ArrayBuffer ? r = new Uint8Array(e) : typeof e == "object" && "buffer"in e && e.buffer instanceof ArrayBuffer ? r = new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : r = new Uint8Array(0),
        n = xh(n),
        this._streaming || (this._decoder = new gI({
            fatal: this._fatal
        }),
        this._BOMseen = !1),
        this._streaming = !!n.stream;
        for (var i = new $m(r), s = [], o; !i.endOfStream() && (o = this._decoder.handler(i, i.read()),
        o !== Aa); )
            o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(i, i.read()),
                o === Aa)
                    break;
                o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o))
            } while (!i.endOfStream());
            this._decoder = null
        }
        return s.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (s[0] === 65279 ? (this._BOMseen = !0,
        s.shift()) : this._BOMseen = !0),
        pI(s)
    }
};
function Od(t, e) {
    if (!(this instanceof Od))
        return new Od(t,e);
    if (t = t !== void 0 ? String(t).toLowerCase() : Bd,
    t !== Bd)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = xh(e),
    this._streaming = !1,
    this._encoder = null,
    this._options = {
        fatal: !!e.fatal
    },
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
Od.prototype = {
    encode: function(e, n) {
        e = e ? String(e) : "",
        n = xh(n),
        this._streaming || (this._encoder = new mI(this._options)),
        this._streaming = !!n.stream;
        for (var r = [], i = new $m(fI(e)), s; !i.endOfStream() && (s = this._encoder.handler(i, i.read()),
        s !== Aa); )
            Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
        if (!this._streaming) {
            for (; s = this._encoder.handler(i, i.read()),
            s !== Aa; )
                Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
            this._encoder = null
        }
        return new Uint8Array(r)
    }
};
function gI(t) {
    var e = t.fatal
      , n = 0
      , r = 0
      , i = 0
      , s = 128
      , o = 191;
    this.handler = function(a, l) {
        if (l === jd && i !== 0)
            return i = 0,
            Jf(e);
        if (l === jd)
            return Aa;
        if (i === 0) {
            if (wi(l, 0, 127))
                return l;
            if (wi(l, 194, 223))
                i = 1,
                n = l - 192;
            else if (wi(l, 224, 239))
                l === 224 && (s = 160),
                l === 237 && (o = 159),
                i = 2,
                n = l - 224;
            else if (wi(l, 240, 244))
                l === 240 && (s = 144),
                l === 244 && (o = 143),
                i = 3,
                n = l - 240;
            else
                return Jf(e);
            return n = n << 6 * i,
            null
        }
        if (!wi(l, s, o))
            return n = i = r = 0,
            s = 128,
            o = 191,
            a.prepend(l),
            Jf(e);
        if (s = 128,
        o = 191,
        r += 1,
        n += l - 128 << 6 * (i - r),
        r !== i)
            return null;
        var c = n;
        return n = i = r = 0,
        c
    }
}
function mI(t) {
    t.fatal,
    this.handler = function(e, n) {
        if (n === jd)
            return Aa;
        if (wi(n, 0, 127))
            return n;
        var r, i;
        wi(n, 128, 2047) ? (r = 1,
        i = 192) : wi(n, 2048, 65535) ? (r = 2,
        i = 224) : wi(n, 65536, 1114111) && (r = 3,
        i = 240);
        for (var s = [(n >> 6 * r) + i]; r > 0; ) {
            var o = n >> 6 * (r - 1);
            s.push(128 | o & 63),
            r -= 1
        }
        return s
    }
}
const yI = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: Pd,
    TextEncoder: Od
}, Symbol.toStringTag, {
    value: "Module"
}))
  , wI = ms(yI);
var vI = Ye && Ye.__createBinding || (Object.create ? function(t, e, n, r) {
    r === void 0 && (r = n),
    Object.defineProperty(t, r, {
        enumerable: !0,
        get: function() {
            return e[n]
        }
    })
}
: function(t, e, n, r) {
    r === void 0 && (r = n),
    t[r] = e[n]
}
)
  , bI = Ye && Ye.__setModuleDefault || (Object.create ? function(t, e) {
    Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e
    })
}
: function(t, e) {
    t.default = e
}
)
  , ri = Ye && Ye.__decorate || function(t, e, n, r) {
    var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s),
    s
}
  , _I = Ye && Ye.__importStar || function(t) {
    if (t && t.__esModule)
        return t;
    var e = {};
    if (t != null)
        for (var n in t)
            n !== "default" && Object.hasOwnProperty.call(t, n) && vI(e, t, n);
    return bI(e, t),
    e
}
  , fx = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(pn, "__esModule", {
    value: !0
});
var px = pn.deserializeUnchecked = bx = pn.deserialize = vx = pn.serialize = pn.BinaryReader = pn.BinaryWriter = pn.BorshError = pn.baseDecode = pn.baseEncode = void 0;
const Xi = fx(dx)
  , gx = fx(hI)
  , xI = _I(wI)
  , SI = typeof TextDecoder != "function" ? xI.TextDecoder : TextDecoder
  , kI = new SI("utf-8",{
    fatal: !0
});
function EI(t) {
    return typeof t == "string" && (t = Buffer.from(t, "utf8")),
    gx.default.encode(Buffer.from(t))
}
pn.baseEncode = EI;
function AI(t) {
    return Buffer.from(gx.default.decode(t))
}
pn.baseDecode = AI;
const Xf = 1024;
class Bn extends Error {
    constructor(e) {
        super(e),
        this.fieldPath = [],
        this.originalMessage = e
    }
    addToFieldPath(e) {
        this.fieldPath.splice(0, 0, e),
        this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}
pn.BorshError = Bn;
class mx {
    constructor() {
        this.buf = Buffer.alloc(Xf),
        this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(Xf)]))
    }
    writeU8(e) {
        this.maybeResize(),
        this.buf.writeUInt8(e, this.length),
        this.length += 1
    }
    writeU16(e) {
        this.maybeResize(),
        this.buf.writeUInt16LE(e, this.length),
        this.length += 2
    }
    writeU32(e) {
        this.maybeResize(),
        this.buf.writeUInt32LE(e, this.length),
        this.length += 4
    }
    writeU64(e) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Xi.default(e).toArray("le", 8)))
    }
    writeU128(e) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Xi.default(e).toArray("le", 16)))
    }
    writeU256(e) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Xi.default(e).toArray("le", 32)))
    }
    writeU512(e) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Xi.default(e).toArray("le", 64)))
    }
    writeBuffer(e) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), e, Buffer.alloc(Xf)]),
        this.length += e.length
    }
    writeString(e) {
        this.maybeResize();
        const n = Buffer.from(e, "utf8");
        this.writeU32(n.length),
        this.writeBuffer(n)
    }
    writeFixedArray(e) {
        this.writeBuffer(Buffer.from(e))
    }
    writeArray(e, n) {
        this.maybeResize(),
        this.writeU32(e.length);
        for (const r of e)
            this.maybeResize(),
            n(r)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
}
pn.BinaryWriter = mx;
function ii(t, e, n) {
    const r = n.value;
    n.value = function(...i) {
        try {
            return r.apply(this, i)
        } catch (s) {
            if (s instanceof RangeError) {
                const o = s.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0)
                    throw new Bn("Reached the end of buffer when deserializing")
            }
            throw s
        }
    }
}
class dr {
    constructor(e) {
        this.buf = e,
        this.offset = 0
    }
    readU8() {
        const e = this.buf.readUInt8(this.offset);
        return this.offset += 1,
        e
    }
    readU16() {
        const e = this.buf.readUInt16LE(this.offset);
        return this.offset += 2,
        e
    }
    readU32() {
        const e = this.buf.readUInt32LE(this.offset);
        return this.offset += 4,
        e
    }
    readU64() {
        const e = this.readBuffer(8);
        return new Xi.default(e,"le")
    }
    readU128() {
        const e = this.readBuffer(16);
        return new Xi.default(e,"le")
    }
    readU256() {
        const e = this.readBuffer(32);
        return new Xi.default(e,"le")
    }
    readU512() {
        const e = this.readBuffer(64);
        return new Xi.default(e,"le")
    }
    readBuffer(e) {
        if (this.offset + e > this.buf.length)
            throw new Bn(`Expected buffer length ${e} isn't within bounds`);
        const n = this.buf.slice(this.offset, this.offset + e);
        return this.offset += e,
        n
    }
    readString() {
        const e = this.readU32()
          , n = this.readBuffer(e);
        try {
            return kI.decode(n)
        } catch (r) {
            throw new Bn(`Error decoding UTF-8 string: ${r}`)
        }
    }
    readFixedArray(e) {
        return new Uint8Array(this.readBuffer(e))
    }
    readArray(e) {
        const n = this.readU32()
          , r = Array();
        for (let i = 0; i < n; ++i)
            r.push(e());
        return r
    }
}
ri([ii], dr.prototype, "readU8", null);
ri([ii], dr.prototype, "readU16", null);
ri([ii], dr.prototype, "readU32", null);
ri([ii], dr.prototype, "readU64", null);
ri([ii], dr.prototype, "readU128", null);
ri([ii], dr.prototype, "readU256", null);
ri([ii], dr.prototype, "readU512", null);
ri([ii], dr.prototype, "readString", null);
ri([ii], dr.prototype, "readFixedArray", null);
ri([ii], dr.prototype, "readArray", null);
pn.BinaryReader = dr;
function yx(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}
function js(t, e, n, r, i) {
    try {
        if (typeof r == "string")
            i[`write${yx(r)}`](n);
        else if (r instanceof Array)
            if (typeof r[0] == "number") {
                if (n.length !== r[0])
                    throw new Bn(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
                i.writeFixedArray(n)
            } else if (r.length === 2 && typeof r[1] == "number") {
                if (n.length !== r[1])
                    throw new Bn(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
                for (let s = 0; s < r[1]; s++)
                    js(t, null, n[s], r[0], i)
            } else
                i.writeArray(n, s => {
                    js(t, e, s, r[0], i)
                }
                );
        else if (r.kind !== void 0)
            switch (r.kind) {
            case "option":
                {
                    n == null ? i.writeU8(0) : (i.writeU8(1),
                    js(t, e, n, r.type, i));
                    break
                }
            case "map":
                {
                    i.writeU32(n.size),
                    n.forEach( (s, o) => {
                        js(t, e, o, r.key, i),
                        js(t, e, s, r.value, i)
                    }
                    );
                    break
                }
            default:
                throw new Bn(`FieldType ${r} unrecognized`)
            }
        else
            wx(t, n, i)
    } catch (s) {
        throw s instanceof Bn && s.addToFieldPath(e),
        s
    }
}
function wx(t, e, n) {
    if (typeof e.borshSerialize == "function") {
        e.borshSerialize(n);
        return
    }
    const r = t.get(e.constructor);
    if (!r)
        throw new Bn(`Class ${e.constructor.name} is missing in schema`);
    if (r.kind === "struct")
        r.fields.map( ([i,s]) => {
            js(t, i, e[i], s, n)
        }
        );
    else if (r.kind === "enum") {
        const i = e[r.field];
        for (let s = 0; s < r.values.length; ++s) {
            const [o,a] = r.values[s];
            if (o === i) {
                n.writeU8(s),
                js(t, o, e[o], a, n);
                break
            }
        }
    } else
        throw new Bn(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)
}
function II(t, e, n=mx) {
    const r = new n;
    return wx(t, e, r),
    r.toArray()
}
var vx = pn.serialize = II;
function Bs(t, e, n, r) {
    try {
        if (typeof n == "string")
            return r[`read${yx(n)}`]();
        if (n instanceof Array) {
            if (typeof n[0] == "number")
                return r.readFixedArray(n[0]);
            if (typeof n[1] == "number") {
                const i = [];
                for (let s = 0; s < n[1]; s++)
                    i.push(Bs(t, null, n[0], r));
                return i
            } else
                return r.readArray( () => Bs(t, e, n[0], r))
        }
        if (n.kind === "option")
            return r.readU8() ? Bs(t, e, n.type, r) : void 0;
        if (n.kind === "map") {
            let i = new Map;
            const s = r.readU32();
            for (let o = 0; o < s; o++) {
                const a = Bs(t, e, n.key, r)
                  , l = Bs(t, e, n.value, r);
                i.set(a, l)
            }
            return i
        }
        return Km(t, n, r)
    } catch (i) {
        throw i instanceof Bn && i.addToFieldPath(e),
        i
    }
}
function Km(t, e, n) {
    if (typeof e.borshDeserialize == "function")
        return e.borshDeserialize(n);
    const r = t.get(e);
    if (!r)
        throw new Bn(`Class ${e.name} is missing in schema`);
    if (r.kind === "struct") {
        const i = {};
        for (const [s,o] of t.get(e).fields)
            i[s] = Bs(t, s, o, n);
        return new e(i)
    }
    if (r.kind === "enum") {
        const i = n.readU8();
        if (i >= r.values.length)
            throw new Bn(`Enum index: ${i} is out of range`);
        const [s,o] = r.values[i]
          , a = Bs(t, s, o, n);
        return new e({
            [s]: a
        })
    }
    throw new Bn(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)
}
function MI(t, e, n, r=dr) {
    const i = new r(n)
      , s = Km(t, e, i);
    if (i.offset < n.length)
        throw new Bn(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
    return s
}
var bx = pn.deserialize = MI;
function TI(t, e, n, r=dr) {
    const i = new r(n);
    return Km(t, e, i)
}
px = pn.deserializeUnchecked = TI;
var H = {};
Object.defineProperty(H, "__esModule", {
    value: !0
});
H.s16 = H.s8 = H.nu64be = H.u48be = H.u40be = H.u32be = H.u24be = H.u16be = dn = H.nu64 = H.u48 = H.u40 = ue = H.u32 = H.u24 = gr = H.u16 = Pe = H.u8 = ds = H.offset = H.greedy = H.Constant = H.UTF8 = H.CString = H.Blob = H.Boolean = H.BitField = H.BitStructure = H.VariantLayout = H.Union = H.UnionLayoutDiscriminator = H.UnionDiscriminator = H.Structure = H.Sequence = H.DoubleBE = H.Double = H.FloatBE = H.Float = H.NearInt64BE = H.NearInt64 = H.NearUInt64BE = H.NearUInt64 = H.IntBE = H.Int = H.UIntBE = H.UInt = H.OffsetLayout = H.GreedyCount = H.ExternalLayout = H.bindConstructorLayout = H.nameWithProperty = H.Layout = H.uint8ArrayToBuffer = H.checkUint8Array = void 0;
H.constant = H.utf8 = H.cstr = st = H.blob = H.unionLayoutDiscriminator = H.union = mn = H.seq = H.bits = de = H.struct = H.f64be = H.f64 = H.f32be = H.f32 = H.ns64be = H.s48be = H.s40be = H.s32be = H.s24be = H.s16be = tr = H.ns64 = H.s48 = H.s40 = H.s32 = H.s24 = void 0;
const Vm = pe;
function Ua(t) {
    if (!(t instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array")
}
H.checkUint8Array = Ua;
function Ue(t) {
    return Ua(t),
    Vm.Buffer.from(t.buffer, t.byteOffset, t.length)
}
H.uint8ArrayToBuffer = Ue;
class Ve {
    constructor(e, n) {
        if (!Number.isInteger(e))
            throw new TypeError("span must be an integer");
        this.span = e,
        this.property = n
    }
    makeDestinationObject() {
        return {}
    }
    getSpan(e, n) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(e) {
        const n = Object.create(this.constructor.prototype);
        return Object.assign(n, this),
        n.property = e,
        n
    }
    fromArray(e) {}
}
H.Layout = Ve;
function Hm(t, e) {
    return e.property ? t + "[" + e.property + "]" : t
}
H.nameWithProperty = Hm;
function NI(t, e) {
    if (typeof t != "function")
        throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(t, "layout_"))
        throw new Error("Class is already bound to a layout");
    if (!(e && e instanceof Ve))
        throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
        throw new Error("layout is already bound to a constructor");
    t.layout_ = e,
    e.boundConstructor_ = t,
    e.makeDestinationObject = () => new t,
    Object.defineProperty(t.prototype, "encode", {
        value(n, r) {
            return e.encode(this, n, r)
        },
        writable: !0
    }),
    Object.defineProperty(t, "decode", {
        value(n, r) {
            return e.decode(n, r)
        },
        writable: !0
    })
}
H.bindConstructorLayout = NI;
class Vn extends Ve {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
H.ExternalLayout = Vn;
class _x extends Vn {
    constructor(e=1, n) {
        if (!Number.isInteger(e) || 0 >= e)
            throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, n),
        this.elementSpan = e
    }
    isCount() {
        return !0
    }
    decode(e, n=0) {
        Ua(e);
        const r = e.length - n;
        return Math.floor(r / this.elementSpan)
    }
    encode(e, n, r) {
        return 0
    }
}
H.GreedyCount = _x;
class qm extends Vn {
    constructor(e, n=0, r) {
        if (!(e instanceof Ve))
            throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(n))
            throw new TypeError("offset must be integer or undefined");
        super(e.span, r || e.property),
        this.layout = e,
        this.offset = n
    }
    isCount() {
        return this.layout instanceof br || this.layout instanceof Br
    }
    decode(e, n=0) {
        return this.layout.decode(e, n + this.offset)
    }
    encode(e, n, r=0) {
        return this.layout.encode(e, n, r + this.offset)
    }
}
H.OffsetLayout = qm;
class br extends Ve {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n=0) {
        return Ue(e).readUIntLE(n, this.span)
    }
    encode(e, n, r=0) {
        return Ue(n).writeUIntLE(e, r, this.span),
        this.span
    }
}
H.UInt = br;
class Br extends Ve {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n=0) {
        return Ue(e).readUIntBE(n, this.span)
    }
    encode(e, n, r=0) {
        return Ue(n).writeUIntBE(e, r, this.span),
        this.span
    }
}
H.UIntBE = Br;
class mo extends Ve {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n=0) {
        return Ue(e).readIntLE(n, this.span)
    }
    encode(e, n, r=0) {
        return Ue(n).writeIntLE(e, r, this.span),
        this.span
    }
}
H.Int = mo;
class Wa extends Ve {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n=0) {
        return Ue(e).readIntBE(n, this.span)
    }
    encode(e, n, r=0) {
        return Ue(n).writeIntBE(e, r, this.span),
        this.span
    }
}
H.IntBE = Wa;
const Ip = Math.pow(2, 32);
function Sh(t) {
    const e = Math.floor(t / Ip)
      , n = t - e * Ip;
    return {
        hi32: e,
        lo32: n
    }
}
function kh(t, e) {
    return t * Ip + e
}
class xx extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        const r = Ue(e)
          , i = r.readUInt32LE(n)
          , s = r.readUInt32LE(n + 4);
        return kh(s, i)
    }
    encode(e, n, r=0) {
        const i = Sh(e)
          , s = Ue(n);
        return s.writeUInt32LE(i.lo32, r),
        s.writeUInt32LE(i.hi32, r + 4),
        8
    }
}
H.NearUInt64 = xx;
class Sx extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        const r = Ue(e)
          , i = r.readUInt32BE(n)
          , s = r.readUInt32BE(n + 4);
        return kh(i, s)
    }
    encode(e, n, r=0) {
        const i = Sh(e)
          , s = Ue(n);
        return s.writeUInt32BE(i.hi32, r),
        s.writeUInt32BE(i.lo32, r + 4),
        8
    }
}
H.NearUInt64BE = Sx;
class kx extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        const r = Ue(e)
          , i = r.readUInt32LE(n)
          , s = r.readInt32LE(n + 4);
        return kh(s, i)
    }
    encode(e, n, r=0) {
        const i = Sh(e)
          , s = Ue(n);
        return s.writeUInt32LE(i.lo32, r),
        s.writeInt32LE(i.hi32, r + 4),
        8
    }
}
H.NearInt64 = kx;
class Ex extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        const r = Ue(e)
          , i = r.readInt32BE(n)
          , s = r.readUInt32BE(n + 4);
        return kh(i, s)
    }
    encode(e, n, r=0) {
        const i = Sh(e)
          , s = Ue(n);
        return s.writeInt32BE(i.hi32, r),
        s.writeUInt32BE(i.lo32, r + 4),
        8
    }
}
H.NearInt64BE = Ex;
class Ax extends Ve {
    constructor(e) {
        super(4, e)
    }
    decode(e, n=0) {
        return Ue(e).readFloatLE(n)
    }
    encode(e, n, r=0) {
        return Ue(n).writeFloatLE(e, r),
        4
    }
}
H.Float = Ax;
class Ix extends Ve {
    constructor(e) {
        super(4, e)
    }
    decode(e, n=0) {
        return Ue(e).readFloatBE(n)
    }
    encode(e, n, r=0) {
        return Ue(n).writeFloatBE(e, r),
        4
    }
}
H.FloatBE = Ix;
class Mx extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        return Ue(e).readDoubleLE(n)
    }
    encode(e, n, r=0) {
        return Ue(n).writeDoubleLE(e, r),
        8
    }
}
H.Double = Mx;
class Tx extends Ve {
    constructor(e) {
        super(8, e)
    }
    decode(e, n=0) {
        return Ue(e).readDoubleBE(n)
    }
    encode(e, n, r=0) {
        return Ue(n).writeDoubleBE(e, r),
        8
    }
}
H.DoubleBE = Tx;
class Nx extends Ve {
    constructor(e, n, r) {
        if (!(e instanceof Ve))
            throw new TypeError("elementLayout must be a Layout");
        if (!(n instanceof Vn && n.isCount() || Number.isInteger(n) && 0 <= n))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let i = -1;
        !(n instanceof Vn) && 0 < e.span && (i = n * e.span),
        super(i, r),
        this.elementLayout = e,
        this.count = n
    }
    getSpan(e, n=0) {
        if (0 <= this.span)
            return this.span;
        let r = 0
          , i = this.count;
        if (i instanceof Vn && (i = i.decode(e, n)),
        0 < this.elementLayout.span)
            r = i * this.elementLayout.span;
        else {
            let s = 0;
            for (; s < i; )
                r += this.elementLayout.getSpan(e, n + r),
                ++s
        }
        return r
    }
    decode(e, n=0) {
        const r = [];
        let i = 0
          , s = this.count;
        for (s instanceof Vn && (s = s.decode(e, n)); i < s; )
            r.push(this.elementLayout.decode(e, n)),
            n += this.elementLayout.getSpan(e, n),
            i += 1;
        return r
    }
    encode(e, n, r=0) {
        const i = this.elementLayout
          , s = e.reduce( (o, a) => o + i.encode(a, n, r + o), 0);
        return this.count instanceof Vn && this.count.encode(e.length, n, r),
        s
    }
}
H.Sequence = Nx;
class Cx extends Ve {
    constructor(e, n, r) {
        if (!(Array.isArray(e) && e.reduce( (s, o) => s && o instanceof Ve, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof n == "boolean" && r === void 0 && (r = n,
        n = void 0);
        for (const s of e)
            if (0 > s.span && s.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let i = -1;
        try {
            i = e.reduce( (s, o) => s + o.getSpan(), 0)
        } catch {}
        super(i, n),
        this.fields = e,
        this.decodePrefixes = !!r
    }
    getSpan(e, n=0) {
        if (0 <= this.span)
            return this.span;
        let r = 0;
        try {
            r = this.fields.reduce( (i, s) => {
                const o = s.getSpan(e, n);
                return n += o,
                i + o
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return r
    }
    decode(e, n=0) {
        Ua(e);
        const r = this.makeDestinationObject();
        for (const i of this.fields)
            if (i.property !== void 0 && (r[i.property] = i.decode(e, n)),
            n += i.getSpan(e, n),
            this.decodePrefixes && e.length === n)
                break;
        return r
    }
    encode(e, n, r=0) {
        const i = r;
        let s = 0
          , o = 0;
        for (const a of this.fields) {
            let l = a.span;
            if (o = 0 < l ? l : 0,
            a.property !== void 0) {
                const c = e[a.property];
                c !== void 0 && (o = a.encode(c, n, r),
                0 > l && (l = a.getSpan(n, r)))
            }
            s = r,
            r += l
        }
        return s + o - i
    }
    fromArray(e) {
        const n = this.makeDestinationObject();
        for (const r of this.fields)
            r.property !== void 0 && 0 < e.length && (n[r.property] = e.shift());
        return n
    }
    layoutFor(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        for (const n of this.fields)
            if (n.property === e)
                return n
    }
    offsetOf(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        let n = 0;
        for (const r of this.fields) {
            if (r.property === e)
                return n;
            0 > r.span ? n = -1 : 0 <= n && (n += r.span)
        }
    }
}
H.Structure = Cx;
class Gm {
    constructor(e) {
        this.property = e
    }
    decode(e, n) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode(e, n, r) {
        throw new Error("UnionDiscriminator is abstract")
    }
}
H.UnionDiscriminator = Gm;
class Dd extends Gm {
    constructor(e, n) {
        if (!(e instanceof Vn && e.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(n || e.property || "variant"),
        this.layout = e
    }
    decode(e, n) {
        return this.layout.decode(e, n)
    }
    encode(e, n, r) {
        return this.layout.encode(e, n, r)
    }
}
H.UnionLayoutDiscriminator = Dd;
class Ym extends Ve {
    constructor(e, n, r) {
        let i;
        if (e instanceof br || e instanceof Br)
            i = new Dd(new qm(e));
        else if (e instanceof Vn && e.isCount())
            i = new Dd(e);
        else if (e instanceof Gm)
            i = e;
        else
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (n === void 0 && (n = null),
        !(n === null || n instanceof Ve))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (n !== null) {
            if (0 > n.span)
                throw new Error("defaultLayout must have constant span");
            n.property === void 0 && (n = n.replicate("content"))
        }
        let s = -1;
        n && (s = n.span,
        0 <= s && (e instanceof br || e instanceof Br) && (s += i.layout.span)),
        super(s, r),
        this.discriminator = i,
        this.usesPrefixDiscriminator = e instanceof br || e instanceof Br,
        this.defaultLayout = n,
        this.registry = {};
        let o = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(a) {
            return o(a)
        }
        ,
        this.configGetSourceVariant = function(a) {
            o = a.bind(this)
        }
    }
    getSpan(e, n=0) {
        if (0 <= this.span)
            return this.span;
        const r = this.getVariant(e, n);
        if (!r)
            throw new Error("unable to determine span for unrecognized variant");
        return r.getSpan(e, n)
    }
    defaultGetSourceVariant(e) {
        if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property))
                return;
            const n = this.registry[e[this.discriminator.property]];
            if (n && (!n.layout || n.property && Object.prototype.hasOwnProperty.call(e, n.property)))
                return n
        } else
            for (const n in this.registry) {
                const r = this.registry[n];
                if (r.property && Object.prototype.hasOwnProperty.call(e, r.property))
                    return r
            }
        throw new Error("unable to infer src variant")
    }
    decode(e, n=0) {
        let r;
        const i = this.discriminator
          , s = i.decode(e, n)
          , o = this.registry[s];
        if (o === void 0) {
            const a = this.defaultLayout;
            let l = 0;
            this.usesPrefixDiscriminator && (l = i.layout.span),
            r = this.makeDestinationObject(),
            r[i.property] = s,
            r[a.property] = a.decode(e, n + l)
        } else
            r = o.decode(e, n);
        return r
    }
    encode(e, n, r=0) {
        const i = this.getSourceVariant(e);
        if (i === void 0) {
            const s = this.discriminator
              , o = this.defaultLayout;
            let a = 0;
            return this.usesPrefixDiscriminator && (a = s.layout.span),
            s.encode(e[s.property], n, r),
            a + o.encode(e[o.property], n, r + a)
        }
        return i.encode(e, n, r)
    }
    addVariant(e, n, r) {
        const i = new Rx(this,e,n,r);
        return this.registry[e] = i,
        i
    }
    getVariant(e, n=0) {
        let r;
        return e instanceof Uint8Array ? r = this.discriminator.decode(e, n) : r = e,
        this.registry[r]
    }
}
H.Union = Ym;
class Rx extends Ve {
    constructor(e, n, r, i) {
        if (!(e instanceof Ym))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(n) || 0 > n)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof r == "string" && i === void 0 && (i = r,
        r = null),
        r) {
            if (!(r instanceof Ve))
                throw new TypeError("layout must be a Layout");
            if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof i != "string")
                throw new TypeError("variant must have a String property")
        }
        let s = e.span;
        0 > e.span && (s = r ? r.span : 0,
        0 <= s && e.usesPrefixDiscriminator && (s += e.discriminator.layout.span)),
        super(s, i),
        this.union = e,
        this.variant = n,
        this.layout = r || null
    }
    getSpan(e, n=0) {
        if (0 <= this.span)
            return this.span;
        let r = 0;
        this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span);
        let i = 0;
        return this.layout && (i = this.layout.getSpan(e, n + r)),
        r + i
    }
    decode(e, n=0) {
        const r = this.makeDestinationObject();
        if (this !== this.union.getVariant(e, n))
            throw new Error("variant mismatch");
        let i = 0;
        return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout ? r[this.property] = this.layout.decode(e, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant),
        r
    }
    encode(e, n, r=0) {
        let i = 0;
        if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout && !Object.prototype.hasOwnProperty.call(e, this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, n, r);
        let s = i;
        if (this.layout && (this.layout.encode(e[this.property], n, r + i),
        s += this.layout.getSpan(n, r + i),
        0 <= this.union.span && s > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return s
    }
    fromArray(e) {
        if (this.layout)
            return this.layout.fromArray(e)
    }
}
H.VariantLayout = Rx;
function Lo(t) {
    return 0 > t && (t += 4294967296),
    t
}
class Zm extends Ve {
    constructor(e, n, r) {
        if (!(e instanceof br || e instanceof Br))
            throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof n == "string" && r === void 0 && (r = n,
        n = !1),
        4 < e.span)
            throw new RangeError("word cannot exceed 32 bits");
        super(e.span, r),
        this.word = e,
        this.msb = !!n,
        this.fields = [];
        let i = 0;
        this._packedSetValue = function(s) {
            return i = Lo(s),
            this
        }
        ,
        this._packedGetValue = function() {
            return i
        }
    }
    decode(e, n=0) {
        const r = this.makeDestinationObject()
          , i = this.word.decode(e, n);
        this._packedSetValue(i);
        for (const s of this.fields)
            s.property !== void 0 && (r[s.property] = s.decode(e));
        return r
    }
    encode(e, n, r=0) {
        const i = this.word.decode(n, r);
        this._packedSetValue(i);
        for (const s of this.fields)
            if (s.property !== void 0) {
                const o = e[s.property];
                o !== void 0 && s.encode(o)
            }
        return this.word.encode(this._packedGetValue(), n, r)
    }
    addField(e, n) {
        const r = new Qm(this,e,n);
        return this.fields.push(r),
        r
    }
    addBoolean(e) {
        const n = new Lx(this,e);
        return this.fields.push(n),
        n
    }
    fieldFor(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        for (const n of this.fields)
            if (n.property === e)
                return n
    }
}
H.BitStructure = Zm;
class Qm {
    constructor(e, n, r) {
        if (!(e instanceof Zm))
            throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(n) || 0 >= n)
            throw new TypeError("bits must be positive integer");
        const i = 8 * e.span
          , s = e.fields.reduce( (o, a) => o + a.bits, 0);
        if (n + s > i)
            throw new Error("bits too long for span remainder (" + (i - s) + " of " + i + " remain)");
        this.container = e,
        this.bits = n,
        this.valueMask = (1 << n) - 1,
        n === 32 && (this.valueMask = 4294967295),
        this.start = s,
        this.container.msb && (this.start = i - s - n),
        this.wordMask = Lo(this.valueMask << this.start),
        this.property = r
    }
    decode(e, n) {
        const r = this.container._packedGetValue();
        return Lo(r & this.wordMask) >>> this.start
    }
    encode(e) {
        if (typeof e != "number" || !Number.isInteger(e) || e !== Lo(e & this.valueMask))
            throw new TypeError(Hm("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const n = this.container._packedGetValue()
          , r = Lo(e << this.start);
        this.container._packedSetValue(Lo(n & ~this.wordMask) | r)
    }
}
H.BitField = Qm;
let Lx = class extends Qm {
    constructor(e, n) {
        super(e, 1, n)
    }
    decode(e, n) {
        return !!super.decode(e, n)
    }
    encode(e) {
        typeof e == "boolean" && (e = +e),
        super.encode(e)
    }
}
;
H.Boolean = Lx;
let jx = class extends Ve {
    constructor(e, n) {
        if (!(e instanceof Vn && e.isCount() || Number.isInteger(e) && 0 <= e))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let r = -1;
        e instanceof Vn || (r = e),
        super(r, n),
        this.length = e
    }
    getSpan(e, n) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(e, n)),
        r
    }
    decode(e, n=0) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(e, n)),
        Ue(e).slice(n, n + r)
    }
    encode(e, n, r) {
        let i = this.length;
        if (this.length instanceof Vn && (i = e.length),
        !(e instanceof Uint8Array && i === e.length))
            throw new TypeError(Hm("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
        if (r + i > n.length)
            throw new RangeError("encoding overruns Uint8Array");
        const s = Ue(e);
        return Ue(n).write(s.toString("hex"), r, i, "hex"),
        this.length instanceof Vn && this.length.encode(i, n, r),
        i
    }
}
;
H.Blob = jx;
class Bx extends Ve {
    constructor(e) {
        super(-1, e)
    }
    getSpan(e, n=0) {
        Ua(e);
        let r = n;
        for (; r < e.length && e[r] !== 0; )
            r += 1;
        return 1 + r - n
    }
    decode(e, n=0) {
        const r = this.getSpan(e, n);
        return Ue(e).slice(n, n + r - 1).toString("utf-8")
    }
    encode(e, n, r=0) {
        typeof e != "string" && (e = String(e));
        const i = Vm.Buffer.from(e, "utf8")
          , s = i.length;
        if (r + s > n.length)
            throw new RangeError("encoding overruns Buffer");
        const o = Ue(n);
        return i.copy(o, r),
        o[r + s] = 0,
        s + 1
    }
}
H.CString = Bx;
class Px extends Ve {
    constructor(e, n) {
        if (typeof e == "string" && n === void 0 && (n = e,
        e = void 0),
        e === void 0)
            e = -1;
        else if (!Number.isInteger(e))
            throw new TypeError("maxSpan must be an integer");
        super(-1, n),
        this.maxSpan = e
    }
    getSpan(e, n=0) {
        return Ua(e),
        e.length - n
    }
    decode(e, n=0) {
        const r = this.getSpan(e, n);
        if (0 <= this.maxSpan && this.maxSpan < r)
            throw new RangeError("text length exceeds maxSpan");
        return Ue(e).slice(n, n + r).toString("utf-8")
    }
    encode(e, n, r=0) {
        typeof e != "string" && (e = String(e));
        const i = Vm.Buffer.from(e, "utf8")
          , s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s)
            throw new RangeError("text length exceeds maxSpan");
        if (r + s > n.length)
            throw new RangeError("encoding overruns Buffer");
        return i.copy(Ue(n), r),
        s
    }
}
H.UTF8 = Px;
class Ox extends Ve {
    constructor(e, n) {
        super(0, n),
        this.value = e
    }
    decode(e, n) {
        return this.value
    }
    encode(e, n, r) {
        return 0
    }
}
H.Constant = Ox;
H.greedy = (t, e) => new _x(t,e);
var ds = H.offset = (t, e, n) => new qm(t,e,n)
  , Pe = H.u8 = t => new br(1,t)
  , gr = H.u16 = t => new br(2,t);
H.u24 = t => new br(3,t);
var ue = H.u32 = t => new br(4,t);
H.u40 = t => new br(5,t);
H.u48 = t => new br(6,t);
var dn = H.nu64 = t => new xx(t);
H.u16be = t => new Br(2,t);
H.u24be = t => new Br(3,t);
H.u32be = t => new Br(4,t);
H.u40be = t => new Br(5,t);
H.u48be = t => new Br(6,t);
H.nu64be = t => new Sx(t);
H.s8 = t => new mo(1,t);
H.s16 = t => new mo(2,t);
H.s24 = t => new mo(3,t);
H.s32 = t => new mo(4,t);
H.s40 = t => new mo(5,t);
H.s48 = t => new mo(6,t);
var tr = H.ns64 = t => new kx(t);
H.s16be = t => new Wa(2,t);
H.s24be = t => new Wa(3,t);
H.s32be = t => new Wa(4,t);
H.s40be = t => new Wa(5,t);
H.s48be = t => new Wa(6,t);
H.ns64be = t => new Ex(t);
H.f32 = t => new Ax(t);
H.f32be = t => new Ix(t);
H.f64 = t => new Mx(t);
H.f64be = t => new Tx(t);
var de = H.struct = (t, e, n) => new Cx(t,e,n);
H.bits = (t, e, n) => new Zm(t,e,n);
var mn = H.seq = (t, e, n) => new Nx(t,e,n);
H.union = (t, e, n) => new Ym(t,e,n);
H.unionLayoutDiscriminator = (t, e) => new Dd(t,e);
var st = H.blob = (t, e) => new jx(t,e);
H.cstr = t => new Bx(t);
H.utf8 = (t, e) => new Px(t,e);
H.constant = (t, e) => new Ox(t,e);
var CI = 8078e3
  , RI = 8078001
  , LI = 8078004
  , jI = 8078005
  , BI = 8078006
  , PI = 8078011;
function Dx(t) {
    return Array.isArray(t) ? "%5B" + t.map(Dx).join("%2C%20") + "%5D" : typeof t == "bigint" ? `${t}n` : encodeURIComponent(String(t != null && Object.getPrototypeOf(t) === null ? {
        ...t
    } : t))
}
function OI([t,e]) {
    return `${t}=${Dx(e)}`
}
function DI(t) {
    const e = Object.entries(t).map(OI).join("&");
    return btoa(e)
}
function zI(t, e={}) {
    {
        let n = `Solana error #${t}; Decode this error by running \`npx @solana/errors decode -- ${t}`;
        return Object.keys(e).length && (n += ` '${DI(e)}'`),
        `${n}\``
    }
}
var da = class extends Error {
    cause = this.cause;
    context;
    constructor(...[t,e]) {
        let n, r;
        if (e) {
            const {cause: s, ...o} = e;
            s && (r = {
                cause: s
            }),
            Object.keys(o).length > 0 && (n = o)
        }
        const i = zI(t, n);
        super(i, r),
        this.context = {
            __code: t,
            ...n
        },
        this.name = "SolanaError"
    }
}
;
function UI(t, e) {
    return "fixedSize"in e ? e.fixedSize : e.getSizeFromValue(t)
}
function WI(t) {
    return Object.freeze({
        ...t,
        encode: e => {
            const n = new Uint8Array(UI(e, t));
            return t.write(e, n, 0),
            n
        }
    })
}
function FI(t) {
    return Object.freeze({
        ...t,
        decode: (e, n=0) => t.read(e, n)[0]
    })
}
function Io(t) {
    return "fixedSize"in t && typeof t.fixedSize == "number"
}
function $I(t, e) {
    if (Io(t) !== Io(e))
        throw new da(LI);
    if (Io(t) && Io(e) && t.fixedSize !== e.fixedSize)
        throw new da(jI,{
            decoderFixedSize: e.fixedSize,
            encoderFixedSize: t.fixedSize
        });
    if (!Io(t) && !Io(e) && t.maxSize !== e.maxSize)
        throw new da(BI,{
            decoderMaxSize: e.maxSize,
            encoderMaxSize: t.maxSize
        });
    return {
        ...e,
        ...t,
        decode: e.decode,
        encode: t.encode,
        read: e.read,
        write: t.write
    }
}
function KI(t, e, n=0) {
    if (e.length - n <= 0)
        throw new da(CI,{
            codecDescription: t
        })
}
function VI(t, e, n, r=0) {
    const i = n.length - r;
    if (i < e)
        throw new da(RI,{
            bytesLength: i,
            codecDescription: t,
            expected: e
        })
}
function HI(t, e, n, r) {
    if (r < e || r > n)
        throw new da(PI,{
            codecDescription: t,
            max: n,
            min: e,
            value: r
        })
}
function zx(t) {
    return t?.endian !== 1
}
function qI(t) {
    return WI({
        fixedSize: t.size,
        write(e, n, r) {
            t.range && HI(t.name, t.range[0], t.range[1], e);
            const i = new ArrayBuffer(t.size);
            return t.set(new DataView(i), e, zx(t.config)),
            n.set(new Uint8Array(i), r),
            r + t.size
        }
    })
}
function GI(t) {
    return FI({
        fixedSize: t.size,
        read(e, n=0) {
            KI(t.name, e, n),
            VI(t.name, t.size, e, n);
            const r = new DataView(YI(e, n, t.size));
            return [t.get(r, zx(t.config)), n + t.size]
        }
    })
}
function YI(t, e, n) {
    const r = t.byteOffset + (e ?? 0)
      , i = n ?? t.byteLength;
    return t.buffer.slice(r, r + i)
}
var Ux = (t={}) => qI({
    config: t,
    name: "u64",
    range: [0n, BigInt("0xffffffffffffffff")],
    set: (e, n, r) => e.setBigUint64(0, BigInt(n), r),
    size: 8
})
  , ZI = (t={}) => GI({
    config: t,
    get: (e, n) => e.getBigUint64(0, n),
    name: "u64",
    size: 8
})
  , QI = (t={}) => $I(Ux(t), ZI(t));
class JI extends TypeError {
    constructor(e, n) {
        let r;
        const {message: i, explanation: s, ...o} = e
          , {path: a} = e
          , l = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
        super(s ?? l),
        s != null && (this.cause = l),
        Object.assign(this, o),
        this.name = this.constructor.name,
        this.failures = () => r ?? (r = [e, ...n()])
    }
}
function XI(t) {
    return _c(t) && typeof t[Symbol.iterator] == "function"
}
function _c(t) {
    return typeof t == "object" && t != null
}
function zd(t) {
    return _c(t) && !Array.isArray(t)
}
function Or(t) {
    return typeof t == "symbol" ? t.toString() : typeof t == "string" ? JSON.stringify(t) : `${t}`
}
function eM(t) {
    const {done: e, value: n} = t.next();
    return e ? void 0 : n
}
function tM(t, e, n, r) {
    if (t === !0)
        return;
    t === !1 ? t = {} : typeof t == "string" && (t = {
        message: t
    });
    const {path: i, branch: s} = e
      , {type: o} = n
      , {refinement: a, message: l=`Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${Or(r)}\``} = t;
    return {
        value: r,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s,
        ...t,
        message: l
    }
}
function *d1(t, e, n, r) {
    XI(t) || (t = [t]);
    for (const i of t) {
        const s = tM(i, e, n, r);
        s && (yield s)
    }
}
function *Jm(t, e, n={}) {
    const {path: r=[], branch: i=[t], coerce: s=!1, mask: o=!1} = n
      , a = {
        path: r,
        branch: i,
        mask: o
    };
    s && (t = e.coercer(t, a));
    let l = "valid";
    for (const c of e.validator(t, a))
        c.explanation = n.message,
        l = "not_valid",
        yield[c, void 0];
    for (let[c,d,h] of e.entries(t, a)) {
        const y = Jm(d, h, {
            path: c === void 0 ? r : [...r, c],
            branch: c === void 0 ? i : [...i, d],
            coerce: s,
            mask: o,
            message: n.message
        });
        for (const m of y)
            m[0] ? (l = m[0].refinement != null ? "not_refined" : "not_valid",
            yield[m[0], void 0]) : s && (d = m[1],
            c === void 0 ? t = d : t instanceof Map ? t.set(c, d) : t instanceof Set ? t.add(d) : _c(t) && (d !== void 0 || c in t) && (t[c] = d))
    }
    if (l !== "not_valid")
        for (const c of e.refiner(t, a))
            c.explanation = n.message,
            l = "not_refined",
            yield[c, void 0];
    l === "valid" && (yield[void 0, t])
}
let si = class {
    constructor(e) {
        const {type: n, schema: r, validator: i, refiner: s, coercer: o=l => l, entries: a=function*() {}
        } = e;
        this.type = n,
        this.schema = r,
        this.entries = a,
        this.coercer = o,
        i ? this.validator = (l, c) => {
            const d = i(l, c);
            return d1(d, c, this, l)
        }
        : this.validator = () => [],
        s ? this.refiner = (l, c) => {
            const d = s(l, c);
            return d1(d, c, this, l)
        }
        : this.refiner = () => []
    }
    assert(e, n) {
        return Wx(e, this, n)
    }
    create(e, n) {
        return se(e, this, n)
    }
    is(e) {
        return Fx(e, this)
    }
    mask(e, n) {
        return nM(e, this, n)
    }
    validate(e, n={}) {
        return xc(e, this, n)
    }
}
;
function Wx(t, e, n) {
    const r = xc(t, e, {
        message: n
    });
    if (r[0])
        throw r[0]
}
function se(t, e, n) {
    const r = xc(t, e, {
        coerce: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function nM(t, e, n) {
    const r = xc(t, e, {
        coerce: !0,
        mask: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function Fx(t, e) {
    return !xc(t, e)[0]
}
function xc(t, e, n={}) {
    const r = Jm(t, e, n)
      , i = eM(r);
    return i[0] ? [new JI(i[0],function*() {
        for (const o of r)
            o[0] && (yield o[0])
    }
    ), void 0] : [void 0, i[1]]
}
function yo(t, e) {
    return new si({
        type: t,
        schema: null,
        validator: e
    })
}
function rM() {
    return yo("any", () => !0)
}
function ae(t) {
    return new si({
        type: "array",
        schema: t,
        *entries(e) {
            if (t && Array.isArray(e))
                for (const [n,r] of e.entries())
                    yield[n, r, t]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || `Expected an array value, but received: ${Or(e)}`
        }
    })
}
function ni() {
    return yo("boolean", t => typeof t == "boolean")
}
function Xm(t) {
    return yo("instance", e => e instanceof t || `Expected a \`${t.name}\` instance, but received: ${Or(e)}`)
}
function pt(t) {
    const e = Or(t)
      , n = typeof t;
    return new si({
        type: "literal",
        schema: n === "string" || n === "number" || n === "boolean" ? t : null,
        validator(r) {
            return r === t || `Expected the literal \`${e}\`, but received: ${Or(r)}`
        }
    })
}
function iM() {
    return yo("never", () => !1)
}
function le(t) {
    return new si({
        ...t,
        validator: (e, n) => e === null || t.validator(e, n),
        refiner: (e, n) => e === null || t.refiner(e, n)
    })
}
function V() {
    return yo("number", t => typeof t == "number" && !isNaN(t) || `Expected a number, but received: ${Or(t)}`)
}
function ge(t) {
    return new si({
        ...t,
        validator: (e, n) => e === void 0 || t.validator(e, n),
        refiner: (e, n) => e === void 0 || t.refiner(e, n)
    })
}
function $x(t, e) {
    return new si({
        type: "record",
        schema: null,
        *entries(n) {
            if (_c(n))
                for (const r in n) {
                    const i = n[r];
                    yield[r, r, t],
                    yield[r, i, e]
                }
        },
        validator(n) {
            return zd(n) || `Expected an object, but received: ${Or(n)}`
        },
        coercer(n) {
            return zd(n) ? {
                ...n
            } : n
        }
    })
}
function re() {
    return yo("string", t => typeof t == "string" || `Expected a string, but received: ${Or(t)}`)
}
function ey(t) {
    const e = iM();
    return new si({
        type: "tuple",
        schema: null,
        *entries(n) {
            if (Array.isArray(n)) {
                const r = Math.max(t.length, n.length);
                for (let i = 0; i < r; i++)
                    yield[i, n[i], t[i] || e]
            }
        },
        validator(n) {
            return Array.isArray(n) || `Expected an array, but received: ${Or(n)}`
        },
        coercer(n) {
            return Array.isArray(n) ? n.slice() : n
        }
    })
}
function Q(t) {
    const e = Object.keys(t);
    return new si({
        type: "type",
        schema: t,
        *entries(n) {
            if (_c(n))
                for (const r of e)
                    yield[r, n[r], t[r]]
        },
        validator(n) {
            return zd(n) || `Expected an object, but received: ${Or(n)}`
        },
        coercer(n) {
            return zd(n) ? {
                ...n
            } : n
        }
    })
}
function On(t) {
    const e = t.map(n => n.type).join(" | ");
    return new si({
        type: "union",
        schema: null,
        coercer(n, r) {
            for (const i of t) {
                const [s,o] = i.validate(n, {
                    coerce: !0,
                    mask: r.mask
                });
                if (!s)
                    return o
            }
            return n
        },
        validator(n, r) {
            const i = [];
            for (const s of t) {
                const [...o] = Jm(n, s, r)
                  , [a] = o;
                if (a[0])
                    for (const [l] of o)
                        l && i.push(l);
                else
                    return []
            }
            return [`Expected the value to satisfy a union of \`${e}\`, but received: ${Or(n)}`, ...i]
        }
    })
}
function Fa() {
    return yo("unknown", () => !0)
}
function Sc(t, e, n) {
    return new si({
        ...t,
        coercer: (r, i) => Fx(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)
    })
}
var ou, sM = new Uint8Array(16);
function Kx() {
    if (!ou && (ou = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !ou))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return ou(sM)
}
const oM = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function Eh(t) {
    return typeof t == "string" && oM.test(t)
}
var un = [];
for (var e0 = 0; e0 < 256; ++e0)
    un.push((e0 + 256).toString(16).substr(1));
function Ah(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , n = (un[t[e + 0]] + un[t[e + 1]] + un[t[e + 2]] + un[t[e + 3]] + "-" + un[t[e + 4]] + un[t[e + 5]] + "-" + un[t[e + 6]] + un[t[e + 7]] + "-" + un[t[e + 8]] + un[t[e + 9]] + "-" + un[t[e + 10]] + un[t[e + 11]] + un[t[e + 12]] + un[t[e + 13]] + un[t[e + 14]] + un[t[e + 15]]).toLowerCase();
    if (!Eh(n))
        throw TypeError("Stringified UUID is invalid");
    return n
}
var h1, t0, n0 = 0, r0 = 0;
function aM(t, e, n) {
    var r = e && n || 0
      , i = e || new Array(16);
    t = t || {};
    var s = t.node || h1
      , o = t.clockseq !== void 0 ? t.clockseq : t0;
    if (s == null || o == null) {
        var a = t.random || (t.rng || Kx)();
        s == null && (s = h1 = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
        o == null && (o = t0 = (a[6] << 8 | a[7]) & 16383)
    }
    var l = t.msecs !== void 0 ? t.msecs : Date.now()
      , c = t.nsecs !== void 0 ? t.nsecs : r0 + 1
      , d = l - n0 + (c - r0) / 1e4;
    if (d < 0 && t.clockseq === void 0 && (o = o + 1 & 16383),
    (d < 0 || l > n0) && t.nsecs === void 0 && (c = 0),
    c >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    n0 = l,
    r0 = c,
    t0 = o,
    l += 122192928e5;
    var h = ((l & 268435455) * 1e4 + c) % 4294967296;
    i[r++] = h >>> 24 & 255,
    i[r++] = h >>> 16 & 255,
    i[r++] = h >>> 8 & 255,
    i[r++] = h & 255;
    var y = l / 4294967296 * 1e4 & 268435455;
    i[r++] = y >>> 8 & 255,
    i[r++] = y & 255,
    i[r++] = y >>> 24 & 15 | 16,
    i[r++] = y >>> 16 & 255,
    i[r++] = o >>> 8 | 128,
    i[r++] = o & 255;
    for (var m = 0; m < 6; ++m)
        i[r + m] = s[m];
    return e || Ah(i)
}
function Vx(t) {
    if (!Eh(t))
        throw TypeError("Invalid UUID");
    var e, n = new Uint8Array(16);
    return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24,
    n[1] = e >>> 16 & 255,
    n[2] = e >>> 8 & 255,
    n[3] = e & 255,
    n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8,
    n[5] = e & 255,
    n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8,
    n[7] = e & 255,
    n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8,
    n[9] = e & 255,
    n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255,
    n[11] = e / 4294967296 & 255,
    n[12] = e >>> 24 & 255,
    n[13] = e >>> 16 & 255,
    n[14] = e >>> 8 & 255,
    n[15] = e & 255,
    n
}
function lM(t) {
    t = unescape(encodeURIComponent(t));
    for (var e = [], n = 0; n < t.length; ++n)
        e.push(t.charCodeAt(n));
    return e
}
var cM = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
  , uM = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Hx(t, e, n) {
    function r(i, s, o, a) {
        if (typeof i == "string" && (i = lM(i)),
        typeof s == "string" && (s = Vx(s)),
        s.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var l = new Uint8Array(16 + i.length);
        if (l.set(s),
        l.set(i, s.length),
        l = n(l),
        l[6] = l[6] & 15 | e,
        l[8] = l[8] & 63 | 128,
        o) {
            a = a || 0;
            for (var c = 0; c < 16; ++c)
                o[a + c] = l[c];
            return o
        }
        return Ah(l)
    }
    try {
        r.name = t
    } catch {}
    return r.DNS = cM,
    r.URL = uM,
    r
}
function dM(t) {
    if (typeof t == "string") {
        var e = unescape(encodeURIComponent(t));
        t = new Uint8Array(e.length);
        for (var n = 0; n < e.length; ++n)
            t[n] = e.charCodeAt(n)
    }
    return hM(fM(pM(t), t.length * 8))
}
function hM(t) {
    for (var e = [], n = t.length * 32, r = "0123456789abcdef", i = 0; i < n; i += 8) {
        var s = t[i >> 5] >>> i % 32 & 255
          , o = parseInt(r.charAt(s >>> 4 & 15) + r.charAt(s & 15), 16);
        e.push(o)
    }
    return e
}
function qx(t) {
    return (t + 64 >>> 9 << 4) + 14 + 1
}
function fM(t, e) {
    t[e >> 5] |= 128 << e % 32,
    t[qx(e) - 1] = e;
    for (var n = 1732584193, r = -271733879, i = -1732584194, s = 271733878, o = 0; o < t.length; o += 16) {
        var a = n
          , l = r
          , c = i
          , d = s;
        n = Sn(n, r, i, s, t[o], 7, -680876936),
        s = Sn(s, n, r, i, t[o + 1], 12, -389564586),
        i = Sn(i, s, n, r, t[o + 2], 17, 606105819),
        r = Sn(r, i, s, n, t[o + 3], 22, -1044525330),
        n = Sn(n, r, i, s, t[o + 4], 7, -176418897),
        s = Sn(s, n, r, i, t[o + 5], 12, 1200080426),
        i = Sn(i, s, n, r, t[o + 6], 17, -1473231341),
        r = Sn(r, i, s, n, t[o + 7], 22, -45705983),
        n = Sn(n, r, i, s, t[o + 8], 7, 1770035416),
        s = Sn(s, n, r, i, t[o + 9], 12, -1958414417),
        i = Sn(i, s, n, r, t[o + 10], 17, -42063),
        r = Sn(r, i, s, n, t[o + 11], 22, -1990404162),
        n = Sn(n, r, i, s, t[o + 12], 7, 1804603682),
        s = Sn(s, n, r, i, t[o + 13], 12, -40341101),
        i = Sn(i, s, n, r, t[o + 14], 17, -1502002290),
        r = Sn(r, i, s, n, t[o + 15], 22, 1236535329),
        n = kn(n, r, i, s, t[o + 1], 5, -165796510),
        s = kn(s, n, r, i, t[o + 6], 9, -1069501632),
        i = kn(i, s, n, r, t[o + 11], 14, 643717713),
        r = kn(r, i, s, n, t[o], 20, -373897302),
        n = kn(n, r, i, s, t[o + 5], 5, -701558691),
        s = kn(s, n, r, i, t[o + 10], 9, 38016083),
        i = kn(i, s, n, r, t[o + 15], 14, -660478335),
        r = kn(r, i, s, n, t[o + 4], 20, -405537848),
        n = kn(n, r, i, s, t[o + 9], 5, 568446438),
        s = kn(s, n, r, i, t[o + 14], 9, -1019803690),
        i = kn(i, s, n, r, t[o + 3], 14, -187363961),
        r = kn(r, i, s, n, t[o + 8], 20, 1163531501),
        n = kn(n, r, i, s, t[o + 13], 5, -1444681467),
        s = kn(s, n, r, i, t[o + 2], 9, -51403784),
        i = kn(i, s, n, r, t[o + 7], 14, 1735328473),
        r = kn(r, i, s, n, t[o + 12], 20, -1926607734),
        n = En(n, r, i, s, t[o + 5], 4, -378558),
        s = En(s, n, r, i, t[o + 8], 11, -2022574463),
        i = En(i, s, n, r, t[o + 11], 16, 1839030562),
        r = En(r, i, s, n, t[o + 14], 23, -35309556),
        n = En(n, r, i, s, t[o + 1], 4, -1530992060),
        s = En(s, n, r, i, t[o + 4], 11, 1272893353),
        i = En(i, s, n, r, t[o + 7], 16, -155497632),
        r = En(r, i, s, n, t[o + 10], 23, -1094730640),
        n = En(n, r, i, s, t[o + 13], 4, 681279174),
        s = En(s, n, r, i, t[o], 11, -358537222),
        i = En(i, s, n, r, t[o + 3], 16, -722521979),
        r = En(r, i, s, n, t[o + 6], 23, 76029189),
        n = En(n, r, i, s, t[o + 9], 4, -640364487),
        s = En(s, n, r, i, t[o + 12], 11, -421815835),
        i = En(i, s, n, r, t[o + 15], 16, 530742520),
        r = En(r, i, s, n, t[o + 2], 23, -995338651),
        n = An(n, r, i, s, t[o], 6, -198630844),
        s = An(s, n, r, i, t[o + 7], 10, 1126891415),
        i = An(i, s, n, r, t[o + 14], 15, -1416354905),
        r = An(r, i, s, n, t[o + 5], 21, -57434055),
        n = An(n, r, i, s, t[o + 12], 6, 1700485571),
        s = An(s, n, r, i, t[o + 3], 10, -1894986606),
        i = An(i, s, n, r, t[o + 10], 15, -1051523),
        r = An(r, i, s, n, t[o + 1], 21, -2054922799),
        n = An(n, r, i, s, t[o + 8], 6, 1873313359),
        s = An(s, n, r, i, t[o + 15], 10, -30611744),
        i = An(i, s, n, r, t[o + 6], 15, -1560198380),
        r = An(r, i, s, n, t[o + 13], 21, 1309151649),
        n = An(n, r, i, s, t[o + 4], 6, -145523070),
        s = An(s, n, r, i, t[o + 11], 10, -1120210379),
        i = An(i, s, n, r, t[o + 2], 15, 718787259),
        r = An(r, i, s, n, t[o + 9], 21, -343485551),
        n = es(n, a),
        r = es(r, l),
        i = es(i, c),
        s = es(s, d)
    }
    return [n, r, i, s]
}
function pM(t) {
    if (t.length === 0)
        return [];
    for (var e = t.length * 8, n = new Uint32Array(qx(e)), r = 0; r < e; r += 8)
        n[r >> 5] |= (t[r / 8] & 255) << r % 32;
    return n
}
function es(t, e) {
    var n = (t & 65535) + (e & 65535)
      , r = (t >> 16) + (e >> 16) + (n >> 16);
    return r << 16 | n & 65535
}
function gM(t, e) {
    return t << e | t >>> 32 - e
}
function Ih(t, e, n, r, i, s) {
    return es(gM(es(es(e, t), es(r, s)), i), n)
}
function Sn(t, e, n, r, i, s, o) {
    return Ih(e & n | ~e & r, t, e, i, s, o)
}
function kn(t, e, n, r, i, s, o) {
    return Ih(e & r | n & ~r, t, e, i, s, o)
}
function En(t, e, n, r, i, s, o) {
    return Ih(e ^ n ^ r, t, e, i, s, o)
}
function An(t, e, n, r, i, s, o) {
    return Ih(n ^ (e | ~r), t, e, i, s, o)
}
var mM = Hx("v3", 48, dM);
const yM = mM;
function wM(t, e, n) {
    t = t || {};
    var r = t.random || (t.rng || Kx)();
    if (r[6] = r[6] & 15 | 64,
    r[8] = r[8] & 63 | 128,
    e) {
        n = n || 0;
        for (var i = 0; i < 16; ++i)
            e[n + i] = r[i];
        return e
    }
    return Ah(r)
}
function vM(t, e, n, r) {
    switch (t) {
    case 0:
        return e & n ^ ~e & r;
    case 1:
        return e ^ n ^ r;
    case 2:
        return e & n ^ e & r ^ n & r;
    case 3:
        return e ^ n ^ r
    }
}
function i0(t, e) {
    return t << e | t >>> 32 - e
}
function bM(t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782]
      , n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof t == "string") {
        var r = unescape(encodeURIComponent(t));
        t = [];
        for (var i = 0; i < r.length; ++i)
            t.push(r.charCodeAt(i))
    } else
        Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (var s = t.length / 4 + 2, o = Math.ceil(s / 16), a = new Array(o), l = 0; l < o; ++l) {
        for (var c = new Uint32Array(16), d = 0; d < 16; ++d)
            c[d] = t[l * 64 + d * 4] << 24 | t[l * 64 + d * 4 + 1] << 16 | t[l * 64 + d * 4 + 2] << 8 | t[l * 64 + d * 4 + 3];
        a[l] = c
    }
    a[o - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32),
    a[o - 1][14] = Math.floor(a[o - 1][14]),
    a[o - 1][15] = (t.length - 1) * 8 & 4294967295;
    for (var h = 0; h < o; ++h) {
        for (var y = new Uint32Array(80), m = 0; m < 16; ++m)
            y[m] = a[h][m];
        for (var v = 16; v < 80; ++v)
            y[v] = i0(y[v - 3] ^ y[v - 8] ^ y[v - 14] ^ y[v - 16], 1);
        for (var E = n[0], A = n[1], _ = n[2], x = n[3], b = n[4], R = 0; R < 80; ++R) {
            var O = Math.floor(R / 20)
              , D = i0(E, 5) + vM(O, A, _, x) + b + e[O] + y[R] >>> 0;
            b = x,
            x = _,
            _ = i0(A, 30) >>> 0,
            A = E,
            E = D
        }
        n[0] = n[0] + E >>> 0,
        n[1] = n[1] + A >>> 0,
        n[2] = n[2] + _ >>> 0,
        n[3] = n[3] + x >>> 0,
        n[4] = n[4] + b >>> 0
    }
    return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255]
}
var _M = Hx("v5", 80, bM);
const xM = _M
  , SM = "00000000-0000-0000-0000-000000000000";
function kM(t) {
    if (!Eh(t))
        throw TypeError("Invalid UUID");
    return parseInt(t.substr(14, 1), 16)
}
const EM = Object.freeze(Object.defineProperty({
    __proto__: null,
    NIL: SM,
    parse: Vx,
    stringify: Ah,
    v1: aM,
    v3: yM,
    v4: wM,
    v5: xM,
    validate: Eh,
    version: kM
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Gx = ms(EM)
  , AM = Gx.v4
  , IM = function(t, e, n, r) {
    if (typeof t != "string")
        throw new TypeError(t + " must be a string");
    r = r || {};
    const i = typeof r.version == "number" ? r.version : 2;
    if (i !== 1 && i !== 2)
        throw new TypeError(i + " must be 1 or 2");
    const s = {
        method: t
    };
    if (i === 2 && (s.jsonrpc = "2.0"),
    e) {
        if (typeof e != "object" && !Array.isArray(e))
            throw new TypeError(e + " must be an object, array or omitted");
        s.params = e
    }
    if (typeof n > "u") {
        const o = typeof r.generator == "function" ? r.generator : function() {
            return AM()
        }
        ;
        s.id = o(s, r)
    } else
        i === 2 && n === null ? r.notificationIdNull && (s.id = null) : s.id = n;
    return s
};
var MM = IM;
const TM = Gx.v4
  , NM = MM
  , rc = function(t, e) {
    if (!(this instanceof rc))
        return new rc(t,e);
    e || (e = {}),
    this.options = {
        reviver: typeof e.reviver < "u" ? e.reviver : null,
        replacer: typeof e.replacer < "u" ? e.replacer : null,
        generator: typeof e.generator < "u" ? e.generator : function() {
            return TM()
        }
        ,
        version: typeof e.version < "u" ? e.version : 2,
        notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
    },
    this.callServer = t
};
var CM = rc;
rc.prototype.request = function(t, e, n, r) {
    const i = this;
    let s = null;
    const o = Array.isArray(t) && typeof e == "function";
    if (this.options.version === 1 && o)
        throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (o || !o && t && typeof t == "object" && typeof e == "function")
        r = e,
        s = t;
    else {
        typeof n == "function" && (r = n,
        n = void 0);
        const c = typeof r == "function";
        try {
            s = NM(t, e, n, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (d) {
            if (c)
                return r(d);
            throw d
        }
        if (!c)
            return s
    }
    let l;
    try {
        l = JSON.stringify(s, this.options.replacer)
    } catch (c) {
        return r(c)
    }
    return this.callServer(l, function(c, d) {
        i._parseResponse(c, d, r)
    }),
    s
}
;
rc.prototype._parseResponse = function(t, e, n) {
    if (t) {
        n(t);
        return
    }
    if (!e)
        return n();
    let r;
    try {
        r = JSON.parse(e, this.options.reviver)
    } catch (i) {
        return n(i)
    }
    if (n.length === 3)
        if (Array.isArray(r)) {
            const i = function(o) {
                return typeof o.error < "u"
            }
              , s = function(o) {
                return !i(o)
            };
            return n(null, r.filter(i), r.filter(s))
        } else
            return n(null, r.error, r.result);
    n(null, r)
}
;
const RM = ho(CM);
var Yx = {
    exports: {}
};
(function(t) {
    var e = Object.prototype.hasOwnProperty
      , n = "~";
    function r() {}
    Object.create && (r.prototype = Object.create(null),
    new r().__proto__ || (n = !1));
    function i(l, c, d) {
        this.fn = l,
        this.context = c,
        this.once = d || !1
    }
    function s(l, c, d, h, y) {
        if (typeof d != "function")
            throw new TypeError("The listener must be a function");
        var m = new i(d,h || l,y)
          , v = n ? n + c : c;
        return l._events[v] ? l._events[v].fn ? l._events[v] = [l._events[v], m] : l._events[v].push(m) : (l._events[v] = m,
        l._eventsCount++),
        l
    }
    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new r : delete l._events[c]
    }
    function a() {
        this._events = new r,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], d, h;
        if (this._eventsCount === 0)
            return c;
        for (h in d = this._events)
            e.call(d, h) && c.push(n ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(d)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var d = n ? n + c : c
          , h = this._events[d];
        if (!h)
            return [];
        if (h.fn)
            return [h.fn];
        for (var y = 0, m = h.length, v = new Array(m); y < m; y++)
            v[y] = h[y].fn;
        return v
    }
    ,
    a.prototype.listenerCount = function(c) {
        var d = n ? n + c : c
          , h = this._events[d];
        return h ? h.fn ? 1 : h.length : 0
    }
    ,
    a.prototype.emit = function(c, d, h, y, m, v) {
        var E = n ? n + c : c;
        if (!this._events[E])
            return !1;
        var A = this._events[E], _ = arguments.length, x, b;
        if (A.fn) {
            switch (A.once && this.removeListener(c, A.fn, void 0, !0),
            _) {
            case 1:
                return A.fn.call(A.context),
                !0;
            case 2:
                return A.fn.call(A.context, d),
                !0;
            case 3:
                return A.fn.call(A.context, d, h),
                !0;
            case 4:
                return A.fn.call(A.context, d, h, y),
                !0;
            case 5:
                return A.fn.call(A.context, d, h, y, m),
                !0;
            case 6:
                return A.fn.call(A.context, d, h, y, m, v),
                !0
            }
            for (b = 1,
            x = new Array(_ - 1); b < _; b++)
                x[b - 1] = arguments[b];
            A.fn.apply(A.context, x)
        } else {
            var R = A.length, O;
            for (b = 0; b < R; b++)
                switch (A[b].once && this.removeListener(c, A[b].fn, void 0, !0),
                _) {
                case 1:
                    A[b].fn.call(A[b].context);
                    break;
                case 2:
                    A[b].fn.call(A[b].context, d);
                    break;
                case 3:
                    A[b].fn.call(A[b].context, d, h);
                    break;
                case 4:
                    A[b].fn.call(A[b].context, d, h, y);
                    break;
                default:
                    if (!x)
                        for (O = 1,
                        x = new Array(_ - 1); O < _; O++)
                            x[O - 1] = arguments[O];
                    A[b].fn.apply(A[b].context, x)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, d, h) {
        return s(this, c, d, h, !1)
    }
    ,
    a.prototype.once = function(c, d, h) {
        return s(this, c, d, h, !0)
    }
    ,
    a.prototype.removeListener = function(c, d, h, y) {
        var m = n ? n + c : c;
        if (!this._events[m])
            return this;
        if (!d)
            return o(this, m),
            this;
        var v = this._events[m];
        if (v.fn)
            v.fn === d && (!y || v.once) && (!h || v.context === h) && o(this, m);
        else {
            for (var E = 0, A = [], _ = v.length; E < _; E++)
                (v[E].fn !== d || y && !v[E].once || h && v[E].context !== h) && A.push(v[E]);
            A.length ? this._events[m] = A.length === 1 ? A[0] : A : o(this, m)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var d;
        return c ? (d = n ? n + c : c,
        this._events[d] && o(this, d)) : (this._events = new r,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = n,
    a.EventEmitter = a,
    t.exports = a
}
)(Yx);
var LM = Yx.exports;
const Zx = ho(LM);
var jM = class extends Zx {
    socket;
    constructor(t, e, n) {
        super(),
        this.socket = new window.WebSocket(t,n),
        this.socket.onopen = () => this.emit("open"),
        this.socket.onmessage = r => this.emit("message", r.data),
        this.socket.onerror = r => this.emit("error", r),
        this.socket.onclose = r => {
            this.emit("close", r.code, r.reason)
        }
    }
    send(t, e, n) {
        const r = n || e;
        try {
            this.socket.send(t),
            r()
        } catch (i) {
            r(i)
        }
    }
    close(t, e) {
        this.socket.close(t, e)
    }
    addEventListener(t, e, n) {
        this.socket.addEventListener(t, e, n)
    }
}
;
function BM(t, e) {
    return new jM(t,e)
}
var PM = class {
    encode(t) {
        return JSON.stringify(t)
    }
    decode(t) {
        return JSON.parse(t)
    }
}
  , OM = class extends Zx {
    address;
    rpc_id;
    queue;
    options;
    autoconnect;
    ready;
    reconnect;
    reconnect_timer_id;
    reconnect_interval;
    max_reconnects;
    rest_options;
    current_reconnects;
    generate_request_id;
    socket;
    webSocketFactory;
    dataPack;
    constructor(t, e="ws://localhost:8080", {autoconnect: n=!0, reconnect: r=!0, reconnect_interval: i=1e3, max_reconnects: s=5, ...o}={}, a, l) {
        super(),
        this.webSocketFactory = t,
        this.queue = {},
        this.rpc_id = 0,
        this.address = e,
        this.autoconnect = n,
        this.ready = !1,
        this.reconnect = r,
        this.reconnect_timer_id = void 0,
        this.reconnect_interval = i,
        this.max_reconnects = s,
        this.rest_options = o,
        this.current_reconnects = 0,
        this.generate_request_id = a || ( () => typeof this.rpc_id == "number" ? ++this.rpc_id : Number(this.rpc_id) + 1),
        l ? this.dataPack = l : this.dataPack = new PM,
        this.autoconnect && this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    connect() {
        this.socket || this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    call(t, e, n, r) {
        return !r && typeof n == "object" && (r = n,
        n = null),
        new Promise( (i, s) => {
            if (!this.ready)
                return s(new Error("socket not ready"));
            const o = this.generate_request_id(t, e)
              , a = {
                jsonrpc: "2.0",
                method: t,
                params: e || void 0,
                id: o
            };
            this.socket.send(this.dataPack.encode(a), r, l => {
                if (l)
                    return s(l);
                this.queue[o] = {
                    promise: [i, s]
                },
                n && (this.queue[o].timeout = setTimeout( () => {
                    delete this.queue[o],
                    s(new Error("reply timeout"))
                }
                , n))
            }
            )
        }
        )
    }
    async login(t) {
        const e = await this.call("rpc.login", t);
        if (!e)
            throw new Error("authentication failed");
        return e
    }
    async listMethods() {
        return await this.call("__listMethods")
    }
    notify(t, e) {
        return new Promise( (n, r) => {
            if (!this.ready)
                return r(new Error("socket not ready"));
            const i = {
                jsonrpc: "2.0",
                method: t,
                params: e
            };
            this.socket.send(this.dataPack.encode(i), s => {
                if (s)
                    return r(s);
                n()
            }
            )
        }
        )
    }
    async subscribe(t) {
        typeof t == "string" && (t = [t]);
        const e = await this.call("rpc.on", t);
        if (typeof t == "string" && e[t] !== "ok")
            throw new Error("Failed subscribing to an event '" + t + "' with: " + e[t]);
        return e
    }
    async unsubscribe(t) {
        typeof t == "string" && (t = [t]);
        const e = await this.call("rpc.off", t);
        if (typeof t == "string" && e[t] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + e);
        return e
    }
    close(t, e) {
        this.socket.close(t || 1e3, e)
    }
    setAutoReconnect(t) {
        this.reconnect = t
    }
    setReconnectInterval(t) {
        this.reconnect_interval = t
    }
    setMaxReconnects(t) {
        this.max_reconnects = t
    }
    _connect(t, e) {
        clearTimeout(this.reconnect_timer_id),
        this.socket = this.webSocketFactory(t, e),
        this.socket.addEventListener("open", () => {
            this.ready = !0,
            this.emit("open"),
            this.current_reconnects = 0
        }
        ),
        this.socket.addEventListener("message", ({data: n}) => {
            n instanceof ArrayBuffer && (n = pe.Buffer.from(n).toString());
            try {
                n = this.dataPack.decode(n)
            } catch {
                return
            }
            if (n.notification && this.listeners(n.notification).length) {
                if (!Object.keys(n.params).length)
                    return this.emit(n.notification);
                const r = [n.notification];
                if (n.params.constructor === Object)
                    r.push(n.params);
                else
                    for (let i = 0; i < n.params.length; i++)
                        r.push(n.params[i]);
                return Promise.resolve().then( () => {
                    this.emit.apply(this, r)
                }
                )
            }
            if (!this.queue[n.id])
                return n.method ? Promise.resolve().then( () => {
                    this.emit(n.method, n?.params)
                }
                ) : void 0;
            "error"in n == "result"in n && this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
            this.queue[n.id].timeout && clearTimeout(this.queue[n.id].timeout),
            n.error ? this.queue[n.id].promise[1](n.error) : this.queue[n.id].promise[0](n.result),
            delete this.queue[n.id]
        }
        ),
        this.socket.addEventListener("error", n => this.emit("error", n)),
        this.socket.addEventListener("close", ({code: n, reason: r}) => {
            this.ready && setTimeout( () => this.emit("close", n, r), 0),
            this.ready = !1,
            this.socket = void 0,
            n !== 1e3 && (this.current_reconnects++,
            this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout( () => this._connect(t, e), this.reconnect_interval)))
        }
        )
    }
}
;
const DM = BigInt(0)
  , tl = BigInt(1)
  , zM = BigInt(2)
  , UM = BigInt(7)
  , WM = BigInt(256)
  , FM = BigInt(113)
  , Qx = []
  , Jx = []
  , Xx = [];
for (let t = 0, e = tl, n = 1, r = 0; t < 24; t++) {
    [n,r] = [r, (2 * n + 3 * r) % 5],
    Qx.push(2 * (5 * r + n)),
    Jx.push((t + 1) * (t + 2) / 2 % 64);
    let i = DM;
    for (let s = 0; s < 7; s++)
        e = (e << tl ^ (e >> UM) * FM) % WM,
        e & zM && (i ^= tl << (tl << BigInt(s)) - tl);
    Xx.push(i)
}
const eS = F_(Xx, !0)
  , $M = eS[0]
  , KM = eS[1]
  , f1 = (t, e, n) => n > 32 ? u4(t, e, n) : l4(t, e, n)
  , p1 = (t, e, n) => n > 32 ? d4(t, e, n) : c4(t, e, n);
function VM(t, e=24) {
    const n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++)
            n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10
              , l = (o + 2) % 10
              , c = n[l]
              , d = n[l + 1]
              , h = f1(c, d, 1) ^ n[a]
              , y = p1(c, d, 1) ^ n[a + 1];
            for (let m = 0; m < 50; m += 10)
                t[o + m] ^= h,
                t[o + m + 1] ^= y
        }
        let i = t[2]
          , s = t[3];
        for (let o = 0; o < 24; o++) {
            const a = Jx[o]
              , l = f1(i, s, a)
              , c = p1(i, s, a)
              , d = Qx[o];
            i = t[d],
            s = t[d + 1],
            t[d] = l,
            t[d + 1] = c
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++)
                n[a] = t[o + a];
            for (let a = 0; a < 10; a++)
                t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
        }
        t[0] ^= $M[r],
        t[1] ^= KM[r]
    }
    gs(n)
}
class ty extends Bm {
    constructor(e, n, r, i=!1, s=24) {
        if (super(),
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        this.enableXOF = !1,
        this.blockLen = e,
        this.suffix = n,
        this.outputLen = r,
        this.enableXOF = i,
        this.rounds = s,
        tc(r),
        !(0 < e && e < 200))
            throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200),
        this.state32 = JA(this.state)
    }
    clone() {
        return this._cloneInto()
    }
    keccak() {
        Zw(this.state32),
        VM(this.state32, this.rounds),
        Zw(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        ka(this),
        e = bh(e),
        Ci(e);
        const {blockLen: n, state: r} = this
          , i = e.length;
        for (let s = 0; s < i; ) {
            const o = Math.min(n - this.pos, i - s);
            for (let a = 0; a < o; a++)
                r[this.pos++] ^= e[s++];
            this.pos === n && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: n, pos: r, blockLen: i} = this;
        e[r] ^= n,
        n & 128 && r === i - 1 && this.keccak(),
        e[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        ka(this, !1),
        Ci(e),
        this.finish();
        const n = this.state
          , {blockLen: r} = this;
        for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, s - i);
            e.set(n.subarray(this.posOut, this.posOut + o), i),
            this.posOut += o,
            i += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return tc(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (z_(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        gs(this.state)
    }
    _cloneInto(e) {
        const {blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: o} = this;
        return e || (e = new ty(n,r,i,o,s)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = s,
        e.suffix = r,
        e.outputLen = i,
        e.enableXOF = o,
        e.destroyed = this.destroyed,
        e
    }
}
const HM = (t, e, n) => Pm( () => new ty(e,t,n))
  , g1 = ( () => HM(1, 136, 256 / 8))();
class tS extends Bm {
    constructor(e, n) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        D_(e);
        const r = bh(n);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const i = this.blockLen
          , s = new Uint8Array(i);
        s.set(r.length > i ? e.create().update(r).digest() : r);
        for (let o = 0; o < s.length; o++)
            s[o] ^= 54;
        this.iHash.update(s),
        this.oHash = e.create();
        for (let o = 0; o < s.length; o++)
            s[o] ^= 106;
        this.oHash.update(s),
        gs(s)
    }
    update(e) {
        return ka(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        ka(this),
        Ci(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a} = this;
        return e = e,
        e.finished = i,
        e.destroyed = s,
        e.blockLen = o,
        e.outputLen = a,
        e.oHash = n._cloneInto(e.oHash),
        e.iHash = r._cloneInto(e.iHash),
        e
    }
    clone() {
        return this._cloneInto()
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
const nS = (t, e, n) => new tS(t,e).update(n).digest();
nS.create = (t, e) => new tS(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const m1 = (t, e) => (t + (t >= 0 ? e : -e) / rS) / e;
function qM(t, e, n) {
    const [[r,i],[s,o]] = e
      , a = m1(o * t, n)
      , l = m1(-i * t, n);
    let c = t - a * r - l * s
      , d = -a * i - l * o;
    const h = c < Si
      , y = d < Si;
    h && (c = -c),
    y && (d = -d);
    const m = vc(Math.ceil(q_(n) / 2)) + ha;
    if (c < Si || c >= m || d < Si || d >= m)
        throw new Error("splitScalar (endomorphism): failed, k=" + t);
    return {
        k1neg: h,
        k1: c,
        k2neg: y,
        k2: d
    }
}
function Mp(t) {
    if (!["compact", "recovered", "der"].includes(t))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return t
}
function s0(t, e) {
    const n = {};
    for (let r of Object.keys(e))
        n[r] = t[r] === void 0 ? e[r] : t[r];
    return oo(n.lowS, "lowS"),
    oo(n.prehash, "prehash"),
    n.format !== void 0 && Mp(n.format),
    n
}
class GM extends Error {
    constructor(e="") {
        super(e)
    }
}
const mi = {
    Err: GM,
    _tlv: {
        encode: (t, e) => {
            const {Err: n} = mi;
            if (t < 0 || t > 256)
                throw new n("tlv.encode: wrong tag");
            if (e.length & 1)
                throw new n("tlv.encode: unpadded data");
            const r = e.length / 2
              , i = ru(r);
            if (i.length / 2 & 128)
                throw new n("tlv.encode: long form length too big");
            const s = r > 127 ? ru(i.length / 2 | 128) : "";
            return ru(t) + s + i + e
        }
        ,
        decode(t, e) {
            const {Err: n} = mi;
            let r = 0;
            if (t < 0 || t > 256)
                throw new n("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== t)
                throw new n("tlv.decode: wrong tlv");
            const i = e[r++]
              , s = !!(i & 128);
            let o = 0;
            if (!s)
                o = i;
            else {
                const l = i & 127;
                if (!l)
                    throw new n("tlv.decode(long): indefinite length not supported");
                if (l > 4)
                    throw new n("tlv.decode(long): byte length is too big");
                const c = e.subarray(r, r + l);
                if (c.length !== l)
                    throw new n("tlv.decode: length bytes not complete");
                if (c[0] === 0)
                    throw new n("tlv.decode(long): zero leftmost byte");
                for (const d of c)
                    o = o << 8 | d;
                if (r += l,
                o < 128)
                    throw new n("tlv.decode(long): not minimal encoding")
            }
            const a = e.subarray(r, r + o);
            if (a.length !== o)
                throw new n("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(r + o)
            }
        }
    },
    _int: {
        encode(t) {
            const {Err: e} = mi;
            if (t < Si)
                throw new e("integer: negative integers are not allowed");
            let n = ru(t);
            if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n),
            n.length & 1)
                throw new e("unexpected DER parsing assertion: unpadded hex");
            return n
        },
        decode(t) {
            const {Err: e} = mi;
            if (t[0] & 128)
                throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128))
                throw new e("invalid signature integer: unnecessary leading zero");
            return _h(t)
        }
    },
    toSig(t) {
        const {Err: e, _int: n, _tlv: r} = mi
          , i = Et("signature", t)
          , {v: s, l: o} = r.decode(48, i);
        if (o.length)
            throw new e("invalid signature: left bytes after parsing");
        const {v: a, l} = r.decode(2, s)
          , {v: c, l: d} = r.decode(2, l);
        if (d.length)
            throw new e("invalid signature: left bytes after parsing");
        return {
            r: n.decode(a),
            s: n.decode(c)
        }
    },
    hexFromSig(t) {
        const {_tlv: e, _int: n} = mi
          , r = e.encode(2, n.encode(t.r))
          , i = e.encode(2, n.encode(t.s))
          , s = r + i;
        return e.encode(48, s)
    }
}
  , Si = BigInt(0)
  , ha = BigInt(1)
  , rS = BigInt(2)
  , au = BigInt(3)
  , YM = BigInt(4);
function na(t, e) {
    const {BYTES: n} = t;
    let r;
    if (typeof e == "bigint")
        r = e;
    else {
        let i = Et("private key", e);
        try {
            r = t.fromBytes(i)
        } catch {
            throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof e}`)
        }
    }
    if (!t.isValidNot0(r))
        throw new Error("invalid private key: out of range [1..N-1]");
    return r
}
function ZM(t, e={}) {
    const n = cx("weierstrass", t, e)
      , {Fp: r, Fn: i} = n;
    let s = n.CURVE;
    const {h: o, n: a} = s;
    bc(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const {endo: l} = e;
    if (l && (!r.is0(s.a) || typeof l.beta != "bigint" || !Array.isArray(l.basises)))
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    const c = sS(r, i);
    function d() {
        if (!r.isOdd)
            throw new Error("compression is not supported: Field does not have .isOdd()")
    }
    function h(X, T, u) {
        const {x: p, y: k} = T.toAffine()
          , C = r.toBytes(p);
        if (oo(u, "isCompressed"),
        u) {
            d();
            const I = !r.isOdd(k);
            return Hr(iS(I), C)
        } else
            return Hr(Uint8Array.of(4), C, r.toBytes(k))
    }
    function y(X) {
        Rr(X, void 0, "Point");
        const {publicKey: T, publicKeyUncompressed: u} = c
          , p = X.length
          , k = X[0]
          , C = X.subarray(1);
        if (p === T && (k === 2 || k === 3)) {
            const I = r.fromBytes(C);
            if (!r.isValid(I))
                throw new Error("bad point: is not on curve, wrong x");
            const L = E(I);
            let P;
            try {
                P = r.sqrt(L)
            } catch (B) {
                const ie = B instanceof Error ? ": " + B.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + ie)
            }
            d();
            const N = r.isOdd(P);
            return (k & 1) === 1 !== N && (P = r.neg(P)),
            {
                x: I,
                y: P
            }
        } else if (p === u && k === 4) {
            const I = r.BYTES
              , L = r.fromBytes(C.subarray(0, I))
              , P = r.fromBytes(C.subarray(I, I * 2));
            if (!A(L, P))
                throw new Error("bad point: is not on curve");
            return {
                x: L,
                y: P
            }
        } else
            throw new Error(`bad point: got length ${p}, expected compressed=${T} or uncompressed=${u}`)
    }
    const m = e.toBytes || h
      , v = e.fromBytes || y;
    function E(X) {
        const T = r.sqr(X)
          , u = r.mul(T, X);
        return r.add(r.add(u, r.mul(X, s.a)), s.b)
    }
    function A(X, T) {
        const u = r.sqr(T)
          , p = E(X);
        return r.eql(u, p)
    }
    if (!A(s.Gx, s.Gy))
        throw new Error("bad curve params: generator point");
    const _ = r.mul(r.pow(s.a, au), YM)
      , x = r.mul(r.sqr(s.b), BigInt(27));
    if (r.is0(r.add(_, x)))
        throw new Error("bad curve params: a or b");
    function b(X, T, u=!1) {
        if (!r.isValid(T) || u && r.is0(T))
            throw new Error(`bad point coordinate ${X}`);
        return T
    }
    function R(X) {
        if (!(X instanceof F))
            throw new Error("ProjectivePoint expected")
    }
    function O(X) {
        if (!l || !l.basises)
            throw new Error("no endo");
        return qM(X, l.basises, i.ORDER)
    }
    const D = Rd( (X, T) => {
        const {X: u, Y: p, Z: k} = X;
        if (r.eql(k, r.ONE))
            return {
                x: u,
                y: p
            };
        const C = X.is0();
        T == null && (T = C ? r.ONE : r.inv(k));
        const I = r.mul(u, T)
          , L = r.mul(p, T)
          , P = r.mul(k, T);
        if (C)
            return {
                x: r.ZERO,
                y: r.ZERO
            };
        if (!r.eql(P, r.ONE))
            throw new Error("invZ was invalid");
        return {
            x: I,
            y: L
        }
    }
    )
      , z = Rd(X => {
        if (X.is0()) {
            if (e.allowInfinityPoint && !r.is0(X.Y))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: T, y: u} = X.toAffine();
        if (!r.isValid(T) || !r.isValid(u))
            throw new Error("bad point: x or y not field elements");
        if (!A(T, u))
            throw new Error("bad point: equation left != right");
        if (!X.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    function K(X, T, u, p, k) {
        return u = new F(r.mul(u.X, X),u.Y,u.Z),
        T = Ld(p, T),
        u = Ld(k, u),
        T.add(u)
    }
    class F {
        constructor(T, u, p) {
            this.X = b("x", T),
            this.Y = b("y", u, !0),
            this.Z = b("z", p),
            Object.freeze(this)
        }
        static CURVE() {
            return s
        }
        static fromAffine(T) {
            const {x: u, y: p} = T || {};
            if (!T || !r.isValid(u) || !r.isValid(p))
                throw new Error("invalid affine point");
            if (T instanceof F)
                throw new Error("projective point not allowed");
            return r.is0(u) && r.is0(p) ? F.ZERO : new F(u,p,r.ONE)
        }
        static fromBytes(T) {
            const u = F.fromAffine(v(Rr(T, void 0, "point")));
            return u.assertValidity(),
            u
        }
        static fromHex(T) {
            return F.fromBytes(Et("pointHex", T))
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        precompute(T=8, u=!0) {
            return Z.createCache(this, T),
            u || this.multiply(au),
            this
        }
        assertValidity() {
            z(this)
        }
        hasEvenY() {
            const {y: T} = this.toAffine();
            if (!r.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !r.isOdd(T)
        }
        equals(T) {
            R(T);
            const {X: u, Y: p, Z: k} = this
              , {X: C, Y: I, Z: L} = T
              , P = r.eql(r.mul(u, L), r.mul(C, k))
              , N = r.eql(r.mul(p, L), r.mul(I, k));
            return P && N
        }
        negate() {
            return new F(this.X,r.neg(this.Y),this.Z)
        }
        double() {
            const {a: T, b: u} = s
              , p = r.mul(u, au)
              , {X: k, Y: C, Z: I} = this;
            let L = r.ZERO
              , P = r.ZERO
              , N = r.ZERO
              , g = r.mul(k, k)
              , B = r.mul(C, C)
              , ie = r.mul(I, I)
              , te = r.mul(k, C);
            return te = r.add(te, te),
            N = r.mul(k, I),
            N = r.add(N, N),
            L = r.mul(T, N),
            P = r.mul(p, ie),
            P = r.add(L, P),
            L = r.sub(B, P),
            P = r.add(B, P),
            P = r.mul(L, P),
            L = r.mul(te, L),
            N = r.mul(p, N),
            ie = r.mul(T, ie),
            te = r.sub(g, ie),
            te = r.mul(T, te),
            te = r.add(te, N),
            N = r.add(g, g),
            g = r.add(N, g),
            g = r.add(g, ie),
            g = r.mul(g, te),
            P = r.add(P, g),
            ie = r.mul(C, I),
            ie = r.add(ie, ie),
            g = r.mul(ie, te),
            L = r.sub(L, g),
            N = r.mul(ie, B),
            N = r.add(N, N),
            N = r.add(N, N),
            new F(L,P,N)
        }
        add(T) {
            R(T);
            const {X: u, Y: p, Z: k} = this
              , {X: C, Y: I, Z: L} = T;
            let P = r.ZERO
              , N = r.ZERO
              , g = r.ZERO;
            const B = s.a
              , ie = r.mul(s.b, au);
            let te = r.mul(u, C)
              , oe = r.mul(p, I)
              , xe = r.mul(k, L)
              , ve = r.add(u, p)
              , ye = r.add(C, I);
            ve = r.mul(ve, ye),
            ye = r.add(te, oe),
            ve = r.sub(ve, ye),
            ye = r.add(u, k);
            let vt = r.add(C, L);
            return ye = r.mul(ye, vt),
            vt = r.add(te, xe),
            ye = r.sub(ye, vt),
            vt = r.add(p, k),
            P = r.add(I, L),
            vt = r.mul(vt, P),
            P = r.add(oe, xe),
            vt = r.sub(vt, P),
            g = r.mul(B, ye),
            P = r.mul(ie, xe),
            g = r.add(P, g),
            P = r.sub(oe, g),
            g = r.add(oe, g),
            N = r.mul(P, g),
            oe = r.add(te, te),
            oe = r.add(oe, te),
            xe = r.mul(B, xe),
            ye = r.mul(ie, ye),
            oe = r.add(oe, xe),
            xe = r.sub(te, xe),
            xe = r.mul(B, xe),
            ye = r.add(ye, xe),
            te = r.mul(oe, ye),
            N = r.add(N, te),
            te = r.mul(vt, ye),
            P = r.mul(ve, P),
            P = r.sub(P, te),
            te = r.mul(ve, oe),
            g = r.mul(vt, g),
            g = r.add(g, te),
            new F(P,N,g)
        }
        subtract(T) {
            return this.add(T.negate())
        }
        is0() {
            return this.equals(F.ZERO)
        }
        multiply(T) {
            const {endo: u} = e;
            if (!i.isValidNot0(T))
                throw new Error("invalid scalar: out of range");
            let p, k;
            const C = I => Z.cached(this, I, L => Ks(F, L));
            if (u) {
                const {k1neg: I, k1: L, k2neg: P, k2: N} = O(T)
                  , {p: g, f: B} = C(L)
                  , {p: ie, f: te} = C(N);
                k = B.add(te),
                p = K(u.beta, g, ie, I, P)
            } else {
                const {p: I, f: L} = C(T);
                p = I,
                k = L
            }
            return Ks(F, [p, k])[0]
        }
        multiplyUnsafe(T) {
            const {endo: u} = e
              , p = this;
            if (!i.isValid(T))
                throw new Error("invalid scalar: out of range");
            if (T === Si || p.is0())
                return F.ZERO;
            if (T === ha)
                return p;
            if (Z.hasCache(this))
                return this.multiply(T);
            if (u) {
                const {k1neg: k, k1: C, k2neg: I, k2: L} = O(T)
                  , {p1: P, p2: N} = D4(F, p, C, L);
                return K(u.beta, P, N, k, I)
            } else
                return Z.unsafe(p, T)
        }
        multiplyAndAddUnsafe(T, u, p) {
            const k = this.multiplyUnsafe(u).add(T.multiplyUnsafe(p));
            return k.is0() ? void 0 : k
        }
        toAffine(T) {
            return D(this, T)
        }
        isTorsionFree() {
            const {isTorsionFree: T} = e;
            return o === ha ? !0 : T ? T(F, this) : Z.unsafe(this, a).is0()
        }
        clearCofactor() {
            const {clearCofactor: T} = e;
            return o === ha ? this : T ? T(F, this) : this.multiplyUnsafe(o)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0()
        }
        toBytes(T=!0) {
            return oo(T, "isCompressed"),
            this.assertValidity(),
            m(F, this, T)
        }
        toHex(T=!0) {
            return eo(this.toBytes(T))
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`
        }
        get px() {
            return this.X
        }
        get py() {
            return this.X
        }
        get pz() {
            return this.Z
        }
        toRawBytes(T=!0) {
            return this.toBytes(T)
        }
        _setWindowSize(T) {
            this.precompute(T)
        }
        static normalizeZ(T) {
            return Ks(F, T)
        }
        static msm(T, u) {
            return lx(F, i, T, u)
        }
        static fromPrivateKey(T) {
            return F.BASE.multiply(na(i, T))
        }
    }
    F.BASE = new F(s.Gx,s.Gy,r.ONE),
    F.ZERO = new F(r.ZERO,r.ONE,r.ZERO),
    F.Fp = r,
    F.Fn = i;
    const G = i.BITS
      , Z = new ax(F,e.endo ? Math.ceil(G / 2) : G);
    return F.BASE.precompute(8),
    F
}
function iS(t) {
    return Uint8Array.of(t ? 2 : 3)
}
function sS(t, e) {
    return {
        secretKey: e.BYTES,
        publicKey: 1 + t.BYTES,
        publicKeyUncompressed: 1 + 2 * t.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
    }
}
function QM(t, e={}) {
    const {Fn: n} = t
      , r = e.randomBytes || Om
      , i = Object.assign(sS(t.Fp, n), {
        seed: ix(n.ORDER)
    });
    function s(m) {
        try {
            return !!na(n, m)
        } catch {
            return !1
        }
    }
    function o(m, v) {
        const {publicKey: E, publicKeyUncompressed: A} = i;
        try {
            const _ = m.length;
            return v === !0 && _ !== E || v === !1 && _ !== A ? !1 : !!t.fromBytes(m)
        } catch {
            return !1
        }
    }
    function a(m=r(i.seed)) {
        return B4(Rr(m, i.seed, "seed"), n.ORDER)
    }
    function l(m, v=!0) {
        return t.BASE.multiply(na(n, m)).toBytes(v)
    }
    function c(m) {
        const v = a(m);
        return {
            secretKey: v,
            publicKey: l(v)
        }
    }
    function d(m) {
        if (typeof m == "bigint")
            return !1;
        if (m instanceof t)
            return !0;
        const {secretKey: v, publicKey: E, publicKeyUncompressed: A} = i;
        if (n.allowedLengths || v === E)
            return;
        const _ = Et("key", m).length;
        return _ === E || _ === A
    }
    function h(m, v, E=!0) {
        if (d(m) === !0)
            throw new Error("first arg must be private key");
        if (d(v) === !1)
            throw new Error("second arg must be public key");
        const A = na(n, m);
        return t.fromHex(v).multiply(A).toBytes(E)
    }
    return Object.freeze({
        getPublicKey: l,
        getSharedSecret: h,
        keygen: c,
        Point: t,
        utils: {
            isValidSecretKey: s,
            isValidPublicKey: o,
            randomSecretKey: a,
            isValidPrivateKey: s,
            randomPrivateKey: a,
            normPrivateKeyToScalar: m => na(n, m),
            precompute(m=8, v=t.BASE) {
                return v.precompute(m, !1)
            }
        },
        lengths: i
    })
}
function JM(t, e, n={}) {
    D_(e),
    bc(n, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const r = n.randomBytes || Om
      , i = n.hmac || ( (u, ...p) => nS(e, u, Hr(...p)))
      , {Fp: s, Fn: o} = t
      , {ORDER: a, BITS: l} = o
      , {keygen: c, getPublicKey: d, getSharedSecret: h, utils: y, lengths: m} = QM(t, n)
      , v = {
        prehash: !1,
        lowS: typeof n.lowS == "boolean" ? n.lowS : !1,
        format: void 0,
        extraEntropy: !1
    }
      , E = "compact";
    function A(u) {
        const p = a >> ha;
        return u > p
    }
    function _(u, p) {
        if (!o.isValidNot0(p))
            throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);
        return p
    }
    function x(u, p) {
        Mp(p);
        const k = m.signature
          , C = p === "compact" ? k : p === "recovered" ? k + 1 : void 0;
        return Rr(u, C, `${p} signature`)
    }
    class b {
        constructor(p, k, C) {
            this.r = _("r", p),
            this.s = _("s", k),
            C != null && (this.recovery = C),
            Object.freeze(this)
        }
        static fromBytes(p, k=E) {
            x(p, k);
            let C;
            if (k === "der") {
                const {r: N, s: g} = mi.toSig(Rr(p));
                return new b(N,g)
            }
            k === "recovered" && (C = p[0],
            k = "compact",
            p = p.subarray(1));
            const I = o.BYTES
              , L = p.subarray(0, I)
              , P = p.subarray(I, I * 2);
            return new b(o.fromBytes(L),o.fromBytes(P),C)
        }
        static fromHex(p, k) {
            return this.fromBytes(Cd(p), k)
        }
        addRecoveryBit(p) {
            return new b(this.r,this.s,p)
        }
        recoverPublicKey(p) {
            const k = s.ORDER
              , {r: C, s: I, recovery: L} = this;
            if (L == null || ![0, 1, 2, 3].includes(L))
                throw new Error("recovery id invalid");
            if (a * rS < k && L > 1)
                throw new Error("recovery id is ambiguous for h>1 curve");
            const N = L === 2 || L === 3 ? C + a : C;
            if (!s.isValid(N))
                throw new Error("recovery id 2 or 3 invalid");
            const g = s.toBytes(N)
              , B = t.fromBytes(Hr(iS((L & 1) === 0), g))
              , ie = o.inv(N)
              , te = O(Et("msgHash", p))
              , oe = o.create(-te * ie)
              , xe = o.create(I * ie)
              , ve = t.BASE.multiplyUnsafe(oe).add(B.multiplyUnsafe(xe));
            if (ve.is0())
                throw new Error("point at infinify");
            return ve.assertValidity(),
            ve
        }
        hasHighS() {
            return A(this.s)
        }
        toBytes(p=E) {
            if (Mp(p),
            p === "der")
                return Cd(mi.hexFromSig(this));
            const k = o.toBytes(this.r)
              , C = o.toBytes(this.s);
            if (p === "recovered") {
                if (this.recovery == null)
                    throw new Error("recovery bit must be present");
                return Hr(Uint8Array.of(this.recovery), k, C)
            }
            return Hr(k, C)
        }
        toHex(p) {
            return eo(this.toBytes(p))
        }
        assertValidity() {}
        static fromCompact(p) {
            return b.fromBytes(Et("sig", p), "compact")
        }
        static fromDER(p) {
            return b.fromBytes(Et("sig", p), "der")
        }
        normalizeS() {
            return this.hasHighS() ? new b(this.r,o.neg(this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return this.toBytes("der")
        }
        toDERHex() {
            return eo(this.toBytes("der"))
        }
        toCompactRawBytes() {
            return this.toBytes("compact")
        }
        toCompactHex() {
            return eo(this.toBytes("compact"))
        }
    }
    const R = n.bits2int || function(p) {
        if (p.length > 8192)
            throw new Error("input is too large");
        const k = _h(p)
          , C = p.length * 8 - l;
        return C > 0 ? k >> BigInt(C) : k
    }
      , O = n.bits2int_modN || function(p) {
        return o.create(R(p))
    }
      , D = vc(l);
    function z(u) {
        return Ep("num < 2^" + l, u, Si, D),
        o.toBytes(u)
    }
    function K(u, p) {
        return Rr(u, void 0, "message"),
        p ? Rr(e(u), void 0, "prehashed message") : u
    }
    function F(u, p, k) {
        if (["recovered", "canonical"].some(oe => oe in k))
            throw new Error("sign() legacy options not supported");
        const {lowS: C, prehash: I, extraEntropy: L} = s0(k, v);
        u = K(u, I);
        const P = O(u)
          , N = na(o, p)
          , g = [z(N), z(P)];
        if (L != null && L !== !1) {
            const oe = L === !0 ? r(m.secretKey) : L;
            g.push(Et("extraEntropy", oe))
        }
        const B = Hr(...g)
          , ie = P;
        function te(oe) {
            const xe = R(oe);
            if (!o.isValidNot0(xe))
                return;
            const ve = o.inv(xe)
              , ye = t.BASE.multiply(xe).toAffine()
              , vt = o.create(ye.x);
            if (vt === Si)
                return;
            const qe = o.create(ve * o.create(ie + vt * N));
            if (qe === Si)
                return;
            let Ze = (ye.x === vt ? 0 : 2) | Number(ye.y & ha)
              , fr = qe;
            return C && A(qe) && (fr = o.neg(qe),
            Ze ^= 1),
            new b(vt,fr,Ze)
        }
        return {
            seed: B,
            k2sig: te
        }
    }
    function G(u, p, k={}) {
        u = Et("message", u);
        const {seed: C, k2sig: I} = F(u, p, k);
        return E4(e.outputLen, o.BYTES, i)(C, I)
    }
    function Z(u) {
        let p;
        const k = typeof u == "string" || wc(u)
          , C = !k && u !== null && typeof u == "object" && typeof u.r == "bigint" && typeof u.s == "bigint";
        if (!k && !C)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (C)
            p = new b(u.r,u.s);
        else if (k) {
            try {
                p = b.fromBytes(Et("sig", u), "der")
            } catch (I) {
                if (!(I instanceof mi.Err))
                    throw I
            }
            if (!p)
                try {
                    p = b.fromBytes(Et("sig", u), "compact")
                } catch {
                    return !1
                }
        }
        return p || !1
    }
    function X(u, p, k, C={}) {
        const {lowS: I, prehash: L, format: P} = s0(C, v);
        if (k = Et("publicKey", k),
        p = K(Et("message", p), L),
        "strict"in C)
            throw new Error("options.strict was renamed to lowS");
        const N = P === void 0 ? Z(u) : b.fromBytes(Et("sig", u), P);
        if (N === !1)
            return !1;
        try {
            const g = t.fromBytes(k);
            if (I && N.hasHighS())
                return !1;
            const {r: B, s: ie} = N
              , te = O(p)
              , oe = o.inv(ie)
              , xe = o.create(te * oe)
              , ve = o.create(B * oe)
              , ye = t.BASE.multiplyUnsafe(xe).add(g.multiplyUnsafe(ve));
            return ye.is0() ? !1 : o.create(ye.x) === B
        } catch {
            return !1
        }
    }
    function T(u, p, k={}) {
        const {prehash: C} = s0(k, v);
        return p = K(p, C),
        b.fromBytes(u, "recovered").recoverPublicKey(p).toBytes()
    }
    return Object.freeze({
        keygen: c,
        getPublicKey: d,
        getSharedSecret: h,
        utils: y,
        lengths: m,
        Point: t,
        sign: G,
        verify: X,
        recoverPublicKey: T,
        Signature: b,
        hash: e
    })
}
function XM(t) {
    const e = {
        a: t.a,
        b: t.b,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy
    }
      , n = t.Fp;
    let r = t.allowedPrivateKeyLengths ? Array.from(new Set(t.allowedPrivateKeyLengths.map(o => Math.ceil(o / 2)))) : void 0;
    const i = go(e.n, {
        BITS: t.nBitLength,
        allowedLengths: r,
        modFromBytes: t.wrapPrivateKey
    })
      , s = {
        Fp: n,
        Fn: i,
        allowInfinityPoint: t.allowInfinityPoint,
        endo: t.endo,
        isTorsionFree: t.isTorsionFree,
        clearCofactor: t.clearCofactor,
        fromBytes: t.fromBytes,
        toBytes: t.toBytes
    };
    return {
        CURVE: e,
        curveOpts: s
    }
}
function eT(t) {
    const {CURVE: e, curveOpts: n} = XM(t)
      , r = {
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: n,
        hash: t.hash,
        ecdsaOpts: r
    }
}
function tT(t, e) {
    const n = e.Point;
    return Object.assign({}, e, {
        ProjectivePoint: n,
        CURVE: Object.assign({}, t, nx(n.Fn.ORDER, n.Fn.BITS))
    })
}
function nT(t) {
    const {CURVE: e, curveOpts: n, hash: r, ecdsaOpts: i} = eT(t)
      , s = ZM(e, n)
      , o = JM(s, r, i);
    return tT(t, o)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function rT(t, e) {
    const n = r => nT({
        ...t,
        hash: r
    });
    return {
        ...n(e),
        create: n
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ny = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}
  , iT = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [[BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")], [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]
}
  , y1 = BigInt(2);
function sT(t) {
    const e = ny.p
      , n = BigInt(3)
      , r = BigInt(6)
      , i = BigInt(11)
      , s = BigInt(22)
      , o = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , c = t * t * t % e
      , d = c * c * t % e
      , h = kt(d, n, e) * d % e
      , y = kt(h, n, e) * d % e
      , m = kt(y, y1, e) * c % e
      , v = kt(m, i, e) * m % e
      , E = kt(v, s, e) * v % e
      , A = kt(E, a, e) * E % e
      , _ = kt(A, l, e) * A % e
      , x = kt(_, a, e) * E % e
      , b = kt(x, n, e) * d % e
      , R = kt(b, o, e) * v % e
      , O = kt(R, r, e) * c % e
      , D = kt(O, y1, e);
    if (!Tp.eql(Tp.sqr(D), t))
        throw new Error("Cannot find square root");
    return D
}
const Tp = go(ny.p, {
    sqrt: sT
})
  , ry = rT({
    ...ny,
    Fp: Tp,
    lowS: !0,
    endo: iT
}, K_)
  , oT = za.utils.randomPrivateKey
  , w1 = () => {
    const t = za.utils.randomPrivateKey()
      , e = Ud(t)
      , n = new Uint8Array(64);
    return n.set(t),
    n.set(e, 32),
    {
        publicKey: e,
        secretKey: n
    }
}
  , Ud = za.getPublicKey;
function v1(t) {
    try {
        return za.ExtendedPoint.fromHex(t),
        !0
    } catch {
        return !1
    }
}
const iy = (t, e) => za.sign(t, e.slice(0, 32))
  , aT = za.verify
  , Ie = t => pe.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? pe.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : pe.Buffer.from(t);
class sy {
    constructor(e) {
        Object.assign(this, e)
    }
    encode() {
        return pe.Buffer.from(vx(Nl, this))
    }
    static decode(e) {
        return bx(Nl, this, e)
    }
    static decodeUnchecked(e) {
        return px(Nl, this, e)
    }
}
class lT extends sy {
    constructor(e) {
        if (super(e),
        this.enum = "",
        Object.keys(e).length !== 1)
            throw new Error("Enum can only take single value");
        Object.keys(e).map(n => {
            this.enum = n
        }
        )
    }
}
const Nl = new Map;
var oS;
const aS = 32
  , ti = 32;
function cT(t) {
    return t._bn !== void 0
}
let b1 = 1;
class ne extends sy {
    constructor(e) {
        if (super({}),
        this._bn = void 0,
        cT(e))
            this._bn = e._bn;
        else {
            if (typeof e == "string") {
                const n = gn.decode(e);
                if (n.length != ti)
                    throw new Error("Invalid public key input");
                this._bn = new c1(n)
            } else
                this._bn = new c1(e);
            if (this._bn.byteLength() > ti)
                throw new Error("Invalid public key input")
        }
    }
    static unique() {
        const e = new ne(b1);
        return b1 += 1,
        new ne(e.toBuffer())
    }
    equals(e) {
        return this._bn.eq(e._bn)
    }
    toBase58() {
        return gn.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        const e = this.toBuffer();
        return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)
    }
    toBuffer() {
        const e = this._bn.toArrayLike(pe.Buffer);
        if (e.length === ti)
            return e;
        const n = pe.Buffer.alloc(32);
        return e.copy(n, 32 - e.length),
        n
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed(e, n, r) {
        const i = pe.Buffer.concat([e.toBuffer(), pe.Buffer.from(n), r.toBuffer()])
          , s = u1(i);
        return new ne(s)
    }
    static createProgramAddressSync(e, n) {
        let r = pe.Buffer.alloc(0);
        e.forEach(function(s) {
            if (s.length > aS)
                throw new TypeError("Max seed length exceeded");
            r = pe.Buffer.concat([r, Ie(s)])
        }),
        r = pe.Buffer.concat([r, n.toBuffer(), pe.Buffer.from("ProgramDerivedAddress")]);
        const i = u1(r);
        if (v1(i))
            throw new Error("Invalid seeds, address must fall off the curve");
        return new ne(i)
    }
    static async createProgramAddress(e, n) {
        return this.createProgramAddressSync(e, n)
    }
    static findProgramAddressSync(e, n) {
        let r = 255, i;
        for (; r != 0; ) {
            try {
                const s = e.concat(pe.Buffer.from([r]));
                i = this.createProgramAddressSync(s, n)
            } catch (s) {
                if (s instanceof TypeError)
                    throw s;
                r--;
                continue
            }
            return [i, r]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress(e, n) {
        return this.findProgramAddressSync(e, n)
    }
    static isOnCurve(e) {
        const n = new ne(e);
        return v1(n.toBytes())
    }
}
oS = ne;
ne.default = new oS("11111111111111111111111111111111");
Nl.set(ne, {
    kind: "struct",
    fields: [["_bn", "u256"]]
});
class uT {
    constructor(e) {
        if (this._publicKey = void 0,
        this._secretKey = void 0,
        e) {
            const n = Ie(e);
            if (e.length !== 64)
                throw new Error("bad secret key size");
            this._publicKey = n.slice(32, 64),
            this._secretKey = n.slice(0, 32)
        } else
            this._secretKey = Ie(oT()),
            this._publicKey = Ie(Ud(this._secretKey))
    }
    get publicKey() {
        return new ne(this._publicKey)
    }
    get secretKey() {
        return pe.Buffer.concat([this._secretKey, this._publicKey], 64)
    }
}
const dT = new ne("BPFLoader1111111111111111111111111111111111")
  , hs = 1280 - 40 - 8
  , Mh = 127
  , ic = 64;
class oy extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: block height exceeded.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(oy.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class ay extends Error {
    constructor(e, n) {
        super(`Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(ay.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
class ra extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: the nonce is no longer valid.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(ra.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
class sc {
    constructor(e, n) {
        this.staticAccountKeys = void 0,
        this.accountKeysFromLookups = void 0,
        this.staticAccountKeys = e,
        this.accountKeysFromLookups = n
    }
    keySegments() {
        const e = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
        e
    }
    get(e) {
        for (const n of this.keySegments()) {
            if (e < n.length)
                return n[e];
            e -= n.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(e) {
        if (this.length > 255 + 1)
            throw new Error("Account index overflow encountered during compilation");
        const r = new Map;
        this.keySegments().flat().forEach( (s, o) => {
            r.set(s.toBase58(), o)
        }
        );
        const i = s => {
            const o = r.get(s.toBase58());
            if (o === void 0)
                throw new Error("Encountered an unknown instruction account key during compilation");
            return o
        }
        ;
        return e.map(s => ({
            programIdIndex: i(s.programId),
            accountKeyIndexes: s.keys.map(o => i(o.pubkey)),
            data: s.data
        }))
    }
}
const Ce = (t="publicKey") => st(32, t)
  , hT = (t="signature") => st(64, t)
  , Vs = (t="string") => {
    const e = de([ue("length"), ue("lengthPadding"), st(ds(ue(), -8), "chars")], t)
      , n = e.decode.bind(e)
      , r = e.encode.bind(e)
      , i = e;
    return i.decode = (s, o) => n(s, o).chars.toString(),
    i.encode = (s, o, a) => {
        const l = {
            chars: pe.Buffer.from(s, "utf8")
        };
        return r(l, o, a)
    }
    ,
    i.alloc = s => ue().span + ue().span + pe.Buffer.from(s, "utf8").length,
    i
}
  , fT = (t="authorized") => de([Ce("staker"), Ce("withdrawer")], t)
  , pT = (t="lockup") => de([tr("unixTimestamp"), tr("epoch"), Ce("custodian")], t)
  , gT = (t="voteInit") => de([Ce("nodePubkey"), Ce("authorizedVoter"), Ce("authorizedWithdrawer"), Pe("commission")], t)
  , mT = (t="voteAuthorizeWithSeedArgs") => de([ue("voteAuthorizationType"), Ce("currentAuthorityDerivedKeyOwnerPubkey"), Vs("currentAuthorityDerivedKeySeed"), Ce("newAuthorized")], t);
function lS(t, e) {
    const n = i => {
        if (i.span >= 0)
            return i.span;
        if (typeof i.alloc == "function")
            return i.alloc(e[i.property]);
        if ("count"in i && "elementLayout"in i) {
            const s = e[i.property];
            if (Array.isArray(s))
                return s.length * n(i.elementLayout)
        } else if ("fields"in i)
            return lS({
                layout: i
            }, e[i.property]);
        return 0
    }
    ;
    let r = 0;
    return t.layout.fields.forEach(i => {
        r += n(i)
    }
    ),
    r
}
function Wn(t) {
    let e = 0
      , n = 0;
    for (; ; ) {
        let r = t.shift();
        if (e |= (r & 127) << n * 7,
        n += 1,
        !(r & 128))
            break
    }
    return e
}
function nr(t, e) {
    let n = e;
    for (; ; ) {
        let r = n & 127;
        if (n >>= 7,
        n == 0) {
            t.push(r);
            break
        } else
            r |= 128,
            t.push(r)
    }
}
function ze(t, e) {
    if (!t)
        throw new Error(e || "Assertion failed")
}
class Th {
    constructor(e, n) {
        this.payer = void 0,
        this.keyMetaMap = void 0,
        this.payer = e,
        this.keyMetaMap = n
    }
    static compile(e, n) {
        const r = new Map
          , i = o => {
            const a = o.toBase58();
            let l = r.get(a);
            return l === void 0 && (l = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            },
            r.set(a, l)),
            l
        }
          , s = i(n);
        s.isSigner = !0,
        s.isWritable = !0;
        for (const o of e) {
            i(o.programId).isInvoked = !0;
            for (const a of o.keys) {
                const l = i(a.pubkey);
                l.isSigner ||= a.isSigner,
                l.isWritable ||= a.isWritable
            }
        }
        return new Th(n,r)
    }
    getMessageComponents() {
        const e = [...this.keyMetaMap.entries()];
        ze(e.length <= 256, "Max static account keys length exceeded");
        const n = e.filter( ([,l]) => l.isSigner && l.isWritable)
          , r = e.filter( ([,l]) => l.isSigner && !l.isWritable)
          , i = e.filter( ([,l]) => !l.isSigner && l.isWritable)
          , s = e.filter( ([,l]) => !l.isSigner && !l.isWritable)
          , o = {
            numRequiredSignatures: n.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: s.length
        };
        {
            ze(n.length > 0, "Expected at least one writable signer key");
            const [l] = n[0];
            ze(l === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const a = [...n.map( ([l]) => new ne(l)), ...r.map( ([l]) => new ne(l)), ...i.map( ([l]) => new ne(l)), ...s.map( ([l]) => new ne(l))];
        return [o, a]
    }
    extractTableLookup(e) {
        const [n,r] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && o.isWritable)
          , [i,s] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && !o.isWritable);
        if (!(n.length === 0 && i.length === 0))
            return [{
                accountKey: e.key,
                writableIndexes: n,
                readonlyIndexes: i
            }, {
                writable: r,
                readonly: s
            }]
    }
    drainKeysFoundInLookupTable(e, n) {
        const r = new Array
          , i = new Array;
        for (const [s,o] of this.keyMetaMap.entries())
            if (n(o)) {
                const a = new ne(s)
                  , l = e.findIndex(c => c.equals(a));
                l >= 0 && (ze(l < 256, "Max lookup table index exceeded"),
                r.push(l),
                i.push(a),
                this.keyMetaMap.delete(s))
            }
        return [r, i]
    }
}
const cS = "Reached end of buffer unexpectedly";
function qr(t) {
    if (t.length === 0)
        throw new Error(cS);
    return t.shift()
}
function Fn(t, ...e) {
    const [n] = e;
    if (e.length === 2 ? n + (e[1] ?? 0) > t.length : n >= t.length)
        throw new Error(cS);
    return t.splice(...e)
}
class Dr {
    constructor(e) {
        this.header = void 0,
        this.accountKeys = void 0,
        this.recentBlockhash = void 0,
        this.instructions = void 0,
        this.indexToProgramIds = new Map,
        this.header = e.header,
        this.accountKeys = e.accountKeys.map(n => new ne(n)),
        this.recentBlockhash = e.recentBlockhash,
        this.instructions = e.instructions,
        this.instructions.forEach(n => this.indexToProgramIds.set(n.programIdIndex, this.accountKeys[n.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map(e => ({
            programIdIndex: e.programIdIndex,
            accountKeyIndexes: e.accounts,
            data: gn.decode(e.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new sc(this.staticAccountKeys)
    }
    static compile(e) {
        const n = Th.compile(e.instructions, e.payerKey)
          , [r,i] = n.getMessageComponents()
          , o = new sc(i).compileInstructions(e.instructions).map(a => ({
            programIdIndex: a.programIdIndex,
            accounts: a.accountKeyIndexes,
            data: gn.encode(a.data)
        }));
        return new Dr({
            header: r,
            accountKeys: i,
            recentBlockhash: e.recentBlockhash,
            instructions: o
        })
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        const n = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
            const r = e - n
              , s = this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts;
            return r < s
        } else {
            const r = n - this.header.numReadonlySignedAccounts;
            return e < r
        }
    }
    isProgramId(e) {
        return this.indexToProgramIds.has(e)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter( (e, n) => !this.isProgramId(n))
    }
    serialize() {
        const e = this.accountKeys.length;
        let n = [];
        nr(n, e);
        const r = this.instructions.map(h => {
            const {accounts: y, programIdIndex: m} = h
              , v = Array.from(gn.decode(h.data));
            let E = [];
            nr(E, y.length);
            let A = [];
            return nr(A, v.length),
            {
                programIdIndex: m,
                keyIndicesCount: pe.Buffer.from(E),
                keyIndices: y,
                dataLength: pe.Buffer.from(A),
                data: v
            }
        }
        );
        let i = [];
        nr(i, r.length);
        let s = pe.Buffer.alloc(hs);
        pe.Buffer.from(i).copy(s);
        let o = i.length;
        r.forEach(h => {
            const m = de([Pe("programIdIndex"), st(h.keyIndicesCount.length, "keyIndicesCount"), mn(Pe("keyIndex"), h.keyIndices.length, "keyIndices"), st(h.dataLength.length, "dataLength"), mn(Pe("userdatum"), h.data.length, "data")]).encode(h, s, o);
            o += m
        }
        ),
        s = s.slice(0, o);
        const a = de([st(1, "numRequiredSignatures"), st(1, "numReadonlySignedAccounts"), st(1, "numReadonlyUnsignedAccounts"), st(n.length, "keyCount"), mn(Ce("key"), e, "keys"), Ce("recentBlockhash")])
          , l = {
            numRequiredSignatures: pe.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: pe.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: pe.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: pe.Buffer.from(n),
            keys: this.accountKeys.map(h => Ie(h.toBytes())),
            recentBlockhash: gn.decode(this.recentBlockhash)
        };
        let c = pe.Buffer.alloc(2048);
        const d = a.encode(l, c);
        return s.copy(c, d),
        c.slice(0, d + s.length)
    }
    static from(e) {
        let n = [...e];
        const r = qr(n);
        if (r !== (r & Mh))
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const i = qr(n)
          , s = qr(n)
          , o = Wn(n);
        let a = [];
        for (let y = 0; y < o; y++) {
            const m = Fn(n, 0, ti);
            a.push(new ne(pe.Buffer.from(m)))
        }
        const l = Fn(n, 0, ti)
          , c = Wn(n);
        let d = [];
        for (let y = 0; y < c; y++) {
            const m = qr(n)
              , v = Wn(n)
              , E = Fn(n, 0, v)
              , A = Wn(n)
              , _ = Fn(n, 0, A)
              , x = gn.encode(pe.Buffer.from(_));
            d.push({
                programIdIndex: m,
                accounts: E,
                data: x
            })
        }
        const h = {
            header: {
                numRequiredSignatures: r,
                numReadonlySignedAccounts: i,
                numReadonlyUnsignedAccounts: s
            },
            recentBlockhash: gn.encode(pe.Buffer.from(l)),
            accountKeys: a,
            instructions: d
        };
        return new Dr(h)
    }
}
class ao {
    constructor(e) {
        this.header = void 0,
        this.staticAccountKeys = void 0,
        this.recentBlockhash = void 0,
        this.compiledInstructions = void 0,
        this.addressTableLookups = void 0,
        this.header = e.header,
        this.staticAccountKeys = e.staticAccountKeys,
        this.recentBlockhash = e.recentBlockhash,
        this.compiledInstructions = e.compiledInstructions,
        this.addressTableLookups = e.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let e = 0;
        for (const n of this.addressTableLookups)
            e += n.readonlyIndexes.length + n.writableIndexes.length;
        return e
    }
    getAccountKeys(e) {
        let n;
        if (e && "accountKeysFromLookups"in e && e.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)
                throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            n = e.accountKeysFromLookups
        } else if (e && "addressLookupTableAccounts"in e && e.addressLookupTableAccounts)
            n = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0)
            throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new sc(this.staticAccountKeys,n)
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        const n = this.header.numRequiredSignatures
          , r = this.staticAccountKeys.length;
        if (e >= r) {
            const i = e - r
              , s = this.addressTableLookups.reduce( (o, a) => o + a.writableIndexes.length, 0);
            return i < s
        } else if (e >= this.header.numRequiredSignatures) {
            const i = e - n
              , o = r - n - this.header.numReadonlyUnsignedAccounts;
            return i < o
        } else {
            const i = n - this.header.numReadonlySignedAccounts;
            return e < i
        }
    }
    resolveAddressTableLookups(e) {
        const n = {
            writable: [],
            readonly: []
        };
        for (const r of this.addressTableLookups) {
            const i = e.find(s => s.key.equals(r.accountKey));
            if (!i)
                throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);
            for (const s of r.writableIndexes)
                if (s < i.state.addresses.length)
                    n.writable.push(i.state.addresses[s]);
                else
                    throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`);
            for (const s of r.readonlyIndexes)
                if (s < i.state.addresses.length)
                    n.readonly.push(i.state.addresses[s]);
                else
                    throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`)
        }
        return n
    }
    static compile(e) {
        const n = Th.compile(e.instructions, e.payerKey)
          , r = new Array
          , i = {
            writable: new Array,
            readonly: new Array
        }
          , s = e.addressLookupTableAccounts || [];
        for (const d of s) {
            const h = n.extractTableLookup(d);
            if (h !== void 0) {
                const [y,{writable: m, readonly: v}] = h;
                r.push(y),
                i.writable.push(...m),
                i.readonly.push(...v)
            }
        }
        const [o,a] = n.getMessageComponents()
          , c = new sc(a,i).compileInstructions(e.instructions);
        return new ao({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: c,
            addressTableLookups: r
        })
    }
    serialize() {
        const e = Array();
        nr(e, this.staticAccountKeys.length);
        const n = this.serializeInstructions()
          , r = Array();
        nr(r, this.compiledInstructions.length);
        const i = this.serializeAddressTableLookups()
          , s = Array();
        nr(s, this.addressTableLookups.length);
        const o = de([Pe("prefix"), de([Pe("numRequiredSignatures"), Pe("numReadonlySignedAccounts"), Pe("numReadonlyUnsignedAccounts")], "header"), st(e.length, "staticAccountKeysLength"), mn(Ce(), this.staticAccountKeys.length, "staticAccountKeys"), Ce("recentBlockhash"), st(r.length, "instructionsLength"), st(n.length, "serializedInstructions"), st(s.length, "addressTableLookupsLength"), st(i.length, "serializedAddressTableLookups")])
          , a = new Uint8Array(hs)
          , l = 128
          , c = o.encode({
            prefix: l,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(e),
            staticAccountKeys: this.staticAccountKeys.map(d => d.toBytes()),
            recentBlockhash: gn.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: n,
            addressTableLookupsLength: new Uint8Array(s),
            serializedAddressTableLookups: i
        }, a);
        return a.slice(0, c)
    }
    serializeInstructions() {
        let e = 0;
        const n = new Uint8Array(hs);
        for (const r of this.compiledInstructions) {
            const i = Array();
            nr(i, r.accountKeyIndexes.length);
            const s = Array();
            nr(s, r.data.length);
            const o = de([Pe("programIdIndex"), st(i.length, "encodedAccountKeyIndexesLength"), mn(Pe(), r.accountKeyIndexes.length, "accountKeyIndexes"), st(s.length, "encodedDataLength"), st(r.data.length, "data")]);
            e += o.encode({
                programIdIndex: r.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(i),
                accountKeyIndexes: r.accountKeyIndexes,
                encodedDataLength: new Uint8Array(s),
                data: r.data
            }, n, e)
        }
        return n.slice(0, e)
    }
    serializeAddressTableLookups() {
        let e = 0;
        const n = new Uint8Array(hs);
        for (const r of this.addressTableLookups) {
            const i = Array();
            nr(i, r.writableIndexes.length);
            const s = Array();
            nr(s, r.readonlyIndexes.length);
            const o = de([Ce("accountKey"), st(i.length, "encodedWritableIndexesLength"), mn(Pe(), r.writableIndexes.length, "writableIndexes"), st(s.length, "encodedReadonlyIndexesLength"), mn(Pe(), r.readonlyIndexes.length, "readonlyIndexes")]);
            e += o.encode({
                accountKey: r.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(i),
                writableIndexes: r.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(s),
                readonlyIndexes: r.readonlyIndexes
            }, n, e)
        }
        return n.slice(0, e)
    }
    static deserialize(e) {
        let n = [...e];
        const r = qr(n)
          , i = r & Mh;
        ze(r !== i, "Expected versioned message but received legacy message");
        const s = i;
        ze(s === 0, `Expected versioned message with version 0 but found version ${s}`);
        const o = {
            numRequiredSignatures: qr(n),
            numReadonlySignedAccounts: qr(n),
            numReadonlyUnsignedAccounts: qr(n)
        }
          , a = []
          , l = Wn(n);
        for (let v = 0; v < l; v++)
            a.push(new ne(Fn(n, 0, ti)));
        const c = gn.encode(Fn(n, 0, ti))
          , d = Wn(n)
          , h = [];
        for (let v = 0; v < d; v++) {
            const E = qr(n)
              , A = Wn(n)
              , _ = Fn(n, 0, A)
              , x = Wn(n)
              , b = new Uint8Array(Fn(n, 0, x));
            h.push({
                programIdIndex: E,
                accountKeyIndexes: _,
                data: b
            })
        }
        const y = Wn(n)
          , m = [];
        for (let v = 0; v < y; v++) {
            const E = new ne(Fn(n, 0, ti))
              , A = Wn(n)
              , _ = Fn(n, 0, A)
              , x = Wn(n)
              , b = Fn(n, 0, x);
            m.push({
                accountKey: E,
                writableIndexes: _,
                readonlyIndexes: b
            })
        }
        return new ao({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: c,
            compiledInstructions: h,
            addressTableLookups: m
        })
    }
}
const ly = {
    deserializeMessageVersion(t) {
        const e = t[0]
          , n = e & Mh;
        return n === e ? "legacy" : n
    },
    deserialize: t => {
        const e = ly.deserializeMessageVersion(t);
        if (e === "legacy")
            return Dr.from(t);
        if (e === 0)
            return ao.deserialize(t);
        throw new Error(`Transaction message version ${e} deserialization is not supported`)
    }
};
let ui = function(t) {
    return t[t.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED",
    t[t.PROCESSED = 1] = "PROCESSED",
    t[t.TIMED_OUT = 2] = "TIMED_OUT",
    t[t.NONCE_INVALID = 3] = "NONCE_INVALID",
    t
}({});
const yT = pe.Buffer.alloc(ic).fill(0);
class Ge {
    constructor(e) {
        this.keys = void 0,
        this.programId = void 0,
        this.data = pe.Buffer.alloc(0),
        this.programId = e.programId,
        this.keys = e.keys,
        e.data && (this.data = e.data)
    }
    toJSON() {
        return {
            keys: this.keys.map( ({pubkey: e, isSigner: n, isWritable: r}) => ({
                pubkey: e.toJSON(),
                isSigner: n,
                isWritable: r
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class Be {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(e) {
        if (this.signatures = [],
        this.feePayer = void 0,
        this.instructions = [],
        this.recentBlockhash = void 0,
        this.lastValidBlockHeight = void 0,
        this.nonceInfo = void 0,
        this.minNonceContextSlot = void 0,
        this._message = void 0,
        this._json = void 0,
        !!e)
            if (e.feePayer && (this.feePayer = e.feePayer),
            e.signatures && (this.signatures = e.signatures),
            Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
                const {minContextSlot: n, nonceInfo: r} = e;
                this.minNonceContextSlot = n,
                this.nonceInfo = r
            } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                const {blockhash: n, lastValidBlockHeight: r} = e;
                this.recentBlockhash = n,
                this.lastValidBlockHeight = r
            } else {
                const {recentBlockhash: n, nonceInfo: r} = e;
                r && (this.nonceInfo = r),
                this.recentBlockhash = n
            }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(e => e.toJSON()),
            signers: this.signatures.map( ({publicKey: e}) => e.toJSON())
        }
    }
    add(...e) {
        if (e.length === 0)
            throw new Error("No instructions");
        return e.forEach(n => {
            "instructions"in n ? this.instructions = this.instructions.concat(n.instructions) : "data"in n && "programId"in n && "keys"in n ? this.instructions.push(n) : this.instructions.push(new Ge(n))
        }
        ),
        this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
            return this._message;
        let e, n;
        if (this.nonceInfo ? (e = this.nonceInfo.nonce,
        this.instructions[0] != this.nonceInfo.nonceInstruction ? n = [this.nonceInfo.nonceInstruction, ...this.instructions] : n = this.instructions) : (e = this.recentBlockhash,
        n = this.instructions),
        !e)
            throw new Error("Transaction recentBlockhash required");
        n.length < 1 && console.warn("No instructions provided");
        let r;
        if (this.feePayer)
            r = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            r = this.signatures[0].publicKey;
        else
            throw new Error("Transaction fee payer required");
        for (let E = 0; E < n.length; E++)
            if (n[E].programId === void 0)
                throw new Error(`Transaction instruction index ${E} has undefined program id`);
        const i = []
          , s = [];
        n.forEach(E => {
            E.keys.forEach(_ => {
                s.push({
                    ..._
                })
            }
            );
            const A = E.programId.toString();
            i.includes(A) || i.push(A)
        }
        ),
        i.forEach(E => {
            s.push({
                pubkey: new ne(E),
                isSigner: !1,
                isWritable: !1
            })
        }
        );
        const o = [];
        s.forEach(E => {
            const A = E.pubkey.toString()
              , _ = o.findIndex(x => x.pubkey.toString() === A);
            _ > -1 ? (o[_].isWritable = o[_].isWritable || E.isWritable,
            o[_].isSigner = o[_].isSigner || E.isSigner) : o.push(E)
        }
        ),
        o.sort(function(E, A) {
            if (E.isSigner !== A.isSigner)
                return E.isSigner ? -1 : 1;
            if (E.isWritable !== A.isWritable)
                return E.isWritable ? -1 : 1;
            const _ = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return E.pubkey.toBase58().localeCompare(A.pubkey.toBase58(), "en", _)
        });
        const a = o.findIndex(E => E.pubkey.equals(r));
        if (a > -1) {
            const [E] = o.splice(a, 1);
            E.isSigner = !0,
            E.isWritable = !0,
            o.unshift(E)
        } else
            o.unshift({
                pubkey: r,
                isSigner: !0,
                isWritable: !0
            });
        for (const E of this.signatures) {
            const A = o.findIndex(_ => _.pubkey.equals(E.publicKey));
            if (A > -1)
                o[A].isSigner || (o[A].isSigner = !0,
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else
                throw new Error(`unknown signer: ${E.publicKey.toString()}`)
        }
        let l = 0
          , c = 0
          , d = 0;
        const h = []
          , y = [];
        o.forEach( ({pubkey: E, isSigner: A, isWritable: _}) => {
            A ? (h.push(E.toString()),
            l += 1,
            _ || (c += 1)) : (y.push(E.toString()),
            _ || (d += 1))
        }
        );
        const m = h.concat(y)
          , v = n.map(E => {
            const {data: A, programId: _} = E;
            return {
                programIdIndex: m.indexOf(_.toString()),
                accounts: E.keys.map(x => m.indexOf(x.pubkey.toString())),
                data: gn.encode(A)
            }
        }
        );
        return v.forEach(E => {
            ze(E.programIdIndex >= 0),
            E.accounts.forEach(A => ze(A >= 0))
        }
        ),
        new Dr({
            header: {
                numRequiredSignatures: l,
                numReadonlySignedAccounts: c,
                numReadonlyUnsignedAccounts: d
            },
            accountKeys: m,
            recentBlockhash: e,
            instructions: v
        })
    }
    _compile() {
        const e = this.compileMessage()
          , n = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === n.length && this.signatures.every( (i, s) => n[s].equals(i.publicKey)) || (this.signatures = n.map(r => ({
            signature: null,
            publicKey: r
        }))),
        e
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee(e) {
        return (await e.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const n = new Set;
        this.signatures = e.filter(r => {
            const i = r.toString();
            return n.has(i) ? !1 : (n.add(i),
            !0)
        }
        ).map(r => ({
            signature: null,
            publicKey: r
        }))
    }
    sign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const n = new Set
          , r = [];
        for (const s of e) {
            const o = s.publicKey.toString();
            n.has(o) || (n.add(o),
            r.push(s))
        }
        this.signatures = r.map(s => ({
            signature: null,
            publicKey: s.publicKey
        }));
        const i = this._compile();
        this._partialSign(i, ...r)
    }
    partialSign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const n = new Set
          , r = [];
        for (const s of e) {
            const o = s.publicKey.toString();
            n.has(o) || (n.add(o),
            r.push(s))
        }
        const i = this._compile();
        this._partialSign(i, ...r)
    }
    _partialSign(e, ...n) {
        const r = e.serialize();
        n.forEach(i => {
            const s = iy(r, i.secretKey);
            this._addSignature(i.publicKey, Ie(s))
        }
        )
    }
    addSignature(e, n) {
        this._compile(),
        this._addSignature(e, n)
    }
    _addSignature(e, n) {
        ze(n.length === 64);
        const r = this.signatures.findIndex(i => e.equals(i.publicKey));
        if (r < 0)
            throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[r].signature = pe.Buffer.from(n)
    }
    verifySignatures(e=!0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), e)
    }
    _getMessageSignednessErrors(e, n) {
        const r = {};
        for (const {signature: i, publicKey: s} of this.signatures)
            i === null ? n && (r.missing ||= []).push(s) : aT(i, e, s.toBytes()) || (r.invalid ||= []).push(s);
        return r.invalid || r.missing ? r : void 0
    }
    serialize(e) {
        const {requireAllSignatures: n, verifySignatures: r} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e)
          , i = this.serializeMessage();
        if (r) {
            const s = this._getMessageSignednessErrors(i, n);
            if (s) {
                let o = "Signature verification failed.";
                throw s.invalid && (o += `
Invalid signature for public key${s.invalid.length === 1 ? "" : "(s)"} [\`${s.invalid.map(a => a.toBase58()).join("`, `")}\`].`),
                s.missing && (o += `
Missing signature for public key${s.missing.length === 1 ? "" : "(s)"} [\`${s.missing.map(a => a.toBase58()).join("`, `")}\`].`),
                new Error(o)
            }
        }
        return this._serialize(i)
    }
    _serialize(e) {
        const {signatures: n} = this
          , r = [];
        nr(r, n.length);
        const i = r.length + n.length * 64 + e.length
          , s = pe.Buffer.alloc(i);
        return ze(n.length < 256),
        pe.Buffer.from(r).copy(s, 0),
        n.forEach( ({signature: o}, a) => {
            o !== null && (ze(o.length === 64, "signature has invalid length"),
            pe.Buffer.from(o).copy(s, r.length + a * 64))
        }
        ),
        e.copy(s, r.length + n.length * 64),
        ze(s.length <= hs, `Transaction too large: ${s.length} > ${hs}`),
        s
    }
    get keys() {
        return ze(this.instructions.length === 1),
        this.instructions[0].keys.map(e => e.pubkey)
    }
    get programId() {
        return ze(this.instructions.length === 1),
        this.instructions[0].programId
    }
    get data() {
        return ze(this.instructions.length === 1),
        this.instructions[0].data
    }
    static from(e) {
        let n = [...e];
        const r = Wn(n);
        let i = [];
        for (let s = 0; s < r; s++) {
            const o = Fn(n, 0, ic);
            i.push(gn.encode(pe.Buffer.from(o)))
        }
        return Be.populate(Dr.from(n), i)
    }
    static populate(e, n=[]) {
        const r = new Be;
        return r.recentBlockhash = e.recentBlockhash,
        e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
        n.forEach( (i, s) => {
            const o = {
                signature: i == gn.encode(yT) ? null : gn.decode(i),
                publicKey: e.accountKeys[s]
            };
            r.signatures.push(o)
        }
        ),
        e.instructions.forEach(i => {
            const s = i.accounts.map(o => {
                const a = e.accountKeys[o];
                return {
                    pubkey: a,
                    isSigner: r.signatures.some(l => l.publicKey.toString() === a.toString()) || e.isAccountSigner(o),
                    isWritable: e.isAccountWritable(o)
                }
            }
            );
            r.instructions.push(new Ge({
                keys: s,
                programId: e.accountKeys[i.programIdIndex],
                data: gn.decode(i.data)
            }))
        }
        ),
        r._message = e,
        r._json = r.toJSON(),
        r
    }
}
class cy {
    constructor(e) {
        this.payerKey = void 0,
        this.instructions = void 0,
        this.recentBlockhash = void 0,
        this.payerKey = e.payerKey,
        this.instructions = e.instructions,
        this.recentBlockhash = e.recentBlockhash
    }
    static decompile(e, n) {
        const {header: r, compiledInstructions: i, recentBlockhash: s} = e
          , {numRequiredSignatures: o, numReadonlySignedAccounts: a, numReadonlyUnsignedAccounts: l} = r
          , c = o - a;
        ze(c > 0, "Message header is invalid");
        const d = e.staticAccountKeys.length - o - l;
        ze(d >= 0, "Message header is invalid");
        const h = e.getAccountKeys(n)
          , y = h.get(0);
        if (y === void 0)
            throw new Error("Failed to decompile message because no account keys were found");
        const m = [];
        for (const v of i) {
            const E = [];
            for (const _ of v.accountKeyIndexes) {
                const x = h.get(_);
                if (x === void 0)
                    throw new Error(`Failed to find key for account key index ${_}`);
                const b = _ < o;
                let R;
                b ? R = _ < c : _ < h.staticAccountKeys.length ? R = _ - o < d : R = _ - h.staticAccountKeys.length < h.accountKeysFromLookups.writable.length,
                E.push({
                    pubkey: x,
                    isSigner: _ < r.numRequiredSignatures,
                    isWritable: R
                })
            }
            const A = h.get(v.programIdIndex);
            if (A === void 0)
                throw new Error(`Failed to find program id for program id index ${v.programIdIndex}`);
            m.push(new Ge({
                programId: A,
                data: Ie(v.data),
                keys: E
            }))
        }
        return new cy({
            payerKey: y,
            instructions: m,
            recentBlockhash: s
        })
    }
    compileToLegacyMessage() {
        return Dr.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
        })
    }
    compileToV0Message(e) {
        return ao.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts: e
        })
    }
}
class oc {
    get version() {
        return this.message.version
    }
    constructor(e, n) {
        if (this.signatures = void 0,
        this.message = void 0,
        n !== void 0)
            ze(n.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"),
            this.signatures = n;
        else {
            const r = [];
            for (let i = 0; i < e.header.numRequiredSignatures; i++)
                r.push(new Uint8Array(ic));
            this.signatures = r
        }
        this.message = e
    }
    serialize() {
        const e = this.message.serialize()
          , n = Array();
        nr(n, this.signatures.length);
        const r = de([st(n.length, "encodedSignaturesLength"), mn(hT(), this.signatures.length, "signatures"), st(e.length, "serializedMessage")])
          , i = new Uint8Array(2048)
          , s = r.encode({
            encodedSignaturesLength: new Uint8Array(n),
            signatures: this.signatures,
            serializedMessage: e
        }, i);
        return i.slice(0, s)
    }
    static deserialize(e) {
        let n = [...e];
        const r = []
          , i = Wn(n);
        for (let o = 0; o < i; o++)
            r.push(new Uint8Array(Fn(n, 0, ic)));
        const s = ly.deserialize(new Uint8Array(n));
        return new oc(s,r)
    }
    sign(e) {
        const n = this.message.serialize()
          , r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const i of e) {
            const s = r.findIndex(o => o.equals(i.publicKey));
            ze(s >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`),
            this.signatures[s] = iy(n, i.secretKey)
        }
    }
    addSignature(e, n) {
        ze(n.byteLength === 64, "Signature must be 64 bytes long");
        const i = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(s => s.equals(e));
        ze(i >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),
        this.signatures[i] = n
    }
}
const wT = 160
  , vT = 64
  , bT = wT / vT
  , uS = 1e3 / bT
  , $r = new ne("SysvarC1ock11111111111111111111111111111111")
  , _T = new ne("SysvarEpochSchedu1e111111111111111111111111")
  , xT = new ne("Sysvar1nstructions1111111111111111111111111")
  , Iu = new ne("SysvarRecentB1ockHashes11111111111111111111")
  , Ia = new ne("SysvarRent111111111111111111111111111111111")
  , ST = new ne("SysvarRewards111111111111111111111111111111")
  , kT = new ne("SysvarS1otHashes111111111111111111111111111")
  , ET = new ne("SysvarS1otHistory11111111111111111111111111")
  , Mu = new ne("SysvarStakeHistory1111111111111111111111111");
class ac extends Error {
    constructor({action: e, signature: n, transactionMessage: r, logs: i}) {
        const s = i ? `Logs: 
${JSON.stringify(i.slice(-10), null, 2)}. ` : ""
          , o = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let a;
        switch (e) {
        case "send":
            a = `Transaction ${n} resulted in an error. 
${r}. ` + s + o;
            break;
        case "simulate":
            a = `Simulation failed. 
Message: ${r}. 
` + s + o;
            break;
        default:
            a = `Unknown action '${(l => l)(e)}'`
        }
        super(a),
        this.signature = void 0,
        this.transactionMessage = void 0,
        this.transactionLogs = void 0,
        this.signature = n,
        this.transactionMessage = r,
        this.transactionLogs = i || void 0
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
    }
    get logs() {
        const e = this.transactionLogs;
        if (!(e != null && typeof e == "object" && "then"in e))
            return e
    }
    async getLogs(e) {
        return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise( (n, r) => {
            e.getTransaction(this.signature).then(i => {
                if (i && i.meta && i.meta.logMessages) {
                    const s = i.meta.logMessages;
                    this.transactionLogs = s,
                    n(s)
                } else
                    r(new Error("Log messages not found"))
            }
            ).catch(r)
        }
        )),
        await this.transactionLogs
    }
}
const AT = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class fe extends Error {
    constructor({code: e, message: n, data: r}, i) {
        super(i != null ? `${i}: ${n}` : n),
        this.code = void 0,
        this.data = void 0,
        this.code = e,
        this.data = r,
        this.name = "SolanaJSONRPCError"
    }
}
async function Np(t, e, n, r) {
    const i = r && {
        skipPreflight: r.skipPreflight,
        preflightCommitment: r.preflightCommitment || r.commitment,
        maxRetries: r.maxRetries,
        minContextSlot: r.minContextSlot
    }
      , s = await t.sendTransaction(e, n, i);
    let o;
    if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
        o = (await t.confirmTransaction({
            abortSignal: r?.abortSignal,
            signature: s,
            blockhash: e.recentBlockhash,
            lastValidBlockHeight: e.lastValidBlockHeight
        }, r && r.commitment)).value;
    else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
        const {nonceInstruction: a} = e.nonceInfo
          , l = a.keys[0].pubkey;
        o = (await t.confirmTransaction({
            abortSignal: r?.abortSignal,
            minContextSlot: e.minNonceContextSlot,
            nonceAccountPubkey: l,
            nonceValue: e.nonceInfo.nonce,
            signature: s
        }, r && r.commitment)).value
    } else
        r?.abortSignal != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),
        o = (await t.confirmTransaction(s, r && r.commitment)).value;
    if (o.err)
        throw s != null ? new ac({
            action: "send",
            signature: s,
            transactionMessage: `Status: (${JSON.stringify(o)})`
        }) : new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);
    return s
}
function Ps(t) {
    return new Promise(e => setTimeout(e, t))
}
function je(t, e) {
    const n = t.layout.span >= 0 ? t.layout.span : lS(t, e)
      , r = pe.Buffer.alloc(n)
      , i = Object.assign({
        instruction: t.index
    }, e);
    return t.layout.encode(i, r),
    r
}
function We(t, e) {
    let n;
    try {
        n = t.layout.decode(e)
    } catch (r) {
        throw new Error("invalid instruction; " + r)
    }
    if (n.instruction !== t.index)
        throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${t.index}`);
    return n
}
const dS = dn("lamportsPerSignature")
  , hS = de([ue("version"), ue("state"), Ce("authorizedPubkey"), Ce("nonce"), de([dS], "feeCalculator")])
  , Cp = hS.span;
class Nh {
    constructor(e) {
        this.authorizedPubkey = void 0,
        this.nonce = void 0,
        this.feeCalculator = void 0,
        this.authorizedPubkey = e.authorizedPubkey,
        this.nonce = e.nonce,
        this.feeCalculator = e.feeCalculator
    }
    static fromAccountData(e) {
        const n = hS.decode(Ie(e), 0);
        return new Nh({
            authorizedPubkey: new ne(n.authorizedPubkey),
            nonce: new ne(n.nonce).toString(),
            feeCalculator: n.feeCalculator
        })
    }
}
function Ma(t) {
    const e = st(8, t)
      , n = e.decode.bind(e)
      , r = e.encode.bind(e)
      , i = e
      , s = QI();
    return i.decode = (o, a) => {
        const l = n(o, a);
        return s.decode(l)
    }
    ,
    i.encode = (o, a, l) => {
        const c = s.encode(o);
        return r(c, a, l)
    }
    ,
    i
}
class IT {
    constructor() {}
    static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        const r = ue("instruction").decode(e.data);
        let i;
        for (const [s,o] of Object.entries(et))
            if (o.index == r) {
                i = s;
                break
            }
        if (!i)
            throw new Error("Instruction type incorrect; not a SystemInstruction");
        return i
    }
    static decodeCreateAccount(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {lamports: n, space: r, programId: i} = We(et.Create, e.data);
        return {
            fromPubkey: e.keys[0].pubkey,
            newAccountPubkey: e.keys[1].pubkey,
            lamports: n,
            space: r,
            programId: new ne(i)
        }
    }
    static decodeTransfer(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {lamports: n} = We(et.Transfer, e.data);
        return {
            fromPubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            lamports: n
        }
    }
    static decodeTransferWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {lamports: n, seed: r, programId: i} = We(et.TransferWithSeed, e.data);
        return {
            fromPubkey: e.keys[0].pubkey,
            basePubkey: e.keys[1].pubkey,
            toPubkey: e.keys[2].pubkey,
            lamports: n,
            seed: r,
            programId: new ne(i)
        }
    }
    static decodeAllocate(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 1);
        const {space: n} = We(et.Allocate, e.data);
        return {
            accountPubkey: e.keys[0].pubkey,
            space: n
        }
    }
    static decodeAllocateWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 1);
        const {base: n, seed: r, space: i, programId: s} = We(et.AllocateWithSeed, e.data);
        return {
            accountPubkey: e.keys[0].pubkey,
            basePubkey: new ne(n),
            seed: r,
            space: i,
            programId: new ne(s)
        }
    }
    static decodeAssign(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 1);
        const {programId: n} = We(et.Assign, e.data);
        return {
            accountPubkey: e.keys[0].pubkey,
            programId: new ne(n)
        }
    }
    static decodeAssignWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 1);
        const {base: n, seed: r, programId: i} = We(et.AssignWithSeed, e.data);
        return {
            accountPubkey: e.keys[0].pubkey,
            basePubkey: new ne(n),
            seed: r,
            programId: new ne(i)
        }
    }
    static decodeCreateWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {base: n, seed: r, lamports: i, space: s, programId: o} = We(et.CreateWithSeed, e.data);
        return {
            fromPubkey: e.keys[0].pubkey,
            newAccountPubkey: e.keys[1].pubkey,
            basePubkey: new ne(n),
            seed: r,
            lamports: i,
            space: s,
            programId: new ne(o)
        }
    }
    static decodeNonceInitialize(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {authorized: n} = We(et.InitializeNonceAccount, e.data);
        return {
            noncePubkey: e.keys[0].pubkey,
            authorizedPubkey: new ne(n)
        }
    }
    static decodeNonceAdvance(e) {
        return this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3),
        We(et.AdvanceNonceAccount, e.data),
        {
            noncePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey
        }
    }
    static decodeNonceWithdraw(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 5);
        const {lamports: n} = We(et.WithdrawNonceAccount, e.data);
        return {
            noncePubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey,
            lamports: n
        }
    }
    static decodeNonceAuthorize(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {authorized: n} = We(et.AuthorizeNonceAccount, e.data);
        return {
            noncePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[1].pubkey,
            newAuthorizedPubkey: new ne(n)
        }
    }
    static checkProgramId(e) {
        if (!e.equals(ln.programId))
            throw new Error("invalid instruction; programId is not SystemProgram")
    }
    static checkKeyLength(e, n) {
        if (e.length < n)
            throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${n}`)
    }
}
const et = Object.freeze({
    Create: {
        index: 0,
        layout: de([ue("instruction"), tr("lamports"), tr("space"), Ce("programId")])
    },
    Assign: {
        index: 1,
        layout: de([ue("instruction"), Ce("programId")])
    },
    Transfer: {
        index: 2,
        layout: de([ue("instruction"), Ma("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: de([ue("instruction"), Ce("base"), Vs("seed"), tr("lamports"), tr("space"), Ce("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: de([ue("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: de([ue("instruction"), tr("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: de([ue("instruction"), Ce("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: de([ue("instruction"), Ce("authorized")])
    },
    Allocate: {
        index: 8,
        layout: de([ue("instruction"), tr("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: de([ue("instruction"), Ce("base"), Vs("seed"), tr("space"), Ce("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: de([ue("instruction"), Ce("base"), Vs("seed"), Ce("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: de([ue("instruction"), Ma("lamports"), Vs("seed"), Ce("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: de([ue("instruction")])
    }
});
class ln {
    constructor() {}
    static createAccount(e) {
        const n = et.Create
          , r = je(n, {
            lamports: e.lamports,
            space: e.space,
            programId: Ie(e.programId.toBuffer())
        });
        return new Ge({
            keys: [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.newAccountPubkey,
                isSigner: !0,
                isWritable: !0
            }],
            programId: this.programId,
            data: r
        })
    }
    static transfer(e) {
        let n, r;
        if ("basePubkey"in e) {
            const i = et.TransferWithSeed;
            n = je(i, {
                lamports: BigInt(e.lamports),
                seed: e.seed,
                programId: Ie(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        } else {
            const i = et.Transfer;
            n = je(i, {
                lamports: BigInt(e.lamports)
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        }
        return new Ge({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
    static assign(e) {
        let n, r;
        if ("basePubkey"in e) {
            const i = et.AssignWithSeed;
            n = je(i, {
                base: Ie(e.basePubkey.toBuffer()),
                seed: e.seed,
                programId: Ie(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const i = et.Assign;
            n = je(i, {
                programId: Ie(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Ge({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
    static createAccountWithSeed(e) {
        const n = et.CreateWithSeed
          , r = je(n, {
            base: Ie(e.basePubkey.toBuffer()),
            seed: e.seed,
            lamports: e.lamports,
            space: e.space,
            programId: Ie(e.programId.toBuffer())
        });
        let i = [{
            pubkey: e.fromPubkey,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: e.newAccountPubkey,
            isSigner: !1,
            isWritable: !0
        }];
        return e.basePubkey.equals(e.fromPubkey) || i.push({
            pubkey: e.basePubkey,
            isSigner: !0,
            isWritable: !1
        }),
        new Ge({
            keys: i,
            programId: this.programId,
            data: r
        })
    }
    static createNonceAccount(e) {
        const n = new Be;
        "basePubkey"in e && "seed"in e ? n.add(ln.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: Cp,
            programId: this.programId
        })) : n.add(ln.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: Cp,
            programId: this.programId
        }));
        const r = {
            noncePubkey: e.noncePubkey,
            authorizedPubkey: e.authorizedPubkey
        };
        return n.add(this.nonceInitialize(r)),
        n
    }
    static nonceInitialize(e) {
        const n = et.InitializeNonceAccount
          , r = je(n, {
            authorized: Ie(e.authorizedPubkey.toBuffer())
        })
          , i = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Iu,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Ia,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Ge(i)
    }
    static nonceAdvance(e) {
        const n = et.AdvanceNonceAccount
          , r = je(n)
          , i = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Iu,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Ge(i)
    }
    static nonceWithdraw(e) {
        const n = et.WithdrawNonceAccount
          , r = je(n, {
            lamports: e.lamports
        });
        return new Ge({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Iu,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Ia,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static nonceAuthorize(e) {
        const n = et.AuthorizeNonceAccount
          , r = je(n, {
            authorized: Ie(e.newAuthorizedPubkey.toBuffer())
        });
        return new Ge({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static allocate(e) {
        let n, r;
        if ("basePubkey"in e) {
            const i = et.AllocateWithSeed;
            n = je(i, {
                base: Ie(e.basePubkey.toBuffer()),
                seed: e.seed,
                space: e.space,
                programId: Ie(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const i = et.Allocate;
            n = je(i, {
                space: e.space
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Ge({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
}
ln.programId = new ne("11111111111111111111111111111111");
const MT = hs - 300;
class lo {
    constructor() {}
    static getMinNumSignatures(e) {
        return 2 * (Math.ceil(e / lo.chunkSize) + 1 + 1)
    }
    static async load(e, n, r, i, s) {
        {
            const h = await e.getMinimumBalanceForRentExemption(s.length)
              , y = await e.getAccountInfo(r.publicKey, "confirmed");
            let m = null;
            if (y !== null) {
                if (y.executable)
                    return console.error("Program load failed, account is already executable"),
                    !1;
                y.data.length !== s.length && (m = m || new Be,
                m.add(ln.allocate({
                    accountPubkey: r.publicKey,
                    space: s.length
                }))),
                y.owner.equals(i) || (m = m || new Be,
                m.add(ln.assign({
                    accountPubkey: r.publicKey,
                    programId: i
                }))),
                y.lamports < h && (m = m || new Be,
                m.add(ln.transfer({
                    fromPubkey: n.publicKey,
                    toPubkey: r.publicKey,
                    lamports: h - y.lamports
                })))
            } else
                m = new Be().add(ln.createAccount({
                    fromPubkey: n.publicKey,
                    newAccountPubkey: r.publicKey,
                    lamports: h > 0 ? h : 1,
                    space: s.length,
                    programId: i
                }));
            m !== null && await Np(e, m, [n, r], {
                commitment: "confirmed"
            })
        }
        const o = de([ue("instruction"), ue("offset"), ue("bytesLength"), ue("bytesLengthPadding"), mn(Pe("byte"), ds(ue(), -8), "bytes")])
          , a = lo.chunkSize;
        let l = 0
          , c = s
          , d = [];
        for (; c.length > 0; ) {
            const h = c.slice(0, a)
              , y = pe.Buffer.alloc(a + 16);
            o.encode({
                instruction: 0,
                offset: l,
                bytes: h,
                bytesLength: 0,
                bytesLengthPadding: 0
            }, y);
            const m = new Be().add({
                keys: [{
                    pubkey: r.publicKey,
                    isSigner: !0,
                    isWritable: !0
                }],
                programId: i,
                data: y
            });
            d.push(Np(e, m, [n, r], {
                commitment: "confirmed"
            })),
            e._rpcEndpoint.includes("solana.com") && await Ps(1e3 / 4),
            l += a,
            c = c.slice(a)
        }
        await Promise.all(d);
        {
            const h = de([ue("instruction")])
              , y = pe.Buffer.alloc(h.span);
            h.encode({
                instruction: 1
            }, y);
            const m = new Be().add({
                keys: [{
                    pubkey: r.publicKey,
                    isSigner: !0,
                    isWritable: !0
                }, {
                    pubkey: Ia,
                    isSigner: !1,
                    isWritable: !1
                }],
                programId: i,
                data: y
            })
              , v = "processed"
              , E = await e.sendTransaction(m, [n, r], {
                preflightCommitment: v
            })
              , {context: A, value: _} = await e.confirmTransaction({
                signature: E,
                lastValidBlockHeight: m.lastValidBlockHeight,
                blockhash: m.recentBlockhash
            }, v);
            if (_.err)
                throw new Error(`Transaction ${E} failed (${JSON.stringify(_)})`);
            for (; ; ) {
                try {
                    if (await e.getSlot({
                        commitment: v
                    }) > A.slot)
                        break
                } catch {}
                await new Promise(x => setTimeout(x, Math.round(uS / 2)))
            }
        }
        return !0
    }
}
lo.chunkSize = MT;
const TT = new ne("BPFLoader2111111111111111111111111111111111");
class NT {
    static getMinNumSignatures(e) {
        return lo.getMinNumSignatures(e)
    }
    static load(e, n, r, i, s) {
        return lo.load(e, n, r, s, i)
    }
}
function CT(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var o0, _1;
function RT() {
    if (_1)
        return o0;
    _1 = 1;
    var t = Object.prototype.toString
      , e = Object.keys || function(r) {
        var i = [];
        for (var s in r)
            i.push(s);
        return i
    }
    ;
    function n(r, i) {
        var s, o, a, l, c, d, h;
        if (r === !0)
            return "true";
        if (r === !1)
            return "false";
        switch (typeof r) {
        case "object":
            if (r === null)
                return null;
            if (r.toJSON && typeof r.toJSON == "function")
                return n(r.toJSON(), i);
            if (h = t.call(r),
            h === "[object Array]") {
                for (a = "[",
                o = r.length - 1,
                s = 0; s < o; s++)
                    a += n(r[s], !0) + ",";
                return o > -1 && (a += n(r[s], !0)),
                a + "]"
            } else if (h === "[object Object]") {
                for (l = e(r).sort(),
                o = l.length,
                a = "",
                s = 0; s < o; )
                    c = l[s],
                    d = n(r[c], !1),
                    d !== void 0 && (a && (a += ","),
                    a += JSON.stringify(c) + ":" + d),
                    s++;
                return "{" + a + "}"
            } else
                return JSON.stringify(r);
        case "function":
        case "undefined":
            return i ? null : void 0;
        case "string":
            return JSON.stringify(r);
        default:
            return isFinite(r) ? r : null
        }
    }
    return o0 = function(r) {
        var i = n(r, !1);
        if (i !== void 0)
            return "" + i
    }
    ,
    o0
}
var LT = RT()
  , x1 = CT(LT);
const nl = 32;
function a0(t) {
    let e = 0;
    for (; t > 1; )
        t /= 2,
        e++;
    return e
}
function jT(t) {
    return t === 0 ? 1 : (t--,
    t |= t >> 1,
    t |= t >> 2,
    t |= t >> 4,
    t |= t >> 8,
    t |= t >> 16,
    t |= t >> 32,
    t + 1)
}
class fS {
    constructor(e, n, r, i, s) {
        this.slotsPerEpoch = void 0,
        this.leaderScheduleSlotOffset = void 0,
        this.warmup = void 0,
        this.firstNormalEpoch = void 0,
        this.firstNormalSlot = void 0,
        this.slotsPerEpoch = e,
        this.leaderScheduleSlotOffset = n,
        this.warmup = r,
        this.firstNormalEpoch = i,
        this.firstNormalSlot = s
    }
    getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0]
    }
    getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
            const n = a0(jT(e + nl + 1)) - a0(nl) - 1
              , r = this.getSlotsInEpoch(n)
              , i = e - (r - nl);
            return [n, i]
        } else {
            const n = e - this.firstNormalSlot
              , r = Math.floor(n / this.slotsPerEpoch)
              , i = this.firstNormalEpoch + r
              , s = n % this.slotsPerEpoch;
            return [i, s]
        }
    }
    getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * nl : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
    }
    getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch ? Math.pow(2, e + a0(nl)) : this.slotsPerEpoch
    }
}
var BT = globalThis.fetch;
class PT extends OM {
    constructor(e, n, r) {
        const i = s => {
            const o = BM(s, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...n
            });
            return "socket"in o ? this.underlyingSocket = o.socket : this.underlyingSocket = o,
            o
        }
        ;
        super(i, e, n, r),
        this.underlyingSocket = void 0
    }
    call(...e) {
        const n = this.underlyingSocket?.readyState;
        return n === 1 ? super.call(...e) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + n + ")"))
    }
    notify(...e) {
        const n = this.underlyingSocket?.readyState;
        return n === 1 ? super.notify(...e) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + n + ")"))
    }
}
function OT(t, e) {
    let n;
    try {
        n = t.layout.decode(e)
    } catch (r) {
        throw new Error("invalid instruction; " + r)
    }
    if (n.typeIndex !== t.index)
        throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`);
    return n
}
const S1 = 56;
class Rp {
    constructor(e) {
        this.key = void 0,
        this.state = void 0,
        this.key = e.key,
        this.state = e.state
    }
    isActive() {
        const e = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === e
    }
    static deserialize(e) {
        const n = OT(DT, e)
          , r = e.length - S1;
        ze(r >= 0, "lookup table is invalid"),
        ze(r % 32 === 0, "lookup table is invalid");
        const i = r / 32
          , {addresses: s} = de([mn(Ce(), i, "addresses")]).decode(e.slice(S1));
        return {
            deactivationSlot: n.deactivationSlot,
            lastExtendedSlot: n.lastExtendedSlot,
            lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
            authority: n.authority.length !== 0 ? new ne(n.authority[0]) : void 0,
            addresses: s.map(o => new ne(o))
        }
    }
}
const DT = {
    index: 1,
    layout: de([ue("typeIndex"), Ma("deactivationSlot"), dn("lastExtendedSlot"), Pe("lastExtendedStartIndex"), Pe(), mn(Ce(), ds(Pe(), -1), "authority")])
}
  , zT = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function UT(t) {
    const e = t.match(zT);
    if (e == null)
        throw TypeError(`Failed to validate endpoint URL \`${t}\``);
    const [n,r,i,s] = e
      , o = t.startsWith("https:") ? "wss:" : "ws:"
      , a = i == null ? null : parseInt(i.slice(1), 10)
      , l = a == null ? "" : `:${a + 1}`;
    return `${o}//${r}${l}${s}`
}
const yt = Sc(Xm(ne), re(), t => new ne(t))
  , pS = ey([re(), pt("base64")])
  , uy = Sc(Xm(pe.Buffer), pS, t => pe.Buffer.from(t[0], "base64"))
  , gS = 30 * 1e3;
function WT(t) {
    if (/^https?:/.test(t) === !1)
        throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return t
}
function Je(t) {
    let e, n;
    if (typeof t == "string")
        e = t;
    else if (t) {
        const {commitment: r, ...i} = t;
        e = r,
        n = i
    }
    return {
        commitment: e,
        config: n
    }
}
function k1(t) {
    return t.map(e => "memcmp"in e ? {
        ...e,
        memcmp: {
            ...e.memcmp,
            encoding: e.memcmp.encoding ?? "base58"
        }
    } : e)
}
function mS(t) {
    return On([Q({
        jsonrpc: pt("2.0"),
        id: re(),
        result: t
    }), Q({
        jsonrpc: pt("2.0"),
        id: re(),
        error: Q({
            code: Fa(),
            message: re(),
            data: ge(rM())
        })
    })])
}
const FT = mS(Fa());
function Ae(t) {
    return Sc(mS(t), FT, e => "error"in e ? e : {
        ...e,
        result: se(e.result, t)
    })
}
function It(t) {
    return Ae(Q({
        context: Q({
            slot: V()
        }),
        value: t
    }))
}
function Ch(t) {
    return Q({
        context: Q({
            slot: V()
        }),
        value: t
    })
}
function l0(t, e) {
    return t === 0 ? new ao({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(n => new ne(n)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(n => ({
            programIdIndex: n.programIdIndex,
            accountKeyIndexes: n.accounts,
            data: gn.decode(n.data)
        })),
        addressTableLookups: e.addressTableLookups
    }) : new Dr(e)
}
const $T = Q({
    foundation: V(),
    foundationTerm: V(),
    initial: V(),
    taper: V(),
    terminal: V()
})
  , KT = Ae(ae(le(Q({
    epoch: V(),
    effectiveSlot: V(),
    amount: V(),
    postBalance: V(),
    commission: ge(le(V()))
}))))
  , VT = ae(Q({
    slot: V(),
    prioritizationFee: V()
}))
  , HT = Q({
    total: V(),
    validator: V(),
    foundation: V(),
    epoch: V()
})
  , qT = Q({
    epoch: V(),
    slotIndex: V(),
    slotsInEpoch: V(),
    absoluteSlot: V(),
    blockHeight: ge(V()),
    transactionCount: ge(V())
})
  , GT = Q({
    slotsPerEpoch: V(),
    leaderScheduleSlotOffset: V(),
    warmup: ni(),
    firstNormalEpoch: V(),
    firstNormalSlot: V()
})
  , YT = $x(re(), ae(V()))
  , wo = le(On([Q({}), re()]))
  , ZT = Q({
    err: wo
})
  , QT = pt("receivedSignature")
  , JT = Q({
    "solana-core": re(),
    "feature-set": ge(V())
})
  , XT = Q({
    program: re(),
    programId: yt,
    parsed: Fa()
})
  , e3 = Q({
    programId: yt,
    accounts: ae(yt),
    data: re()
})
  , E1 = It(Q({
    err: le(On([Q({}), re()])),
    logs: le(ae(re())),
    accounts: ge(le(ae(le(Q({
        executable: ni(),
        owner: re(),
        lamports: V(),
        data: ae(re()),
        rentEpoch: ge(V())
    }))))),
    unitsConsumed: ge(V()),
    returnData: ge(le(Q({
        programId: re(),
        data: ey([re(), pt("base64")])
    }))),
    innerInstructions: ge(le(ae(Q({
        index: V(),
        instructions: ae(On([XT, e3]))
    }))))
}))
  , t3 = It(Q({
    byIdentity: $x(re(), ae(V())),
    range: Q({
        firstSlot: V(),
        lastSlot: V()
    })
}));
function n3(t, e, n, r, i, s) {
    const o = n || BT;
    let a;
    s != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let l;
    return r && (l = async (d, h) => {
        const y = await new Promise( (m, v) => {
            try {
                r(d, h, (E, A) => m([E, A]))
            } catch (E) {
                v(E)
            }
        }
        );
        return await o(...y)
    }
    ),
    new RM(async (d, h) => {
        const y = {
            method: "POST",
            body: d,
            agent: a,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, e || {}, nN)
        };
        try {
            let m = 5, v, E = 500;
            for (; l ? v = await l(t, y) : v = await o(t, y),
            !(v.status !== 429 || i === !0 || (m -= 1,
            m === 0)); )
                console.error(`Server responded with ${v.status} ${v.statusText}.  Retrying after ${E}ms delay...`),
                await Ps(E),
                E *= 2;
            const A = await v.text();
            v.ok ? h(null, A) : h(new Error(`${v.status} ${v.statusText}: ${A}`))
        } catch (m) {
            m instanceof Error && h(m)
        }
    }
    ,{})
}
function r3(t) {
    return (e, n) => new Promise( (r, i) => {
        t.request(e, n, (s, o) => {
            if (s) {
                i(s);
                return
            }
            r(o)
        }
        )
    }
    )
}
function i3(t) {
    return e => new Promise( (n, r) => {
        e.length === 0 && n([]);
        const i = e.map(s => t.request(s.methodName, s.args));
        t.request(i, (s, o) => {
            if (s) {
                r(s);
                return
            }
            n(o)
        }
        )
    }
    )
}
const s3 = Ae($T)
  , o3 = Ae(HT)
  , a3 = Ae(VT)
  , l3 = Ae(qT)
  , c3 = Ae(GT)
  , u3 = Ae(YT)
  , d3 = Ae(V())
  , h3 = It(Q({
    total: V(),
    circulating: V(),
    nonCirculating: V(),
    nonCirculatingAccounts: ae(yt)
}))
  , Lp = Q({
    amount: re(),
    uiAmount: le(V()),
    decimals: V(),
    uiAmountString: ge(re())
})
  , f3 = It(ae(Q({
    address: yt,
    amount: re(),
    uiAmount: le(V()),
    decimals: V(),
    uiAmountString: ge(re())
})))
  , p3 = It(ae(Q({
    pubkey: yt,
    account: Q({
        executable: ni(),
        owner: yt,
        lamports: V(),
        data: uy,
        rentEpoch: V()
    })
})))
  , jp = Q({
    program: re(),
    parsed: Fa(),
    space: V()
})
  , g3 = It(ae(Q({
    pubkey: yt,
    account: Q({
        executable: ni(),
        owner: yt,
        lamports: V(),
        data: jp,
        rentEpoch: V()
    })
})))
  , m3 = It(ae(Q({
    lamports: V(),
    address: yt
})))
  , lc = Q({
    executable: ni(),
    owner: yt,
    lamports: V(),
    data: uy,
    rentEpoch: V()
})
  , y3 = Q({
    pubkey: yt,
    account: lc
})
  , w3 = Sc(On([Xm(pe.Buffer), jp]), On([pS, jp]), t => Array.isArray(t) ? se(t, uy) : t)
  , Bp = Q({
    executable: ni(),
    owner: yt,
    lamports: V(),
    data: w3,
    rentEpoch: V()
})
  , v3 = Q({
    pubkey: yt,
    account: Bp
})
  , b3 = Q({
    state: On([pt("active"), pt("inactive"), pt("activating"), pt("deactivating")]),
    active: V(),
    inactive: V()
})
  , _3 = Ae(ae(Q({
    signature: re(),
    slot: V(),
    err: wo,
    memo: le(re()),
    blockTime: ge(le(V()))
})))
  , x3 = Ae(ae(Q({
    signature: re(),
    slot: V(),
    err: wo,
    memo: le(re()),
    blockTime: ge(le(V()))
})))
  , S3 = Q({
    subscription: V(),
    result: Ch(lc)
})
  , k3 = Q({
    pubkey: yt,
    account: lc
})
  , E3 = Q({
    subscription: V(),
    result: Ch(k3)
})
  , A3 = Q({
    parent: V(),
    slot: V(),
    root: V()
})
  , I3 = Q({
    subscription: V(),
    result: A3
})
  , M3 = On([Q({
    type: On([pt("firstShredReceived"), pt("completed"), pt("optimisticConfirmation"), pt("root")]),
    slot: V(),
    timestamp: V()
}), Q({
    type: pt("createdBank"),
    parent: V(),
    slot: V(),
    timestamp: V()
}), Q({
    type: pt("frozen"),
    slot: V(),
    timestamp: V(),
    stats: Q({
        numTransactionEntries: V(),
        numSuccessfulTransactions: V(),
        numFailedTransactions: V(),
        maxTransactionsPerEntry: V()
    })
}), Q({
    type: pt("dead"),
    slot: V(),
    timestamp: V(),
    err: re()
})])
  , T3 = Q({
    subscription: V(),
    result: M3
})
  , N3 = Q({
    subscription: V(),
    result: Ch(On([ZT, QT]))
})
  , C3 = Q({
    subscription: V(),
    result: V()
})
  , R3 = Q({
    pubkey: re(),
    gossip: le(re()),
    tpu: le(re()),
    rpc: le(re()),
    version: le(re())
})
  , A1 = Q({
    votePubkey: re(),
    nodePubkey: re(),
    activatedStake: V(),
    epochVoteAccount: ni(),
    epochCredits: ae(ey([V(), V(), V()])),
    commission: V(),
    lastVote: V(),
    rootSlot: le(V())
})
  , L3 = Ae(Q({
    current: ae(A1),
    delinquent: ae(A1)
}))
  , j3 = On([pt("processed"), pt("confirmed"), pt("finalized")])
  , B3 = Q({
    slot: V(),
    confirmations: le(V()),
    err: wo,
    confirmationStatus: ge(j3)
})
  , P3 = It(ae(le(B3)))
  , O3 = Ae(V())
  , yS = Q({
    accountKey: yt,
    writableIndexes: ae(V()),
    readonlyIndexes: ae(V())
})
  , dy = Q({
    signatures: ae(re()),
    message: Q({
        accountKeys: ae(re()),
        header: Q({
            numRequiredSignatures: V(),
            numReadonlySignedAccounts: V(),
            numReadonlyUnsignedAccounts: V()
        }),
        instructions: ae(Q({
            accounts: ae(V()),
            data: re(),
            programIdIndex: V()
        })),
        recentBlockhash: re(),
        addressTableLookups: ge(ae(yS))
    })
})
  , wS = Q({
    pubkey: yt,
    signer: ni(),
    writable: ni(),
    source: ge(On([pt("transaction"), pt("lookupTable")]))
})
  , vS = Q({
    accountKeys: ae(wS),
    signatures: ae(re())
})
  , bS = Q({
    parsed: Fa(),
    program: re(),
    programId: yt
})
  , _S = Q({
    accounts: ae(yt),
    data: re(),
    programId: yt
})
  , D3 = On([_S, bS])
  , z3 = On([Q({
    parsed: Fa(),
    program: re(),
    programId: re()
}), Q({
    accounts: ae(re()),
    data: re(),
    programId: re()
})])
  , xS = Sc(D3, z3, t => "accounts"in t ? se(t, _S) : se(t, bS))
  , SS = Q({
    signatures: ae(re()),
    message: Q({
        accountKeys: ae(wS),
        instructions: ae(xS),
        recentBlockhash: re(),
        addressTableLookups: ge(le(ae(yS)))
    })
})
  , Wd = Q({
    accountIndex: V(),
    mint: re(),
    owner: ge(re()),
    programId: ge(re()),
    uiTokenAmount: Lp
})
  , kS = Q({
    writable: ae(yt),
    readonly: ae(yt)
})
  , Rh = Q({
    err: wo,
    fee: V(),
    innerInstructions: ge(le(ae(Q({
        index: V(),
        instructions: ae(Q({
            accounts: ae(V()),
            data: re(),
            programIdIndex: V()
        }))
    })))),
    preBalances: ae(V()),
    postBalances: ae(V()),
    logMessages: ge(le(ae(re()))),
    preTokenBalances: ge(le(ae(Wd))),
    postTokenBalances: ge(le(ae(Wd))),
    loadedAddresses: ge(kS),
    computeUnitsConsumed: ge(V()),
    costUnits: ge(V())
})
  , hy = Q({
    err: wo,
    fee: V(),
    innerInstructions: ge(le(ae(Q({
        index: V(),
        instructions: ae(xS)
    })))),
    preBalances: ae(V()),
    postBalances: ae(V()),
    logMessages: ge(le(ae(re()))),
    preTokenBalances: ge(le(ae(Wd))),
    postTokenBalances: ge(le(ae(Wd))),
    loadedAddresses: ge(kS),
    computeUnitsConsumed: ge(V()),
    costUnits: ge(V())
})
  , $a = On([pt(0), pt("legacy")])
  , vo = Q({
    pubkey: re(),
    lamports: V(),
    postBalance: le(V()),
    rewardType: le(re()),
    commission: ge(le(V()))
})
  , U3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    transactions: ae(Q({
        transaction: dy,
        meta: le(Rh),
        version: ge($a)
    })),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , W3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , F3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    transactions: ae(Q({
        transaction: vS,
        meta: le(Rh),
        version: ge($a)
    })),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , $3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    transactions: ae(Q({
        transaction: SS,
        meta: le(hy),
        version: ge($a)
    })),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , K3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    transactions: ae(Q({
        transaction: vS,
        meta: le(hy),
        version: ge($a)
    })),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , V3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    rewards: ge(ae(vo)),
    blockTime: le(V()),
    blockHeight: le(V())
})))
  , H3 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    transactions: ae(Q({
        transaction: dy,
        meta: le(Rh)
    })),
    rewards: ge(ae(vo)),
    blockTime: le(V())
})))
  , I1 = Ae(le(Q({
    blockhash: re(),
    previousBlockhash: re(),
    parentSlot: V(),
    signatures: ae(re()),
    blockTime: le(V())
})))
  , c0 = Ae(le(Q({
    slot: V(),
    meta: le(Rh),
    blockTime: ge(le(V())),
    transaction: dy,
    version: ge($a)
})))
  , lu = Ae(le(Q({
    slot: V(),
    transaction: SS,
    meta: le(hy),
    blockTime: ge(le(V())),
    version: ge($a)
})))
  , q3 = It(Q({
    blockhash: re(),
    lastValidBlockHeight: V()
}))
  , G3 = It(ni())
  , Y3 = Q({
    slot: V(),
    numTransactions: V(),
    numSlots: V(),
    samplePeriodSecs: V()
})
  , Z3 = Ae(ae(Y3))
  , Q3 = It(le(Q({
    feeCalculator: Q({
        lamportsPerSignature: V()
    })
})))
  , J3 = Ae(re())
  , X3 = Ae(re())
  , eN = Q({
    err: wo,
    logs: ae(re()),
    signature: re()
})
  , tN = Q({
    result: Ch(eN),
    subscription: V()
})
  , nN = {
    "solana-client": "js/1.0.0-maintenance"
};
class ES {
    constructor(e, n) {
        this._commitment = void 0,
        this._confirmTransactionInitialTimeout = void 0,
        this._rpcEndpoint = void 0,
        this._rpcWsEndpoint = void 0,
        this._rpcClient = void 0,
        this._rpcRequest = void 0,
        this._rpcBatchRequest = void 0,
        this._rpcWebSocket = void 0,
        this._rpcWebSocketConnected = !1,
        this._rpcWebSocketHeartbeat = null,
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketGeneration = 0,
        this._disableBlockhashCaching = !1,
        this._pollingBlockhash = !1,
        this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        },
        this._nextClientSubscriptionId = 0,
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {},
        this._subscriptionHashByClientSubscriptionId = {},
        this._subscriptionStateChangeCallbacksByHash = {},
        this._subscriptionCallbacksByServerSubscriptionId = {},
        this._subscriptionsByHash = {},
        this._subscriptionsAutoDisposedByRpc = new Set,
        this.getBlockHeight = ( () => {
            const c = {};
            return async d => {
                const {commitment: h, config: y} = Je(d)
                  , m = this._buildArgs([], h, void 0, y)
                  , v = x1(m);
                return c[v] = c[v] ?? (async () => {
                    try {
                        const E = await this._rpcRequest("getBlockHeight", m)
                          , A = se(E, Ae(V()));
                        if ("error"in A)
                            throw new fe(A.error,"failed to get block height information");
                        return A.result
                    } finally {
                        delete c[v]
                    }
                }
                )(),
                await c[v]
            }
        }
        )();
        let r, i, s, o, a, l;
        n && typeof n == "string" ? this._commitment = n : n && (this._commitment = n.commitment,
        this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout,
        r = n.wsEndpoint,
        i = n.httpHeaders,
        s = n.fetch,
        o = n.fetchMiddleware,
        a = n.disableRetryOnRateLimit,
        l = n.httpAgent),
        this._rpcEndpoint = WT(e),
        this._rpcWsEndpoint = r || UT(e),
        this._rpcClient = n3(e, i, s, o, a, l),
        this._rpcRequest = r3(this._rpcClient),
        this._rpcBatchRequest = i3(this._rpcClient),
        this._rpcWebSocket = new PT(this._rpcWsEndpoint,{
            autoconnect: !1,
            max_reconnects: 1 / 0
        }),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)),
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)),
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)),
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)),
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)),
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)),
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgs([e.toBase58()], r, void 0, i)
          , o = await this._rpcRequest("getBalance", s)
          , a = se(o, It(V()));
        if ("error"in a)
            throw new fe(a.error,`failed to get balance for ${e.toBase58()}`);
        return a.result
    }
    async getBalance(e, n) {
        return await this.getBalanceAndContext(e, n).then(r => r.value).catch(r => {
            throw new Error("failed to get balance of account " + e.toBase58() + ": " + r)
        }
        )
    }
    async getBlockTime(e) {
        const n = await this._rpcRequest("getBlockTime", [e])
          , r = se(n, Ae(le(V())));
        if ("error"in r)
            throw new fe(r.error,`failed to get block time for slot ${e}`);
        return r.result
    }
    async getMinimumLedgerSlot() {
        const e = await this._rpcRequest("minimumLedgerSlot", [])
          , n = se(e, Ae(V()));
        if ("error"in n)
            throw new fe(n.error,"failed to get minimum ledger slot");
        return n.result
    }
    async getFirstAvailableBlock() {
        const e = await this._rpcRequest("getFirstAvailableBlock", [])
          , n = se(e, d3);
        if ("error"in n)
            throw new fe(n.error,"failed to get first available block");
        return n.result
    }
    async getSupply(e) {
        let n = {};
        typeof e == "string" ? n = {
            commitment: e
        } : e ? n = {
            ...e,
            commitment: e && e.commitment || this.commitment
        } : n = {
            commitment: this.commitment
        };
        const r = await this._rpcRequest("getSupply", [n])
          , i = se(r, h3);
        if ("error"in i)
            throw new fe(i.error,"failed to get supply");
        return i.result
    }
    async getTokenSupply(e, n) {
        const r = this._buildArgs([e.toBase58()], n)
          , i = await this._rpcRequest("getTokenSupply", r)
          , s = se(i, It(Lp));
        if ("error"in s)
            throw new fe(s.error,"failed to get token supply");
        return s.result
    }
    async getTokenAccountBalance(e, n) {
        const r = this._buildArgs([e.toBase58()], n)
          , i = await this._rpcRequest("getTokenAccountBalance", r)
          , s = se(i, It(Lp));
        if ("error"in s)
            throw new fe(s.error,"failed to get token account balance");
        return s.result
    }
    async getTokenAccountsByOwner(e, n, r) {
        const {commitment: i, config: s} = Je(r);
        let o = [e.toBase58()];
        "mint"in n ? o.push({
            mint: n.mint.toBase58()
        }) : o.push({
            programId: n.programId.toBase58()
        });
        const a = this._buildArgs(o, i, "base64", s)
          , l = await this._rpcRequest("getTokenAccountsByOwner", a)
          , c = se(l, p3);
        if ("error"in c)
            throw new fe(c.error,`failed to get token accounts owned by account ${e.toBase58()}`);
        return c.result
    }
    async getParsedTokenAccountsByOwner(e, n, r) {
        let i = [e.toBase58()];
        "mint"in n ? i.push({
            mint: n.mint.toBase58()
        }) : i.push({
            programId: n.programId.toBase58()
        });
        const s = this._buildArgs(i, r, "jsonParsed")
          , o = await this._rpcRequest("getTokenAccountsByOwner", s)
          , a = se(o, g3);
        if ("error"in a)
            throw new fe(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);
        return a.result
    }
    async getLargestAccounts(e) {
        const n = {
            ...e,
            commitment: e && e.commitment || this.commitment
        }
          , r = n.filter || n.commitment ? [n] : []
          , i = await this._rpcRequest("getLargestAccounts", r)
          , s = se(i, m3);
        if ("error"in s)
            throw new fe(s.error,"failed to get largest accounts");
        return s.result
    }
    async getTokenLargestAccounts(e, n) {
        const r = this._buildArgs([e.toBase58()], n)
          , i = await this._rpcRequest("getTokenLargestAccounts", r)
          , s = se(i, f3);
        if ("error"in s)
            throw new fe(s.error,"failed to get token largest accounts");
        return s.result
    }
    async getAccountInfoAndContext(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgs([e.toBase58()], r, "base64", i)
          , o = await this._rpcRequest("getAccountInfo", s)
          , a = se(o, It(le(lc)));
        if ("error"in a)
            throw new fe(a.error,`failed to get info about account ${e.toBase58()}`);
        return a.result
    }
    async getParsedAccountInfo(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgs([e.toBase58()], r, "jsonParsed", i)
          , o = await this._rpcRequest("getAccountInfo", s)
          , a = se(o, It(le(Bp)));
        if ("error"in a)
            throw new fe(a.error,`failed to get info about account ${e.toBase58()}`);
        return a.result
    }
    async getAccountInfo(e, n) {
        try {
            return (await this.getAccountInfoAndContext(e, n)).value
        } catch (r) {
            throw new Error("failed to get info about account " + e.toBase58() + ": " + r)
        }
    }
    async getMultipleParsedAccounts(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = e.map(c => c.toBase58())
          , o = this._buildArgs([s], r, "jsonParsed", i)
          , a = await this._rpcRequest("getMultipleAccounts", o)
          , l = se(a, It(ae(le(Bp))));
        if ("error"in l)
            throw new fe(l.error,`failed to get info for accounts ${s}`);
        return l.result
    }
    async getMultipleAccountsInfoAndContext(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = e.map(c => c.toBase58())
          , o = this._buildArgs([s], r, "base64", i)
          , a = await this._rpcRequest("getMultipleAccounts", o)
          , l = se(a, It(ae(le(lc))));
        if ("error"in l)
            throw new fe(l.error,`failed to get info for accounts ${s}`);
        return l.result
    }
    async getMultipleAccountsInfo(e, n) {
        return (await this.getMultipleAccountsInfoAndContext(e, n)).value
    }
    async getStakeActivation(e, n, r) {
        const {commitment: i, config: s} = Je(n)
          , o = this._buildArgs([e.toBase58()], i, void 0, {
            ...s,
            epoch: r ?? s?.epoch
        })
          , a = await this._rpcRequest("getStakeActivation", o)
          , l = se(a, Ae(b3));
        if ("error"in l)
            throw new fe(l.error,`failed to get Stake Activation ${e.toBase58()}`);
        return l.result
    }
    async getProgramAccounts(e, n) {
        const {commitment: r, config: i} = Je(n)
          , {encoding: s, ...o} = i || {}
          , a = this._buildArgs([e.toBase58()], r, s || "base64", {
            ...o,
            ...o.filters ? {
                filters: k1(o.filters)
            } : null
        })
          , l = await this._rpcRequest("getProgramAccounts", a)
          , c = ae(y3)
          , d = o.withContext === !0 ? se(l, It(c)) : se(l, Ae(c));
        if ("error"in d)
            throw new fe(d.error,`failed to get accounts owned by program ${e.toBase58()}`);
        return d.result
    }
    async getParsedProgramAccounts(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgs([e.toBase58()], r, "jsonParsed", i)
          , o = await this._rpcRequest("getProgramAccounts", s)
          , a = se(o, Ae(ae(v3)));
        if ("error"in a)
            throw new fe(a.error,`failed to get accounts owned by program ${e.toBase58()}`);
        return a.result
    }
    async confirmTransaction(e, n) {
        let r;
        if (typeof e == "string")
            r = e;
        else {
            const s = e;
            if (s.abortSignal?.aborted)
                return Promise.reject(s.abortSignal.reason);
            r = s.signature
        }
        let i;
        try {
            i = gn.decode(r)
        } catch {
            throw new Error("signature must be base58 encoded: " + r)
        }
        return ze(i.length === 64, "signature has invalid length"),
        typeof e == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: n || this.commitment,
            signature: r
        }) : "lastValidBlockHeight"in e ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: n || this.commitment,
            strategy: e
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: n || this.commitment,
            strategy: e
        })
    }
    getCancellationPromise(e) {
        return new Promise( (n, r) => {
            e != null && (e.aborted ? r(e.reason) : e.addEventListener("abort", () => {
                r(e.reason)
            }
            ))
        }
        )
    }
    getTransactionConfirmationPromise({commitment: e, signature: n}) {
        let r, i, s = !1;
        const o = new Promise( (l, c) => {
            try {
                r = this.onSignature(n, (h, y) => {
                    r = void 0;
                    const m = {
                        context: y,
                        value: h
                    };
                    l({
                        __type: ui.PROCESSED,
                        response: m
                    })
                }
                , e);
                const d = new Promise(h => {
                    r == null ? h() : i = this._onSubscriptionStateChange(r, y => {
                        y === "subscribed" && h()
                    }
                    )
                }
                );
                (async () => {
                    if (await d,
                    s)
                        return;
                    const h = await this.getSignatureStatus(n);
                    if (s || h == null)
                        return;
                    const {context: y, value: m} = h;
                    if (m != null)
                        if (m?.err)
                            c(m.err);
                        else {
                            switch (e) {
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                                {
                                    if (m.confirmationStatus === "processed")
                                        return;
                                    break
                                }
                            case "finalized":
                            case "max":
                            case "root":
                                {
                                    if (m.confirmationStatus === "processed" || m.confirmationStatus === "confirmed")
                                        return;
                                    break
                                }
                            case "processed":
                            case "recent":
                            }
                            s = !0,
                            l({
                                __type: ui.PROCESSED,
                                response: {
                                    context: y,
                                    value: m
                                }
                            })
                        }
                }
                )()
            } catch (d) {
                c(d)
            }
        }
        );
        return {
            abortConfirmation: () => {
                i && (i(),
                i = void 0),
                r != null && (this.removeSignatureListener(r),
                r = void 0)
            }
            ,
            confirmationPromise: o
        }
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment: e, strategy: {abortSignal: n, lastValidBlockHeight: r, signature: i}}) {
        let s = !1;
        const o = new Promise(h => {
            const y = async () => {
                try {
                    return await this.getBlockHeight(e)
                } catch {
                    return -1
                }
            }
            ;
            (async () => {
                let m = await y();
                if (!s) {
                    for (; m <= r; )
                        if (await Ps(1e3),
                        s || (m = await y(),
                        s))
                            return;
                    h({
                        __type: ui.BLOCKHEIGHT_EXCEEDED
                    })
                }
            }
            )()
        }
        )
          , {abortConfirmation: a, confirmationPromise: l} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: i
        })
          , c = this.getCancellationPromise(n);
        let d;
        try {
            const h = await Promise.race([c, l, o]);
            if (h.__type === ui.PROCESSED)
                d = h.response;
            else
                throw new oy(i)
        } finally {
            s = !0,
            a()
        }
        return d
    }
    async confirmTransactionUsingDurableNonceStrategy({commitment: e, strategy: {abortSignal: n, minContextSlot: r, nonceAccountPubkey: i, nonceValue: s, signature: o}}) {
        let a = !1;
        const l = new Promise(m => {
            let v = s
              , E = null;
            const A = async () => {
                try {
                    const {context: _, value: x} = await this.getNonceAndContext(i, {
                        commitment: e,
                        minContextSlot: r
                    });
                    return E = _.slot,
                    x?.nonce
                } catch {
                    return v
                }
            }
            ;
            (async () => {
                if (v = await A(),
                !a)
                    for (; ; ) {
                        if (s !== v) {
                            m({
                                __type: ui.NONCE_INVALID,
                                slotInWhichNonceDidAdvance: E
                            });
                            return
                        }
                        if (await Ps(2e3),
                        a || (v = await A(),
                        a))
                            return
                    }
            }
            )()
        }
        )
          , {abortConfirmation: c, confirmationPromise: d} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: o
        })
          , h = this.getCancellationPromise(n);
        let y;
        try {
            const m = await Promise.race([h, d, l]);
            if (m.__type === ui.PROCESSED)
                y = m.response;
            else {
                let v;
                for (; ; ) {
                    const E = await this.getSignatureStatus(o);
                    if (E == null)
                        break;
                    if (E.context.slot < (m.slotInWhichNonceDidAdvance ?? r)) {
                        await Ps(400);
                        continue
                    }
                    v = E;
                    break
                }
                if (v?.value) {
                    const E = e || "finalized"
                      , {confirmationStatus: A} = v.value;
                    switch (E) {
                    case "processed":
                    case "recent":
                        if (A !== "processed" && A !== "confirmed" && A !== "finalized")
                            throw new ra(o);
                        break;
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                        if (A !== "confirmed" && A !== "finalized")
                            throw new ra(o);
                        break;
                    case "finalized":
                    case "max":
                    case "root":
                        if (A !== "finalized")
                            throw new ra(o);
                        break;
                    default:
                    }
                    y = {
                        context: v.context,
                        value: {
                            err: v.value.err
                        }
                    }
                } else
                    throw new ra(o)
            }
        } finally {
            a = !0,
            c()
        }
        return y
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({commitment: e, signature: n}) {
        let r;
        const i = new Promise(l => {
            let c = this._confirmTransactionInitialTimeout || 6e4;
            switch (e) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
                {
                    c = this._confirmTransactionInitialTimeout || 3e4;
                    break
                }
            }
            r = setTimeout( () => l({
                __type: ui.TIMED_OUT,
                timeoutMs: c
            }), c)
        }
        )
          , {abortConfirmation: s, confirmationPromise: o} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: n
        });
        let a;
        try {
            const l = await Promise.race([o, i]);
            if (l.__type === ui.PROCESSED)
                a = l.response;
            else
                throw new ay(n,l.timeoutMs / 1e3)
        } finally {
            clearTimeout(r),
            s()
        }
        return a
    }
    async getClusterNodes() {
        const e = await this._rpcRequest("getClusterNodes", [])
          , n = se(e, Ae(ae(R3)));
        if ("error"in n)
            throw new fe(n.error,"failed to get cluster nodes");
        return n.result
    }
    async getVoteAccounts(e) {
        const n = this._buildArgs([], e)
          , r = await this._rpcRequest("getVoteAccounts", n)
          , i = se(r, L3);
        if ("error"in i)
            throw new fe(i.error,"failed to get vote accounts");
        return i.result
    }
    async getSlot(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, void 0, r)
          , s = await this._rpcRequest("getSlot", i)
          , o = se(s, Ae(V()));
        if ("error"in o)
            throw new fe(o.error,"failed to get slot");
        return o.result
    }
    async getSlotLeader(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, void 0, r)
          , s = await this._rpcRequest("getSlotLeader", i)
          , o = se(s, Ae(re()));
        if ("error"in o)
            throw new fe(o.error,"failed to get slot leader");
        return o.result
    }
    async getSlotLeaders(e, n) {
        const r = [e, n]
          , i = await this._rpcRequest("getSlotLeaders", r)
          , s = se(i, Ae(ae(yt)));
        if ("error"in s)
            throw new fe(s.error,"failed to get slot leaders");
        return s.result
    }
    async getSignatureStatus(e, n) {
        const {context: r, value: i} = await this.getSignatureStatuses([e], n);
        ze(i.length === 1);
        const s = i[0];
        return {
            context: r,
            value: s
        }
    }
    async getSignatureStatuses(e, n) {
        const r = [e];
        n && r.push(n);
        const i = await this._rpcRequest("getSignatureStatuses", r)
          , s = se(i, P3);
        if ("error"in s)
            throw new fe(s.error,"failed to get signature status");
        return s.result
    }
    async getTransactionCount(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, void 0, r)
          , s = await this._rpcRequest("getTransactionCount", i)
          , o = se(s, Ae(V()));
        if ("error"in o)
            throw new fe(o.error,"failed to get transaction count");
        return o.result
    }
    async getTotalSupply(e) {
        return (await this.getSupply({
            commitment: e,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor(e) {
        const n = this._buildArgs([], e)
          , r = await this._rpcRequest("getInflationGovernor", n)
          , i = se(r, s3);
        if ("error"in i)
            throw new fe(i.error,"failed to get inflation");
        return i.result
    }
    async getInflationReward(e, n, r) {
        const {commitment: i, config: s} = Je(r)
          , o = this._buildArgs([e.map(c => c.toBase58())], i, void 0, {
            ...s,
            epoch: n ?? s?.epoch
        })
          , a = await this._rpcRequest("getInflationReward", o)
          , l = se(a, KT);
        if ("error"in l)
            throw new fe(l.error,"failed to get inflation reward");
        return l.result
    }
    async getInflationRate() {
        const e = await this._rpcRequest("getInflationRate", [])
          , n = se(e, o3);
        if ("error"in n)
            throw new fe(n.error,"failed to get inflation rate");
        return n.result
    }
    async getEpochInfo(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, void 0, r)
          , s = await this._rpcRequest("getEpochInfo", i)
          , o = se(s, l3);
        if ("error"in o)
            throw new fe(o.error,"failed to get epoch info");
        return o.result
    }
    async getEpochSchedule() {
        const e = await this._rpcRequest("getEpochSchedule", [])
          , n = se(e, c3);
        if ("error"in n)
            throw new fe(n.error,"failed to get epoch schedule");
        const r = n.result;
        return new fS(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const e = await this._rpcRequest("getLeaderSchedule", [])
          , n = se(e, u3);
        if ("error"in n)
            throw new fe(n.error,"failed to get leader schedule");
        return n.result
    }
    async getMinimumBalanceForRentExemption(e, n) {
        const r = this._buildArgs([e], n)
          , i = await this._rpcRequest("getMinimumBalanceForRentExemption", r)
          , s = se(i, O3);
        return "error"in s ? (console.warn("Unable to fetch minimum balance for rent exemption"),
        0) : s.result
    }
    async getRecentBlockhashAndContext(e) {
        const {context: n, value: {blockhash: r}} = await this.getLatestBlockhashAndContext(e);
        return {
            context: n,
            value: {
                blockhash: r,
                feeCalculator: {
                    get lamportsPerSignature() {
                        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")
                    },
                    toJSON() {
                        return {}
                    }
                }
            }
        }
    }
    async getRecentPerformanceSamples(e) {
        const n = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : [])
          , r = se(n, Z3);
        if ("error"in r)
            throw new fe(r.error,"failed to get recent performance samples");
        return r.result
    }
    async getFeeCalculatorForBlockhash(e, n) {
        const r = this._buildArgs([e], n)
          , i = await this._rpcRequest("getFeeCalculatorForBlockhash", r)
          , s = se(i, Q3);
        if ("error"in s)
            throw new fe(s.error,"failed to get fee calculator");
        const {context: o, value: a} = s.result;
        return {
            context: o,
            value: a !== null ? a.feeCalculator : null
        }
    }
    async getFeeForMessage(e, n) {
        const r = Ie(e.serialize()).toString("base64")
          , i = this._buildArgs([r], n)
          , s = await this._rpcRequest("getFeeForMessage", i)
          , o = se(s, It(le(V())));
        if ("error"in o)
            throw new fe(o.error,"failed to get fee for message");
        if (o.result === null)
            throw new Error("invalid blockhash");
        return o.result
    }
    async getRecentPrioritizationFees(e) {
        const n = e?.lockedWritableAccounts?.map(o => o.toBase58())
          , r = n?.length ? [n] : []
          , i = await this._rpcRequest("getRecentPrioritizationFees", r)
          , s = se(i, a3);
        if ("error"in s)
            throw new fe(s.error,"failed to get recent prioritization fees");
        return s.result
    }
    async getRecentBlockhash(e) {
        try {
            return (await this.getRecentBlockhashAndContext(e)).value
        } catch (n) {
            throw new Error("failed to get recent blockhash: " + n)
        }
    }
    async getLatestBlockhash(e) {
        try {
            return (await this.getLatestBlockhashAndContext(e)).value
        } catch (n) {
            throw new Error("failed to get recent blockhash: " + n)
        }
    }
    async getLatestBlockhashAndContext(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, void 0, r)
          , s = await this._rpcRequest("getLatestBlockhash", i)
          , o = se(s, q3);
        if ("error"in o)
            throw new fe(o.error,"failed to get latest blockhash");
        return o.result
    }
    async isBlockhashValid(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgs([e], r, void 0, i)
          , o = await this._rpcRequest("isBlockhashValid", s)
          , a = se(o, G3);
        if ("error"in a)
            throw new fe(a.error,"failed to determine if the blockhash `" + e + "`is valid");
        return a.result
    }
    async getVersion() {
        const e = await this._rpcRequest("getVersion", [])
          , n = se(e, Ae(JT));
        if ("error"in n)
            throw new fe(n.error,"failed to get version");
        return n.result
    }
    async getGenesisHash() {
        const e = await this._rpcRequest("getGenesisHash", [])
          , n = se(e, Ae(re()));
        if ("error"in n)
            throw new fe(n.error,"failed to get genesis hash");
        return n.result
    }
    async getBlock(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgsAtLeastConfirmed([e], r, void 0, i)
          , o = await this._rpcRequest("getBlock", s);
        try {
            switch (i?.transactionDetails) {
            case "accounts":
                {
                    const a = se(o, F3);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            case "none":
                {
                    const a = se(o, W3);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            default:
                {
                    const a = se(o, U3);
                    if ("error"in a)
                        throw a.error;
                    const {result: l} = a;
                    return l ? {
                        ...l,
                        transactions: l.transactions.map( ({transaction: c, meta: d, version: h}) => ({
                            meta: d,
                            transaction: {
                                ...c,
                                message: l0(h, c.message)
                            },
                            version: h
                        }))
                    } : null
                }
            }
        } catch (a) {
            throw new fe(a,"failed to get confirmed block")
        }
    }
    async getParsedBlock(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i)
          , o = await this._rpcRequest("getBlock", s);
        try {
            switch (i?.transactionDetails) {
            case "accounts":
                {
                    const a = se(o, K3);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            case "none":
                {
                    const a = se(o, V3);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            default:
                {
                    const a = se(o, $3);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            }
        } catch (a) {
            throw new fe(a,"failed to get block")
        }
    }
    async getBlockProduction(e) {
        let n, r;
        if (typeof e == "string")
            r = e;
        else if (e) {
            const {commitment: a, ...l} = e;
            r = a,
            n = l
        }
        const i = this._buildArgs([], r, "base64", n)
          , s = await this._rpcRequest("getBlockProduction", i)
          , o = se(s, t3);
        if ("error"in o)
            throw new fe(o.error,"failed to get block production information");
        return o.result
    }
    async getTransaction(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgsAtLeastConfirmed([e], r, void 0, i)
          , o = await this._rpcRequest("getTransaction", s)
          , a = se(o, c0);
        if ("error"in a)
            throw new fe(a.error,"failed to get transaction");
        const l = a.result;
        return l && {
            ...l,
            transaction: {
                ...l.transaction,
                message: l0(l.version, l.transaction.message)
            }
        }
    }
    async getParsedTransaction(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i)
          , o = await this._rpcRequest("getTransaction", s)
          , a = se(o, lu);
        if ("error"in a)
            throw new fe(a.error,"failed to get transaction");
        return a.result
    }
    async getParsedTransactions(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = e.map(l => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([l], r, "jsonParsed", i)
        }));
        return (await this._rpcBatchRequest(s)).map(l => {
            const c = se(l, lu);
            if ("error"in c)
                throw new fe(c.error,"failed to get transactions");
            return c.result
        }
        )
    }
    async getTransactions(e, n) {
        const {commitment: r, config: i} = Je(n)
          , s = e.map(l => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([l], r, void 0, i)
        }));
        return (await this._rpcBatchRequest(s)).map(l => {
            const c = se(l, c0);
            if ("error"in c)
                throw new fe(c.error,"failed to get transactions");
            const d = c.result;
            return d && {
                ...d,
                transaction: {
                    ...d.transaction,
                    message: l0(d.version, d.transaction.message)
                }
            }
        }
        )
    }
    async getConfirmedBlock(e, n) {
        const r = this._buildArgsAtLeastConfirmed([e], n)
          , i = await this._rpcRequest("getBlock", r)
          , s = se(i, H3);
        if ("error"in s)
            throw new fe(s.error,"failed to get confirmed block");
        const o = s.result;
        if (!o)
            throw new Error("Confirmed block " + e + " not found");
        const a = {
            ...o,
            transactions: o.transactions.map( ({transaction: l, meta: c}) => {
                const d = new Dr(l.message);
                return {
                    meta: c,
                    transaction: {
                        ...l,
                        message: d
                    }
                }
            }
            )
        };
        return {
            ...a,
            transactions: a.transactions.map( ({transaction: l, meta: c}) => ({
                meta: c,
                transaction: Be.populate(l.message, l.signatures)
            }))
        }
    }
    async getBlocks(e, n, r) {
        const i = this._buildArgsAtLeastConfirmed(n !== void 0 ? [e, n] : [e], r)
          , s = await this._rpcRequest("getBlocks", i)
          , o = se(s, Ae(ae(V())));
        if ("error"in o)
            throw new fe(o.error,"failed to get blocks");
        return o.result
    }
    async getBlockSignatures(e, n) {
        const r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , i = await this._rpcRequest("getBlock", r)
          , s = se(i, I1);
        if ("error"in s)
            throw new fe(s.error,"failed to get block");
        const o = s.result;
        if (!o)
            throw new Error("Block " + e + " not found");
        return o
    }
    async getConfirmedBlockSignatures(e, n) {
        const r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , i = await this._rpcRequest("getBlock", r)
          , s = se(i, I1);
        if ("error"in s)
            throw new fe(s.error,"failed to get confirmed block");
        const o = s.result;
        if (!o)
            throw new Error("Confirmed block " + e + " not found");
        return o
    }
    async getConfirmedTransaction(e, n) {
        const r = this._buildArgsAtLeastConfirmed([e], n)
          , i = await this._rpcRequest("getTransaction", r)
          , s = se(i, c0);
        if ("error"in s)
            throw new fe(s.error,"failed to get transaction");
        const o = s.result;
        if (!o)
            return o;
        const a = new Dr(o.transaction.message)
          , l = o.transaction.signatures;
        return {
            ...o,
            transaction: Be.populate(a, l)
        }
    }
    async getParsedConfirmedTransaction(e, n) {
        const r = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed")
          , i = await this._rpcRequest("getTransaction", r)
          , s = se(i, lu);
        if ("error"in s)
            throw new fe(s.error,"failed to get confirmed transaction");
        return s.result
    }
    async getParsedConfirmedTransactions(e, n) {
        const r = e.map(o => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([o], n, "jsonParsed")
        }));
        return (await this._rpcBatchRequest(r)).map(o => {
            const a = se(o, lu);
            if ("error"in a)
                throw new fe(a.error,"failed to get confirmed transactions");
            return a.result
        }
        )
    }
    async getConfirmedSignaturesForAddress(e, n, r) {
        let i = {}
          , s = await this.getFirstAvailableBlock();
        for (; !("until"in i) && (n--,
        !(n <= 0 || n < s)); )
            try {
                const l = await this.getConfirmedBlockSignatures(n, "finalized");
                l.signatures.length > 0 && (i.until = l.signatures[l.signatures.length - 1].toString())
            } catch (l) {
                if (l instanceof Error && l.message.includes("skipped"))
                    continue;
                throw l
            }
        let o = await this.getSlot("finalized");
        for (; !("before"in i) && (r++,
        !(r > o)); )
            try {
                const l = await this.getConfirmedBlockSignatures(r);
                l.signatures.length > 0 && (i.before = l.signatures[l.signatures.length - 1].toString())
            } catch (l) {
                if (l instanceof Error && l.message.includes("skipped"))
                    continue;
                throw l
            }
        return (await this.getConfirmedSignaturesForAddress2(e, i)).map(l => l.signature)
    }
    async getConfirmedSignaturesForAddress2(e, n, r) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n)
          , s = await this._rpcRequest("getConfirmedSignaturesForAddress2", i)
          , o = se(s, _3);
        if ("error"in o)
            throw new fe(o.error,"failed to get confirmed signatures for address");
        return o.result
    }
    async getSignaturesForAddress(e, n, r) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n)
          , s = await this._rpcRequest("getSignaturesForAddress", i)
          , o = se(s, x3);
        if ("error"in o)
            throw new fe(o.error,"failed to get signatures for address");
        return o.result
    }
    async getAddressLookupTable(e, n) {
        const {context: r, value: i} = await this.getAccountInfoAndContext(e, n);
        let s = null;
        return i !== null && (s = new Rp({
            key: e,
            state: Rp.deserialize(i.data)
        })),
        {
            context: r,
            value: s
        }
    }
    async getNonceAndContext(e, n) {
        const {context: r, value: i} = await this.getAccountInfoAndContext(e, n);
        let s = null;
        return i !== null && (s = Nh.fromAccountData(i.data)),
        {
            context: r,
            value: s
        }
    }
    async getNonce(e, n) {
        return await this.getNonceAndContext(e, n).then(r => r.value).catch(r => {
            throw new Error("failed to get nonce for account " + e.toBase58() + ": " + r)
        }
        )
    }
    async requestAirdrop(e, n) {
        const r = await this._rpcRequest("requestAirdrop", [e.toBase58(), n])
          , i = se(r, J3);
        if ("error"in i)
            throw new fe(i.error,`airdrop to ${e.toBase58()} failed`);
        return i.result
    }
    async _blockhashWithExpiryBlockHeight(e) {
        if (!e) {
            for (; this._pollingBlockhash; )
                await Ps(100);
            const r = Date.now() - this._blockhashInfo.lastFetch >= gS;
            if (this._blockhashInfo.latestBlockhash !== null && !r)
                return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const e = Date.now()
              , n = this._blockhashInfo.latestBlockhash
              , r = n ? n.blockhash : null;
            for (let i = 0; i < 50; i++) {
                const s = await this.getLatestBlockhash("finalized");
                if (r !== s.blockhash)
                    return this._blockhashInfo = {
                        latestBlockhash: s,
                        lastFetch: Date.now(),
                        transactionSignatures: [],
                        simulatedSignatures: []
                    },
                    s;
                await Ps(uS / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async getStakeMinimumDelegation(e) {
        const {commitment: n, config: r} = Je(e)
          , i = this._buildArgs([], n, "base64", r)
          , s = await this._rpcRequest("getStakeMinimumDelegation", i)
          , o = se(s, It(V()));
        if ("error"in o)
            throw new fe(o.error,"failed to get stake minimum delegation");
        return o.result
    }
    async simulateTransaction(e, n, r) {
        if ("message"in e) {
            const E = e.serialize()
              , A = pe.Buffer.from(E).toString("base64");
            if (Array.isArray(n) || r !== void 0)
                throw new Error("Invalid arguments");
            const _ = n || {};
            _.encoding = "base64",
            "commitment"in _ || (_.commitment = this.commitment),
            n && typeof n == "object" && "innerInstructions"in n && (_.innerInstructions = n.innerInstructions);
            const x = [A, _]
              , b = await this._rpcRequest("simulateTransaction", x)
              , R = se(b, E1);
            if ("error"in R)
                throw new Error("failed to simulate transaction: " + R.error.message);
            return R.result
        }
        let i;
        if (e instanceof Be) {
            let v = e;
            i = new Be,
            i.feePayer = v.feePayer,
            i.instructions = e.instructions,
            i.nonceInfo = v.nonceInfo,
            i.signatures = v.signatures
        } else
            i = Be.populate(e),
            i._message = i._json = void 0;
        if (n !== void 0 && !Array.isArray(n))
            throw new Error("Invalid arguments");
        const s = n;
        if (i.nonceInfo && s)
            i.sign(...s);
        else {
            let v = this._disableBlockhashCaching;
            for (; ; ) {
                const E = await this._blockhashWithExpiryBlockHeight(v);
                if (i.lastValidBlockHeight = E.lastValidBlockHeight,
                i.recentBlockhash = E.blockhash,
                !s)
                    break;
                if (i.sign(...s),
                !i.signature)
                    throw new Error("!signature");
                const A = i.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(A) && !this._blockhashInfo.transactionSignatures.includes(A)) {
                    this._blockhashInfo.simulatedSignatures.push(A);
                    break
                } else
                    v = !0
            }
        }
        const o = i._compile()
          , a = o.serialize()
          , c = i._serialize(a).toString("base64")
          , d = {
            encoding: "base64",
            commitment: this.commitment
        };
        if (r) {
            const v = (Array.isArray(r) ? r : o.nonProgramIds()).map(E => E.toBase58());
            d.accounts = {
                encoding: "base64",
                addresses: v
            }
        }
        s && (d.sigVerify = !0),
        n && typeof n == "object" && "innerInstructions"in n && (d.innerInstructions = n.innerInstructions);
        const h = [c, d]
          , y = await this._rpcRequest("simulateTransaction", h)
          , m = se(y, E1);
        if ("error"in m) {
            let v;
            if ("data"in m.error && (v = m.error.data.logs,
            v && Array.isArray(v))) {
                const E = `
    `
                  , A = E + v.join(E);
                console.error(m.error.message, A)
            }
            throw new ac({
                action: "simulate",
                signature: "",
                transactionMessage: m.error.message,
                logs: v
            })
        }
        return m.result
    }
    async sendTransaction(e, n, r) {
        if ("version"in e) {
            if (n && Array.isArray(n))
                throw new Error("Invalid arguments");
            const o = e.serialize();
            return await this.sendRawTransaction(o, n)
        }
        if (n === void 0 || !Array.isArray(n))
            throw new Error("Invalid arguments");
        const i = n;
        if (e.nonceInfo)
            e.sign(...i);
        else {
            let o = this._disableBlockhashCaching;
            for (; ; ) {
                const a = await this._blockhashWithExpiryBlockHeight(o);
                if (e.lastValidBlockHeight = a.lastValidBlockHeight,
                e.recentBlockhash = a.blockhash,
                e.sign(...i),
                !e.signature)
                    throw new Error("!signature");
                const l = e.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(l))
                    o = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(l);
                    break
                }
            }
        }
        const s = e.serialize();
        return await this.sendRawTransaction(s, r)
    }
    async sendRawTransaction(e, n) {
        const r = Ie(e).toString("base64");
        return await this.sendEncodedTransaction(r, n)
    }
    async sendEncodedTransaction(e, n) {
        const r = {
            encoding: "base64"
        }
          , i = n && n.skipPreflight
          , s = i === !0 ? "processed" : n && n.preflightCommitment || this.commitment;
        n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
        n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
        i && (r.skipPreflight = i),
        s && (r.preflightCommitment = s);
        const o = [e, r]
          , a = await this._rpcRequest("sendTransaction", o)
          , l = se(a, X3);
        if ("error"in l) {
            let c;
            throw "data"in l.error && (c = l.error.data.logs),
            new ac({
                action: i ? "send" : "simulate",
                signature: "",
                transactionMessage: l.error.message,
                logs: c
            })
        }
        return l.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0,
        this._rpcWebSocketHeartbeat = setInterval( () => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {}
            }
            )()
        }
        , 5e3),
        this._updateSubscriptions()
    }
    _wsOnError(e) {
        this._rpcWebSocketConnected = !1,
        console.error("ws error:", e.message)
    }
    _wsOnClose(e) {
        if (this._rpcWebSocketConnected = !1,
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER,
        this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null),
        this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat),
        this._rpcWebSocketHeartbeat = null),
        e === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {},
        Object.entries(this._subscriptionsByHash).forEach( ([n,r]) => {
            this._setSubscription(n, {
                ...r,
                state: "pending"
            })
        }
        )
    }
    _setSubscription(e, n) {
        const r = this._subscriptionsByHash[e]?.state;
        if (this._subscriptionsByHash[e] = n,
        r !== n.state) {
            const i = this._subscriptionStateChangeCallbacksByHash[e];
            i && i.forEach(s => {
                try {
                    s(n.state)
                } catch {}
            }
            )
        }
    }
    _onSubscriptionStateChange(e, n) {
        const r = this._subscriptionHashByClientSubscriptionId[e];
        if (r == null)
            return () => {}
            ;
        const i = this._subscriptionStateChangeCallbacksByHash[r] ||= new Set;
        return i.add(n),
        () => {
            i.delete(n),
            i.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[r]
        }
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1,
            this._rpcWebSocketIdleTimeout = setTimeout( () => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch (r) {
                    r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`)
                }
            }
            , 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketConnected = !0),
        !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const e = this._rpcWebSocketGeneration
          , n = () => e === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async r => {
            const i = this._subscriptionsByHash[r];
            if (i !== void 0)
                switch (i.state) {
                case "pending":
                case "unsubscribed":
                    if (i.callbacks.size === 0) {
                        delete this._subscriptionsByHash[r],
                        i.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId],
                        await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {args: s, method: o} = i;
                        try {
                            this._setSubscription(r, {
                                ...i,
                                state: "subscribing"
                            });
                            const a = await this._rpcWebSocket.call(o, s);
                            this._setSubscription(r, {
                                ...i,
                                serverSubscriptionId: a,
                                state: "subscribed"
                            }),
                            this._subscriptionCallbacksByServerSubscriptionId[a] = i.callbacks,
                            await this._updateSubscriptions()
                        } catch (a) {
                            if (console.error(`Received ${ainstanceof Error ? "" : "JSON-RPC "}error calling \`${o}\``, {
                                args: s,
                                error: a
                            }),
                            !n())
                                return;
                            this._setSubscription(r, {
                                ...i,
                                state: "pending"
                            }),
                            await this._updateSubscriptions()
                        }
                    }
                    )();
                    break;
                case "subscribed":
                    i.callbacks.size === 0 && await (async () => {
                        const {serverSubscriptionId: s, unsubscribeMethod: o} = i;
                        if (this._subscriptionsAutoDisposedByRpc.has(s))
                            this._subscriptionsAutoDisposedByRpc.delete(s);
                        else {
                            this._setSubscription(r, {
                                ...i,
                                state: "unsubscribing"
                            }),
                            this._setSubscription(r, {
                                ...i,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(o, [s])
                            } catch (a) {
                                if (a instanceof Error && console.error(`${o} error:`, a.message),
                                !n())
                                    return;
                                this._setSubscription(r, {
                                    ...i,
                                    state: "subscribed"
                                }),
                                await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription(r, {
                            ...i,
                            state: "unsubscribed"
                        }),
                        await this._updateSubscriptions()
                    }
                    )();
                    break
                }
        }
        ))
    }
    _handleServerNotification(e, n) {
        const r = this._subscriptionCallbacksByServerSubscriptionId[e];
        r !== void 0 && r.forEach(i => {
            try {
                i(...n)
            } catch (s) {
                console.error(s)
            }
        }
        )
    }
    _wsOnAccountNotification(e) {
        const {result: n, subscription: r} = se(e, S3);
        this._handleServerNotification(r, [n.value, n.context])
    }
    _makeSubscription(e, n) {
        const r = this._nextClientSubscriptionId++
          , i = x1([e.method, n])
          , s = this._subscriptionsByHash[i];
        return s === void 0 ? this._subscriptionsByHash[i] = {
            ...e,
            args: n,
            callbacks: new Set([e.callback]),
            state: "pending"
        } : s.callbacks.add(e.callback),
        this._subscriptionHashByClientSubscriptionId[r] = i,
        this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
            delete this._subscriptionHashByClientSubscriptionId[r];
            const o = this._subscriptionsByHash[i];
            ze(o !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${r}`),
            o.callbacks.delete(e.callback),
            await this._updateSubscriptions()
        }
        ,
        this._updateSubscriptions(),
        r
    }
    onAccountChange(e, n, r) {
        const {commitment: i, config: s} = Je(r)
          , o = this._buildArgs([e.toBase58()], i || this._commitment || "finalized", "base64", s);
        return this._makeSubscription({
            callback: n,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, o)
    }
    async removeAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "account change")
    }
    _wsOnProgramAccountNotification(e) {
        const {result: n, subscription: r} = se(e, E3);
        this._handleServerNotification(r, [{
            accountId: n.value.pubkey,
            accountInfo: n.value.account
        }, n.context])
    }
    onProgramAccountChange(e, n, r, i) {
        const {commitment: s, config: o} = Je(r)
          , a = this._buildArgs([e.toBase58()], s || this._commitment || "finalized", "base64", o || (i ? {
            filters: k1(i)
        } : void 0));
        return this._makeSubscription({
            callback: n,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, a)
    }
    async removeProgramAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "program account change")
    }
    onLogs(e, n, r) {
        const i = this._buildArgs([typeof e == "object" ? {
            mentions: [e.toString()]
        } : e], r || this._commitment || "finalized");
        return this._makeSubscription({
            callback: n,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, i)
    }
    async removeOnLogsListener(e) {
        await this._unsubscribeClientSubscription(e, "logs")
    }
    _wsOnLogsNotification(e) {
        const {result: n, subscription: r} = se(e, tN);
        this._handleServerNotification(r, [n.value, n.context])
    }
    _wsOnSlotNotification(e) {
        const {result: n, subscription: r} = se(e, I3);
        this._handleServerNotification(r, [n])
    }
    onSlotChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "slot change")
    }
    _wsOnSlotUpdatesNotification(e) {
        const {result: n, subscription: r} = se(e, T3);
        this._handleServerNotification(r, [n])
    }
    onSlotUpdate(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener(e) {
        await this._unsubscribeClientSubscription(e, "slot update")
    }
    async _unsubscribeClientSubscription(e, n) {
        const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
        r ? await r() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${n}' events could not be found.`)
    }
    _buildArgs(e, n, r, i) {
        const s = n || this._commitment;
        if (s || r || i) {
            let o = {};
            r && (o.encoding = r),
            s && (o.commitment = s),
            i && (o = Object.assign(o, i)),
            e.push(o)
        }
        return e
    }
    _buildArgsAtLeastConfirmed(e, n, r, i) {
        const s = n || this._commitment;
        if (s && !["confirmed", "finalized"].includes(s))
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(e, n, r, i)
    }
    _wsOnSignatureNotification(e) {
        const {result: n, subscription: r} = se(e, N3);
        n.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(r),
        this._handleServerNotification(r, n.value === "receivedSignature" ? [{
            type: "received"
        }, n.context] : [{
            type: "status",
            result: n.value
        }, n.context])
    }
    onSignature(e, n, r) {
        const i = this._buildArgs([e], r || this._commitment || "finalized")
          , s = this._makeSubscription({
            callback: (o, a) => {
                if (o.type === "status") {
                    n(o.result, a);
                    try {
                        this.removeSignatureListener(s)
                    } catch {}
                }
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, i);
        return s
    }
    onSignatureWithOptions(e, n, r) {
        const {commitment: i, ...s} = {
            ...r,
            commitment: r && r.commitment || this._commitment || "finalized"
        }
          , o = this._buildArgs([e], i, void 0, s)
          , a = this._makeSubscription({
            callback: (l, c) => {
                n(l, c);
                try {
                    this.removeSignatureListener(a)
                } catch {}
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, o);
        return a
    }
    async removeSignatureListener(e) {
        await this._unsubscribeClientSubscription(e, "signature result")
    }
    _wsOnRootNotification(e) {
        const {result: n, subscription: r} = se(e, C3);
        this._handleServerNotification(r, [n])
    }
    onRootChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "root change")
    }
}
class fa {
    constructor(e) {
        this._keypair = void 0,
        this._keypair = e ?? w1()
    }
    static generate() {
        return new fa(w1())
    }
    static fromSecretKey(e, n) {
        if (e.byteLength !== 64)
            throw new Error("bad secret key size");
        const r = e.slice(32, 64);
        if (!n || !n.skipValidation) {
            const i = e.slice(0, 32)
              , s = Ud(i);
            for (let o = 0; o < 32; o++)
                if (r[o] !== s[o])
                    throw new Error("provided secretKey is invalid")
        }
        return new fa({
            publicKey: r,
            secretKey: e
        })
    }
    static fromSeed(e) {
        const n = Ud(e)
          , r = new Uint8Array(64);
        return r.set(e),
        r.set(n, 32),
        new fa({
            publicKey: n,
            secretKey: r
        })
    }
    get publicKey() {
        return new ne(this._keypair.publicKey)
    }
    get secretKey() {
        return new Uint8Array(this._keypair.secretKey)
    }
}
const vi = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: de([ue("instruction"), Ma("recentSlot"), Pe("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: de([ue("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: de([ue("instruction"), Ma(), mn(Ce(), ds(ue(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: de([ue("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: de([ue("instruction")])
    }
});
class rN {
    constructor() {}
    static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        const r = ue("instruction").decode(e.data);
        let i;
        for (const [s,o] of Object.entries(vi))
            if (o.index == r) {
                i = s;
                break
            }
        if (!i)
            throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        return i
    }
    static decodeCreateLookupTable(e) {
        this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 4);
        const {recentSlot: n} = We(vi.CreateLookupTable, e.data);
        return {
            authority: e.keys[1].pubkey,
            payer: e.keys[2].pubkey,
            recentSlot: Number(n)
        }
    }
    static decodeExtendLookupTable(e) {
        if (this.checkProgramId(e.programId),
        e.keys.length < 2)
            throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
        const {addresses: n} = We(vi.ExtendLookupTable, e.data);
        return {
            lookupTable: e.keys[0].pubkey,
            authority: e.keys[1].pubkey,
            payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
            addresses: n.map(r => new ne(r))
        }
    }
    static decodeCloseLookupTable(e) {
        return this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 3),
        {
            lookupTable: e.keys[0].pubkey,
            authority: e.keys[1].pubkey,
            recipient: e.keys[2].pubkey
        }
    }
    static decodeFreezeLookupTable(e) {
        return this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 2),
        {
            lookupTable: e.keys[0].pubkey,
            authority: e.keys[1].pubkey
        }
    }
    static decodeDeactivateLookupTable(e) {
        return this.checkProgramId(e.programId),
        this.checkKeysLength(e.keys, 2),
        {
            lookupTable: e.keys[0].pubkey,
            authority: e.keys[1].pubkey
        }
    }
    static checkProgramId(e) {
        if (!e.equals(fy.programId))
            throw new Error("invalid instruction; programId is not AddressLookupTable Program")
    }
    static checkKeysLength(e, n) {
        if (e.length < n)
            throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${n}`)
    }
}
class fy {
    constructor() {}
    static createLookupTable(e) {
        const [n,r] = ne.findProgramAddressSync([e.authority.toBuffer(), Ux().encode(e.recentSlot)], this.programId)
          , i = vi.CreateLookupTable
          , s = je(i, {
            recentSlot: BigInt(e.recentSlot),
            bumpSeed: r
        })
          , o = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: e.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: ln.programId,
            isSigner: !1,
            isWritable: !1
        }];
        return [new Ge({
            programId: this.programId,
            keys: o,
            data: s
        }), n]
    }
    static freezeLookupTable(e) {
        const n = vi.FreezeLookupTable
          , r = je(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new Ge({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static extendLookupTable(e) {
        const n = vi.ExtendLookupTable
          , r = je(n, {
            addresses: e.addresses.map(s => s.toBytes())
        })
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return e.payer && i.push({
            pubkey: e.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: ln.programId,
            isSigner: !1,
            isWritable: !1
        }),
        new Ge({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static deactivateLookupTable(e) {
        const n = vi.DeactivateLookupTable
          , r = je(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new Ge({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static closeLookupTable(e) {
        const n = vi.CloseLookupTable
          , r = je(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: e.recipient,
            isSigner: !1,
            isWritable: !0
        }];
        return new Ge({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
}
fy.programId = new ne("AddressLookupTab1e1111111111111111111111111");
class iN {
    constructor() {}
    static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        const r = Pe("instruction").decode(e.data);
        let i;
        for (const [s,o] of Object.entries(Gr))
            if (o.index == r) {
                i = s;
                break
            }
        if (!i)
            throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        return i
    }
    static decodeRequestUnits(e) {
        this.checkProgramId(e.programId);
        const {units: n, additionalFee: r} = We(Gr.RequestUnits, e.data);
        return {
            units: n,
            additionalFee: r
        }
    }
    static decodeRequestHeapFrame(e) {
        this.checkProgramId(e.programId);
        const {bytes: n} = We(Gr.RequestHeapFrame, e.data);
        return {
            bytes: n
        }
    }
    static decodeSetComputeUnitLimit(e) {
        this.checkProgramId(e.programId);
        const {units: n} = We(Gr.SetComputeUnitLimit, e.data);
        return {
            units: n
        }
    }
    static decodeSetComputeUnitPrice(e) {
        this.checkProgramId(e.programId);
        const {microLamports: n} = We(Gr.SetComputeUnitPrice, e.data);
        return {
            microLamports: n
        }
    }
    static checkProgramId(e) {
        if (!e.equals(py.programId))
            throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
    }
}
const Gr = Object.freeze({
    RequestUnits: {
        index: 0,
        layout: de([Pe("instruction"), ue("units"), ue("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: de([Pe("instruction"), ue("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: de([Pe("instruction"), ue("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: de([Pe("instruction"), Ma("microLamports")])
    }
});
class py {
    constructor() {}
    static requestUnits(e) {
        const n = Gr.RequestUnits
          , r = je(n, e);
        return new Ge({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static requestHeapFrame(e) {
        const n = Gr.RequestHeapFrame
          , r = je(n, e);
        return new Ge({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static setComputeUnitLimit(e) {
        const n = Gr.SetComputeUnitLimit
          , r = je(n, e);
        return new Ge({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static setComputeUnitPrice(e) {
        const n = Gr.SetComputeUnitPrice
          , r = je(n, {
            microLamports: BigInt(e.microLamports)
        });
        return new Ge({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
}
py.programId = new ne("ComputeBudget111111111111111111111111111111");
const M1 = 64
  , T1 = 32
  , N1 = 64
  , C1 = de([Pe("numSignatures"), Pe("padding"), gr("signatureOffset"), gr("signatureInstructionIndex"), gr("publicKeyOffset"), gr("publicKeyInstructionIndex"), gr("messageDataOffset"), gr("messageDataSize"), gr("messageInstructionIndex")]);
class Lh {
    constructor() {}
    static createInstructionWithPublicKey(e) {
        const {publicKey: n, message: r, signature: i, instructionIndex: s} = e;
        ze(n.length === T1, `Public Key must be ${T1} bytes but received ${n.length} bytes`),
        ze(i.length === N1, `Signature must be ${N1} bytes but received ${i.length} bytes`);
        const o = C1.span
          , a = o + n.length
          , l = a + i.length
          , c = 1
          , d = pe.Buffer.alloc(l + r.length)
          , h = s ?? 65535;
        return C1.encode({
            numSignatures: c,
            padding: 0,
            signatureOffset: a,
            signatureInstructionIndex: h,
            publicKeyOffset: o,
            publicKeyInstructionIndex: h,
            messageDataOffset: l,
            messageDataSize: r.length,
            messageInstructionIndex: h
        }, d),
        d.fill(n, o),
        d.fill(i, a),
        d.fill(r, l),
        new Ge({
            keys: [],
            programId: Lh.programId,
            data: d
        })
    }
    static createInstructionWithPrivateKey(e) {
        const {privateKey: n, message: r, instructionIndex: i} = e;
        ze(n.length === M1, `Private key must be ${M1} bytes but received ${n.length} bytes`);
        try {
            const s = fa.fromSecretKey(n)
              , o = s.publicKey.toBytes()
              , a = iy(r, s.secretKey);
            return this.createInstructionWithPublicKey({
                publicKey: o,
                message: r,
                signature: a,
                instructionIndex: i
            })
        } catch (s) {
            throw new Error(`Error creating instruction; ${s}`)
        }
    }
}
Lh.programId = new ne("Ed25519SigVerify111111111111111111111111111");
const sN = (t, e) => {
    const n = ry.sign(t, e);
    return [n.toCompactRawBytes(), n.recovery]
}
;
ry.utils.isValidPrivateKey;
const oN = ry.getPublicKey
  , R1 = 32
  , u0 = 20
  , L1 = 64
  , aN = 11
  , d0 = de([Pe("numSignatures"), gr("signatureOffset"), Pe("signatureInstructionIndex"), gr("ethAddressOffset"), Pe("ethAddressInstructionIndex"), gr("messageDataOffset"), gr("messageDataSize"), Pe("messageInstructionIndex"), st(20, "ethAddress"), st(64, "signature"), Pe("recoveryId")]);
class pa {
    constructor() {}
    static publicKeyToEthAddress(e) {
        ze(e.length === L1, `Public key must be ${L1} bytes but received ${e.length} bytes`);
        try {
            return pe.Buffer.from(g1(Ie(e))).slice(-u0)
        } catch (n) {
            throw new Error(`Error constructing Ethereum address: ${n}`)
        }
    }
    static createInstructionWithPublicKey(e) {
        const {publicKey: n, message: r, signature: i, recoveryId: s, instructionIndex: o} = e;
        return pa.createInstructionWithEthAddress({
            ethAddress: pa.publicKeyToEthAddress(n),
            message: r,
            signature: i,
            recoveryId: s,
            instructionIndex: o
        })
    }
    static createInstructionWithEthAddress(e) {
        const {ethAddress: n, message: r, signature: i, recoveryId: s, instructionIndex: o=0} = e;
        let a;
        typeof n == "string" ? n.startsWith("0x") ? a = pe.Buffer.from(n.substr(2), "hex") : a = pe.Buffer.from(n, "hex") : a = n,
        ze(a.length === u0, `Address must be ${u0} bytes but received ${a.length} bytes`);
        const l = 1 + aN
          , c = l
          , d = l + a.length
          , h = d + i.length + 1
          , y = 1
          , m = pe.Buffer.alloc(d0.span + r.length);
        return d0.encode({
            numSignatures: y,
            signatureOffset: d,
            signatureInstructionIndex: o,
            ethAddressOffset: c,
            ethAddressInstructionIndex: o,
            messageDataOffset: h,
            messageDataSize: r.length,
            messageInstructionIndex: o,
            signature: Ie(i),
            ethAddress: Ie(a),
            recoveryId: s
        }, m),
        m.fill(Ie(r), d0.span),
        new Ge({
            keys: [],
            programId: pa.programId,
            data: m
        })
    }
    static createInstructionWithPrivateKey(e) {
        const {privateKey: n, message: r, instructionIndex: i} = e;
        ze(n.length === R1, `Private key must be ${R1} bytes but received ${n.length} bytes`);
        try {
            const s = Ie(n)
              , o = oN(s, !1).slice(1)
              , a = pe.Buffer.from(g1(Ie(r)))
              , [l,c] = sN(a, s);
            return this.createInstructionWithPublicKey({
                publicKey: o,
                message: r,
                signature: l,
                recoveryId: c,
                instructionIndex: i
            })
        } catch (s) {
            throw new Error(`Error creating instruction; ${s}`)
        }
    }
}
pa.programId = new ne("KeccakSecp256k11111111111111111111111111111");
var AS;
const IS = new ne("StakeConfig11111111111111111111111111111111");
class MS {
    constructor(e, n) {
        this.staker = void 0,
        this.withdrawer = void 0,
        this.staker = e,
        this.withdrawer = n
    }
}
class kc {
    constructor(e, n, r) {
        this.unixTimestamp = void 0,
        this.epoch = void 0,
        this.custodian = void 0,
        this.unixTimestamp = e,
        this.epoch = n,
        this.custodian = r
    }
}
AS = kc;
kc.default = new AS(0,0,ne.default);
class lN {
    constructor() {}
    static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        const r = ue("instruction").decode(e.data);
        let i;
        for (const [s,o] of Object.entries(on))
            if (o.index == r) {
                i = s;
                break
            }
        if (!i)
            throw new Error("Instruction type incorrect; not a StakeInstruction");
        return i
    }
    static decodeInitialize(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {authorized: n, lockup: r} = We(on.Initialize, e.data);
        return {
            stakePubkey: e.keys[0].pubkey,
            authorized: new MS(new ne(n.staker),new ne(n.withdrawer)),
            lockup: new kc(r.unixTimestamp,r.epoch,new ne(r.custodian))
        }
    }
    static decodeDelegate(e) {
        return this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 6),
        We(on.Delegate, e.data),
        {
            stakePubkey: e.keys[0].pubkey,
            votePubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[5].pubkey
        }
    }
    static decodeAuthorize(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {newAuthorized: n, stakeAuthorizationType: r} = We(on.Authorize, e.data)
          , i = {
            stakePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey,
            newAuthorizedPubkey: new ne(n),
            stakeAuthorizationType: {
                index: r
            }
        };
        return e.keys.length > 3 && (i.custodianPubkey = e.keys[3].pubkey),
        i
    }
    static decodeAuthorizeWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 2);
        const {newAuthorized: n, stakeAuthorizationType: r, authoritySeed: i, authorityOwner: s} = We(on.AuthorizeWithSeed, e.data)
          , o = {
            stakePubkey: e.keys[0].pubkey,
            authorityBase: e.keys[1].pubkey,
            authoritySeed: i,
            authorityOwner: new ne(s),
            newAuthorizedPubkey: new ne(n),
            stakeAuthorizationType: {
                index: r
            }
        };
        return e.keys.length > 3 && (o.custodianPubkey = e.keys[3].pubkey),
        o
    }
    static decodeSplit(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {lamports: n} = We(on.Split, e.data);
        return {
            stakePubkey: e.keys[0].pubkey,
            splitStakePubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[2].pubkey,
            lamports: n
        }
    }
    static decodeMerge(e) {
        return this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3),
        We(on.Merge, e.data),
        {
            stakePubkey: e.keys[0].pubkey,
            sourceStakePubKey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey
        }
    }
    static decodeWithdraw(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 5);
        const {lamports: n} = We(on.Withdraw, e.data)
          , r = {
            stakePubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey,
            lamports: n
        };
        return e.keys.length > 5 && (r.custodianPubkey = e.keys[5].pubkey),
        r
    }
    static decodeDeactivate(e) {
        return this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3),
        We(on.Deactivate, e.data),
        {
            stakePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey
        }
    }
    static checkProgramId(e) {
        if (!e.equals(jh.programId))
            throw new Error("invalid instruction; programId is not StakeProgram")
    }
    static checkKeyLength(e, n) {
        if (e.length < n)
            throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${n}`)
    }
}
const on = Object.freeze({
    Initialize: {
        index: 0,
        layout: de([ue("instruction"), fT(), pT()])
    },
    Authorize: {
        index: 1,
        layout: de([ue("instruction"), Ce("newAuthorized"), ue("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: de([ue("instruction")])
    },
    Split: {
        index: 3,
        layout: de([ue("instruction"), tr("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: de([ue("instruction"), tr("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: de([ue("instruction")])
    },
    Merge: {
        index: 7,
        layout: de([ue("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: de([ue("instruction"), Ce("newAuthorized"), ue("stakeAuthorizationType"), Vs("authoritySeed"), Ce("authorityOwner")])
    }
})
  , cN = Object.freeze({
    Staker: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
class jh {
    constructor() {}
    static initialize(e) {
        const {stakePubkey: n, authorized: r, lockup: i} = e
          , s = i || kc.default
          , o = on.Initialize
          , a = je(o, {
            authorized: {
                staker: Ie(r.staker.toBuffer()),
                withdrawer: Ie(r.withdrawer.toBuffer())
            },
            lockup: {
                unixTimestamp: s.unixTimestamp,
                epoch: s.epoch,
                custodian: Ie(s.custodian.toBuffer())
            }
        })
          , l = {
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Ia,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: a
        };
        return new Ge(l)
    }
    static createAccountWithSeed(e) {
        const n = new Be;
        n.add(ln.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.stakePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {stakePubkey: r, authorized: i, lockup: s} = e;
        return n.add(this.initialize({
            stakePubkey: r,
            authorized: i,
            lockup: s
        }))
    }
    static createAccount(e) {
        const n = new Be;
        n.add(ln.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.stakePubkey,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {stakePubkey: r, authorized: i, lockup: s} = e;
        return n.add(this.initialize({
            stakePubkey: r,
            authorized: i,
            lockup: s
        }))
    }
    static delegate(e) {
        const {stakePubkey: n, authorizedPubkey: r, votePubkey: i} = e
          , s = on.Delegate
          , o = je(s);
        return new Be().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $r,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Mu,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: IS,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: o
        })
    }
    static authorize(e) {
        const {stakePubkey: n, authorizedPubkey: r, newAuthorizedPubkey: i, stakeAuthorizationType: s, custodianPubkey: o} = e
          , a = on.Authorize
          , l = je(a, {
            newAuthorized: Ie(i.toBuffer()),
            stakeAuthorizationType: s.index
        })
          , c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $r,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return o && c.push({
            pubkey: o,
            isSigner: !0,
            isWritable: !1
        }),
        new Be().add({
            keys: c,
            programId: this.programId,
            data: l
        })
    }
    static authorizeWithSeed(e) {
        const {stakePubkey: n, authorityBase: r, authoritySeed: i, authorityOwner: s, newAuthorizedPubkey: o, stakeAuthorizationType: a, custodianPubkey: l} = e
          , c = on.AuthorizeWithSeed
          , d = je(c, {
            newAuthorized: Ie(o.toBuffer()),
            stakeAuthorizationType: a.index,
            authoritySeed: i,
            authorityOwner: Ie(s.toBuffer())
        })
          , h = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: $r,
            isSigner: !1,
            isWritable: !1
        }];
        return l && h.push({
            pubkey: l,
            isSigner: !0,
            isWritable: !1
        }),
        new Be().add({
            keys: h,
            programId: this.programId,
            data: d
        })
    }
    static splitInstruction(e) {
        const {stakePubkey: n, authorizedPubkey: r, splitStakePubkey: i, lamports: s} = e
          , o = on.Split
          , a = je(o, {
            lamports: s
        });
        return new Ge({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: a
        })
    }
    static split(e, n) {
        const r = new Be;
        return r.add(ln.createAccount({
            fromPubkey: e.authorizedPubkey,
            newAccountPubkey: e.splitStakePubkey,
            lamports: n,
            space: this.space,
            programId: this.programId
        })),
        r.add(this.splitInstruction(e))
    }
    static splitWithSeed(e, n) {
        const {stakePubkey: r, authorizedPubkey: i, splitStakePubkey: s, basePubkey: o, seed: a, lamports: l} = e
          , c = new Be;
        return c.add(ln.allocate({
            accountPubkey: s,
            basePubkey: o,
            seed: a,
            space: this.space,
            programId: this.programId
        })),
        n && n > 0 && c.add(ln.transfer({
            fromPubkey: e.authorizedPubkey,
            toPubkey: s,
            lamports: n
        })),
        c.add(this.splitInstruction({
            stakePubkey: r,
            authorizedPubkey: i,
            splitStakePubkey: s,
            lamports: l
        }))
    }
    static merge(e) {
        const {stakePubkey: n, sourceStakePubKey: r, authorizedPubkey: i} = e
          , s = on.Merge
          , o = je(s);
        return new Be().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $r,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Mu,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: i,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: o
        })
    }
    static withdraw(e) {
        const {stakePubkey: n, authorizedPubkey: r, toPubkey: i, lamports: s, custodianPubkey: o} = e
          , a = on.Withdraw
          , l = je(a, {
            lamports: s
        })
          , c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: Mu,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return o && c.push({
            pubkey: o,
            isSigner: !0,
            isWritable: !1
        }),
        new Be().add({
            keys: c,
            programId: this.programId,
            data: l
        })
    }
    static deactivate(e) {
        const {stakePubkey: n, authorizedPubkey: r} = e
          , i = on.Deactivate
          , s = je(i);
        return new Be().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $r,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: s
        })
    }
}
jh.programId = new ne("Stake11111111111111111111111111111111111111");
jh.space = 200;
class TS {
    constructor(e, n, r, i) {
        this.nodePubkey = void 0,
        this.authorizedVoter = void 0,
        this.authorizedWithdrawer = void 0,
        this.commission = void 0,
        this.nodePubkey = e,
        this.authorizedVoter = n,
        this.authorizedWithdrawer = r,
        this.commission = i
    }
}
class uN {
    constructor() {}
    static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        const r = ue("instruction").decode(e.data);
        let i;
        for (const [s,o] of Object.entries(Yr))
            if (o.index == r) {
                i = s;
                break
            }
        if (!i)
            throw new Error("Instruction type incorrect; not a VoteInstruction");
        return i
    }
    static decodeInitializeAccount(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 4);
        const {voteInit: n} = We(Yr.InitializeAccount, e.data);
        return {
            votePubkey: e.keys[0].pubkey,
            nodePubkey: e.keys[3].pubkey,
            voteInit: new TS(new ne(n.nodePubkey),new ne(n.authorizedVoter),new ne(n.authorizedWithdrawer),n.commission)
        }
    }
    static decodeAuthorize(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {newAuthorized: n, voteAuthorizationType: r} = We(Yr.Authorize, e.data);
        return {
            votePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey,
            newAuthorizedPubkey: new ne(n),
            voteAuthorizationType: {
                index: r
            }
        }
    }
    static decodeAuthorizeWithSeed(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {voteAuthorizeWithSeedArgs: {currentAuthorityDerivedKeyOwnerPubkey: n, currentAuthorityDerivedKeySeed: r, newAuthorized: i, voteAuthorizationType: s}} = We(Yr.AuthorizeWithSeed, e.data);
        return {
            currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new ne(n),
            currentAuthorityDerivedKeySeed: r,
            newAuthorizedPubkey: new ne(i),
            voteAuthorizationType: {
                index: s
            },
            votePubkey: e.keys[0].pubkey
        }
    }
    static decodeWithdraw(e) {
        this.checkProgramId(e.programId),
        this.checkKeyLength(e.keys, 3);
        const {lamports: n} = We(Yr.Withdraw, e.data);
        return {
            votePubkey: e.keys[0].pubkey,
            authorizedWithdrawerPubkey: e.keys[2].pubkey,
            lamports: n,
            toPubkey: e.keys[1].pubkey
        }
    }
    static checkProgramId(e) {
        if (!e.equals(Ka.programId))
            throw new Error("invalid instruction; programId is not VoteProgram")
    }
    static checkKeyLength(e, n) {
        if (e.length < n)
            throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${n}`)
    }
}
const Yr = Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: de([ue("instruction"), gT()])
    },
    Authorize: {
        index: 1,
        layout: de([ue("instruction"), Ce("newAuthorized"), ue("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: de([ue("instruction"), tr("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: de([ue("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: de([ue("instruction"), mT()])
    }
})
  , dN = Object.freeze({
    Voter: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
class Ka {
    constructor() {}
    static initializeAccount(e) {
        const {votePubkey: n, nodePubkey: r, voteInit: i} = e
          , s = Yr.InitializeAccount
          , o = je(s, {
            voteInit: {
                nodePubkey: Ie(i.nodePubkey.toBuffer()),
                authorizedVoter: Ie(i.authorizedVoter.toBuffer()),
                authorizedWithdrawer: Ie(i.authorizedWithdrawer.toBuffer()),
                commission: i.commission
            }
        })
          , a = {
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Ia,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $r,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: o
        };
        return new Ge(a)
    }
    static createAccount(e) {
        const n = new Be;
        return n.add(ln.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.votePubkey,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        })),
        n.add(this.initializeAccount({
            votePubkey: e.votePubkey,
            nodePubkey: e.voteInit.nodePubkey,
            voteInit: e.voteInit
        }))
    }
    static authorize(e) {
        const {votePubkey: n, authorizedPubkey: r, newAuthorizedPubkey: i, voteAuthorizationType: s} = e
          , o = Yr.Authorize
          , a = je(o, {
            newAuthorized: Ie(i.toBuffer()),
            voteAuthorizationType: s.index
        })
          , l = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Be().add({
            keys: l,
            programId: this.programId,
            data: a
        })
    }
    static authorizeWithSeed(e) {
        const {currentAuthorityDerivedKeyBasePubkey: n, currentAuthorityDerivedKeyOwnerPubkey: r, currentAuthorityDerivedKeySeed: i, newAuthorizedPubkey: s, voteAuthorizationType: o, votePubkey: a} = e
          , l = Yr.AuthorizeWithSeed
          , c = je(l, {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: Ie(r.toBuffer()),
                currentAuthorityDerivedKeySeed: i,
                newAuthorized: Ie(s.toBuffer()),
                voteAuthorizationType: o.index
            }
        })
          , d = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: n,
            isSigner: !0,
            isWritable: !1
        }];
        return new Be().add({
            keys: d,
            programId: this.programId,
            data: c
        })
    }
    static withdraw(e) {
        const {votePubkey: n, authorizedWithdrawerPubkey: r, lamports: i, toPubkey: s} = e
          , o = Yr.Withdraw
          , a = je(o, {
            lamports: i
        })
          , l = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: s,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Be().add({
            keys: l,
            programId: this.programId,
            data: a
        })
    }
    static safeWithdraw(e, n, r) {
        if (e.lamports > n - r)
            throw new Error("Withdraw will leave vote account with insufficient funds.");
        return Ka.withdraw(e)
    }
    static updateValidatorIdentity(e) {
        const {votePubkey: n, authorizedWithdrawerPubkey: r, nodePubkey: i} = e
          , s = Yr.UpdateValidatorIdentity
          , o = je(s)
          , a = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Be().add({
            keys: a,
            programId: this.programId,
            data: o
        })
    }
}
Ka.programId = new ne("Vote111111111111111111111111111111111111111");
Ka.space = 3762;
const NS = new ne("Va1idator1nfo111111111111111111111111111111")
  , hN = Q({
    name: re(),
    website: ge(re()),
    details: ge(re()),
    iconUrl: ge(re()),
    keybaseUsername: ge(re())
});
class gy {
    constructor(e, n) {
        this.key = void 0,
        this.info = void 0,
        this.key = e,
        this.info = n
    }
    static fromConfigData(e) {
        let n = [...e];
        if (Wn(n) !== 2)
            return null;
        const i = [];
        for (let s = 0; s < 2; s++) {
            const o = new ne(Fn(n, 0, ti))
              , a = qr(n) === 1;
            i.push({
                publicKey: o,
                isSigner: a
            })
        }
        if (i[0].publicKey.equals(NS) && i[1].isSigner) {
            const s = Vs().decode(pe.Buffer.from(n))
              , o = JSON.parse(s);
            return Wx(o, hN),
            new gy(i[1].publicKey,o)
        }
        return null
    }
}
const fN = new ne("Vote111111111111111111111111111111111111111")
  , pN = de([Ce("nodePubkey"), Ce("authorizedWithdrawer"), Pe("commission"), dn(), mn(de([dn("slot"), ue("confirmationCount")]), ds(ue(), -8), "votes"), Pe("rootSlotValid"), dn("rootSlot"), dn(), mn(de([dn("epoch"), Ce("authorizedVoter")]), ds(ue(), -8), "authorizedVoters"), de([mn(de([Ce("authorizedPubkey"), dn("epochOfLastAuthorizedSwitch"), dn("targetEpoch")]), 32, "buf"), dn("idx"), Pe("isEmpty")], "priorVoters"), dn(), mn(de([dn("epoch"), dn("credits"), dn("prevCredits")]), ds(ue(), -8), "epochCredits"), de([dn("slot"), dn("timestamp")], "lastTimestamp")]);
class my {
    constructor(e) {
        this.nodePubkey = void 0,
        this.authorizedWithdrawer = void 0,
        this.commission = void 0,
        this.rootSlot = void 0,
        this.votes = void 0,
        this.authorizedVoters = void 0,
        this.priorVoters = void 0,
        this.epochCredits = void 0,
        this.lastTimestamp = void 0,
        this.nodePubkey = e.nodePubkey,
        this.authorizedWithdrawer = e.authorizedWithdrawer,
        this.commission = e.commission,
        this.rootSlot = e.rootSlot,
        this.votes = e.votes,
        this.authorizedVoters = e.authorizedVoters,
        this.priorVoters = e.priorVoters,
        this.epochCredits = e.epochCredits,
        this.lastTimestamp = e.lastTimestamp
    }
    static fromAccountData(e) {
        const r = pN.decode(Ie(e), 4);
        let i = r.rootSlot;
        return r.rootSlotValid || (i = null),
        new my({
            nodePubkey: new ne(r.nodePubkey),
            authorizedWithdrawer: new ne(r.authorizedWithdrawer),
            commission: r.commission,
            votes: r.votes,
            rootSlot: i,
            authorizedVoters: r.authorizedVoters.map(gN),
            priorVoters: mN(r.priorVoters),
            epochCredits: r.epochCredits,
            lastTimestamp: r.lastTimestamp
        })
    }
}
function gN({authorizedVoter: t, epoch: e}) {
    return {
        epoch: e,
        authorizedVoter: new ne(t)
    }
}
function j1({authorizedPubkey: t, epochOfLastAuthorizedSwitch: e, targetEpoch: n}) {
    return {
        authorizedPubkey: new ne(t),
        epochOfLastAuthorizedSwitch: e,
        targetEpoch: n
    }
}
function mN({buf: t, idx: e, isEmpty: n}) {
    return n ? [] : [...t.slice(e + 1).map(j1), ...t.slice(0, e).map(j1)]
}
const B1 = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};
function yN(t, e) {
    const n = e === !1 ? "http" : "https";
    if (!t)
        return B1[n].devnet;
    const r = B1[n][t];
    if (!r)
        throw new Error(`Unknown ${n} cluster: ${t}`);
    return r
}
async function wN(t, e, n, r) {
    let i, s;
    n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight") || n && Object.prototype.hasOwnProperty.call(n, "nonceValue") ? (i = n,
    s = r) : s = n;
    const o = s && {
        skipPreflight: s.skipPreflight,
        preflightCommitment: s.preflightCommitment || s.commitment,
        minContextSlot: s.minContextSlot
    }
      , a = await t.sendRawTransaction(e, o)
      , l = s && s.commitment
      , d = (await (i ? t.confirmTransaction(i, l) : t.confirmTransaction(a, l))).value;
    if (d.err)
        throw a != null ? new ac({
            action: o?.skipPreflight ? "send" : "simulate",
            signature: a,
            transactionMessage: `Status: (${JSON.stringify(d)})`
        }) : new Error(`Raw transaction ${a} failed (${JSON.stringify(d)})`);
    return a
}
const vN = 1e9
  , bN = Object.freeze(Object.defineProperty({
    __proto__: null,
    Account: uT,
    AddressLookupTableAccount: Rp,
    AddressLookupTableInstruction: rN,
    AddressLookupTableProgram: fy,
    Authorized: MS,
    BLOCKHASH_CACHE_TIMEOUT_MS: gS,
    BPF_LOADER_DEPRECATED_PROGRAM_ID: dT,
    BPF_LOADER_PROGRAM_ID: TT,
    BpfLoader: NT,
    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: Gr,
    ComputeBudgetInstruction: iN,
    ComputeBudgetProgram: py,
    Connection: ES,
    Ed25519Program: Lh,
    Enum: lT,
    EpochSchedule: fS,
    FeeCalculatorLayout: dS,
    Keypair: fa,
    LAMPORTS_PER_SOL: vN,
    LOOKUP_TABLE_INSTRUCTION_LAYOUTS: vi,
    Loader: lo,
    Lockup: kc,
    MAX_SEED_LENGTH: aS,
    Message: Dr,
    MessageAccountKeys: sc,
    MessageV0: ao,
    NONCE_ACCOUNT_LENGTH: Cp,
    NonceAccount: Nh,
    PACKET_DATA_SIZE: hs,
    PUBLIC_KEY_LENGTH: ti,
    PublicKey: ne,
    SIGNATURE_LENGTH_IN_BYTES: ic,
    SOLANA_SCHEMA: Nl,
    STAKE_CONFIG_ID: IS,
    STAKE_INSTRUCTION_LAYOUTS: on,
    SYSTEM_INSTRUCTION_LAYOUTS: et,
    SYSVAR_CLOCK_PUBKEY: $r,
    SYSVAR_EPOCH_SCHEDULE_PUBKEY: _T,
    SYSVAR_INSTRUCTIONS_PUBKEY: xT,
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY: Iu,
    SYSVAR_RENT_PUBKEY: Ia,
    SYSVAR_REWARDS_PUBKEY: ST,
    SYSVAR_SLOT_HASHES_PUBKEY: kT,
    SYSVAR_SLOT_HISTORY_PUBKEY: ET,
    SYSVAR_STAKE_HISTORY_PUBKEY: Mu,
    Secp256k1Program: pa,
    SendTransactionError: ac,
    SolanaJSONRPCError: fe,
    SolanaJSONRPCErrorCode: AT,
    StakeAuthorizationLayout: cN,
    StakeInstruction: lN,
    StakeProgram: jh,
    Struct: sy,
    SystemInstruction: IT,
    SystemProgram: ln,
    Transaction: Be,
    TransactionExpiredBlockheightExceededError: oy,
    TransactionExpiredNonceInvalidError: ra,
    TransactionExpiredTimeoutError: ay,
    TransactionInstruction: Ge,
    TransactionMessage: cy,
    TransactionStatus: ui,
    VALIDATOR_INFO_KEY: NS,
    VERSION_PREFIX_MASK: Mh,
    VOTE_PROGRAM_ID: fN,
    ValidatorInfo: gy,
    VersionedMessage: ly,
    VersionedTransaction: oc,
    VoteAccount: my,
    VoteAuthorizationLayout: dN,
    VoteInit: TS,
    VoteInstruction: uN,
    VoteProgram: Ka,
    clusterApiUrl: yN,
    sendAndConfirmRawTransaction: wN,
    sendAndConfirmTransaction: Np
}, Symbol.toStringTag, {
    value: "Module"
}))
  , CS = Y.createContext({});
function _N() {
    return Y.useContext(CS)
}
const xN = ({children: t, endpoint: e, config: n={
    commitment: "confirmed"
}}) => {
    const r = Y.useMemo( () => new ES(e,n), [e, n]);
    return J.createElement(CS.Provider, {
        value: {
            connection: r
        }
    }, t)
}
;
var RS = {
    exports: {}
};
(function(t) {
    var e = Object.prototype.hasOwnProperty
      , n = "~";
    function r() {}
    Object.create && (r.prototype = Object.create(null),
    new r().__proto__ || (n = !1));
    function i(l, c, d) {
        this.fn = l,
        this.context = c,
        this.once = d || !1
    }
    function s(l, c, d, h, y) {
        if (typeof d != "function")
            throw new TypeError("The listener must be a function");
        var m = new i(d,h || l,y)
          , v = n ? n + c : c;
        return l._events[v] ? l._events[v].fn ? l._events[v] = [l._events[v], m] : l._events[v].push(m) : (l._events[v] = m,
        l._eventsCount++),
        l
    }
    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new r : delete l._events[c]
    }
    function a() {
        this._events = new r,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], d, h;
        if (this._eventsCount === 0)
            return c;
        for (h in d = this._events)
            e.call(d, h) && c.push(n ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(d)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var d = n ? n + c : c
          , h = this._events[d];
        if (!h)
            return [];
        if (h.fn)
            return [h.fn];
        for (var y = 0, m = h.length, v = new Array(m); y < m; y++)
            v[y] = h[y].fn;
        return v
    }
    ,
    a.prototype.listenerCount = function(c) {
        var d = n ? n + c : c
          , h = this._events[d];
        return h ? h.fn ? 1 : h.length : 0
    }
    ,
    a.prototype.emit = function(c, d, h, y, m, v) {
        var E = n ? n + c : c;
        if (!this._events[E])
            return !1;
        var A = this._events[E], _ = arguments.length, x, b;
        if (A.fn) {
            switch (A.once && this.removeListener(c, A.fn, void 0, !0),
            _) {
            case 1:
                return A.fn.call(A.context),
                !0;
            case 2:
                return A.fn.call(A.context, d),
                !0;
            case 3:
                return A.fn.call(A.context, d, h),
                !0;
            case 4:
                return A.fn.call(A.context, d, h, y),
                !0;
            case 5:
                return A.fn.call(A.context, d, h, y, m),
                !0;
            case 6:
                return A.fn.call(A.context, d, h, y, m, v),
                !0
            }
            for (b = 1,
            x = new Array(_ - 1); b < _; b++)
                x[b - 1] = arguments[b];
            A.fn.apply(A.context, x)
        } else {
            var R = A.length, O;
            for (b = 0; b < R; b++)
                switch (A[b].once && this.removeListener(c, A[b].fn, void 0, !0),
                _) {
                case 1:
                    A[b].fn.call(A[b].context);
                    break;
                case 2:
                    A[b].fn.call(A[b].context, d);
                    break;
                case 3:
                    A[b].fn.call(A[b].context, d, h);
                    break;
                case 4:
                    A[b].fn.call(A[b].context, d, h, y);
                    break;
                default:
                    if (!x)
                        for (O = 1,
                        x = new Array(_ - 1); O < _; O++)
                            x[O - 1] = arguments[O];
                    A[b].fn.apply(A[b].context, x)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, d, h) {
        return s(this, c, d, h, !1)
    }
    ,
    a.prototype.once = function(c, d, h) {
        return s(this, c, d, h, !0)
    }
    ,
    a.prototype.removeListener = function(c, d, h, y) {
        var m = n ? n + c : c;
        if (!this._events[m])
            return this;
        if (!d)
            return o(this, m),
            this;
        var v = this._events[m];
        if (v.fn)
            v.fn === d && (!y || v.once) && (!h || v.context === h) && o(this, m);
        else {
            for (var E = 0, A = [], _ = v.length; E < _; E++)
                (v[E].fn !== d || y && !v[E].once || h && v[E].context !== h) && A.push(v[E]);
            A.length ? this._events[m] = A.length === 1 ? A[0] : A : o(this, m)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var d;
        return c ? (d = n ? n + c : c,
        this._events[d] && o(this, d)) : (this._events = new r,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = n,
    a.EventEmitter = a,
    t.exports = a
}
)(RS);
var SN = RS.exports;
const LS = ho(SN);
class wt extends Error {
    constructor(e, n) {
        super(e),
        this.error = n
    }
}
class co extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletNotReadyError"
    }
}
class jS extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletLoadError"
    }
}
class Hs extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletConfigError"
    }
}
class Ta extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletConnectionError"
    }
}
class Ec extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectedError"
    }
}
class Ac extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectionError"
    }
}
class ki extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletAccountError"
    }
}
class uo extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletPublicKeyError"
    }
}
class kN extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletKeypairError"
    }
}
class at extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletNotConnectedError"
    }
}
class Qr extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletSendTransactionError"
    }
}
class ir extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletSignTransactionError"
    }
}
class Ic extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletSignMessageError"
    }
}
class Pp extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletSignInError"
    }
}
class EN extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletTimeoutError"
    }
}
class AN extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletWindowBlockedError"
    }
}
class IN extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletWindowClosedError"
    }
}
var Re;
(function(t) {
    t.Installed = "Installed",
    t.NotDetected = "NotDetected",
    t.Loadable = "Loadable",
    t.Unsupported = "Unsupported"
}
)(Re || (Re = {}));
class yy extends LS {
    get connected() {
        return !!this.publicKey
    }
    async autoConnect() {
        await this.connect()
    }
    async prepareTransaction(e, n, r={}) {
        const i = this.publicKey;
        if (!i)
            throw new at;
        return e.feePayer = e.feePayer || i,
        e.recentBlockhash = e.recentBlockhash || (await n.getLatestBlockhash({
            commitment: r.preflightCommitment,
            minContextSlot: r.minContextSlot
        })).blockhash,
        e
    }
}
function Bh(t) {
    if (typeof window > "u" || typeof document > "u")
        return;
    const e = [];
    function n() {
        if (t())
            for (const s of e)
                s()
    }
    const r = setInterval(n, 1e3);
    e.push( () => clearInterval(r)),
    document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", n, {
        once: !0
    }),
    e.push( () => document.removeEventListener("DOMContentLoaded", n))),
    document.readyState !== "complete" && (window.addEventListener("load", n, {
        once: !0
    }),
    e.push( () => window.removeEventListener("load", n))),
    n()
}
function Fd() {
    if (!navigator)
        return !1;
    const t = navigator.userAgent.toLowerCase()
      , e = t.includes("iphone") || t.includes("ipad")
      , n = t.includes("safari");
    return e && n
}
function Jr(t) {
    return "version"in t
}
class BS extends yy {
    async sendTransaction(e, n, r={}) {
        let i = !0;
        try {
            if (Jr(e)) {
                if (!this.supportedTransactionVersions)
                    throw new Qr("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(e.version))
                    throw new Qr(`Sending transaction version ${e.version} isn't supported by this wallet`);
                try {
                    e = await this.signTransaction(e);
                    const s = e.serialize();
                    return await n.sendRawTransaction(s, r)
                } catch (s) {
                    throw s instanceof ir ? (i = !1,
                    s) : new Qr(s?.message,s)
                }
            } else
                try {
                    const {signers: s, ...o} = r;
                    e = await this.prepareTransaction(e, n, o),
                    s?.length && e.partialSign(...s),
                    e = await this.signTransaction(e);
                    const a = e.serialize();
                    return await n.sendRawTransaction(a, o)
                } catch (s) {
                    throw s instanceof ir ? (i = !1,
                    s) : new Qr(s?.message,s)
                }
        } catch (s) {
            throw i && this.emit("error", s),
            s
        }
    }
    async signAllTransactions(e) {
        for (const r of e)
            if (Jr(r)) {
                if (!this.supportedTransactionVersions)
                    throw new ir("Signing versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(r.version))
                    throw new ir(`Signing transaction version ${r.version} isn't supported by this wallet`)
            }
        const n = [];
        for (const r of e)
            n.push(await this.signTransaction(r));
        return n
    }
}
class Mc extends BS {
}
class MN extends Mc {
}
var Me = {}
  , Ph = {};
Object.defineProperty(Ph, "__esModule", {
    value: !0
});
Ph.SolanaSignAndSendTransaction = void 0;
Ph.SolanaSignAndSendTransaction = "solana:signAndSendTransaction";
var Oh = {};
Object.defineProperty(Oh, "__esModule", {
    value: !0
});
Oh.SolanaSignIn = void 0;
Oh.SolanaSignIn = "solana:signIn";
var Dh = {};
Object.defineProperty(Dh, "__esModule", {
    value: !0
});
Dh.SolanaSignMessage = void 0;
Dh.SolanaSignMessage = "solana:signMessage";
var zh = {};
Object.defineProperty(zh, "__esModule", {
    value: !0
});
zh.SolanaSignTransaction = void 0;
zh.SolanaSignTransaction = "solana:signTransaction";
var Uh = {};
Object.defineProperty(Uh, "__esModule", {
    value: !0
});
Uh.SignAndSendAllTransactions = void 0;
Uh.SignAndSendAllTransactions = "solana:signAndSendAllTransactions";
(function(t) {
    var e = Ye && Ye.__createBinding || (Object.create ? function(r, i, s, o) {
        o === void 0 && (o = s);
        var a = Object.getOwnPropertyDescriptor(i, s);
        (!a || ("get"in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[s]
            }
        }),
        Object.defineProperty(r, o, a)
    }
    : function(r, i, s, o) {
        o === void 0 && (o = s),
        r[o] = i[s]
    }
    )
      , n = Ye && Ye.__exportStar || function(r, i) {
        for (var s in r)
            s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s)
    }
    ;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    n(Ph, t),
    n(Oh, t),
    n(Dh, t),
    n(zh, t),
    n(Uh, t)
}
)(Me);
const Tc = "standard:connect"
  , TN = Tc
  , cc = "standard:disconnect"
  , NN = cc
  , Nc = "standard:events"
  , CN = Nc
  , RN = Object.freeze(Object.defineProperty({
    __proto__: null,
    Connect: TN,
    Disconnect: NN,
    Events: CN,
    StandardConnect: Tc,
    StandardDisconnect: cc,
    StandardEvents: Nc
}, Symbol.toStringTag, {
    value: "Module"
}));
function PS(t) {
    return Tc in t.features && Nc in t.features && (Me.SolanaSignAndSendTransaction in t.features || Me.SolanaSignTransaction in t.features)
}
var Op;
(function(t) {
    t.Mainnet = "mainnet-beta",
    t.Testnet = "testnet",
    t.Devnet = "devnet"
}
)(Op || (Op = {}));
const LN = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseMessageSignerWalletAdapter: Mc,
    BaseSignInMessageSignerWalletAdapter: MN,
    BaseSignerWalletAdapter: BS,
    BaseWalletAdapter: yy,
    EventEmitter: LS,
    WalletAccountError: ki,
    get WalletAdapterNetwork() {
        return Op
    },
    WalletConfigError: Hs,
    WalletConnectionError: Ta,
    WalletDisconnectedError: Ec,
    WalletDisconnectionError: Ac,
    WalletError: wt,
    WalletKeypairError: kN,
    WalletLoadError: jS,
    WalletNotConnectedError: at,
    WalletNotReadyError: co,
    WalletPublicKeyError: uo,
    get WalletReadyState() {
        return Re
    },
    WalletSendTransactionError: Qr,
    WalletSignInError: Pp,
    WalletSignMessageError: Ic,
    WalletSignTransactionError: ir,
    WalletTimeoutError: EN,
    WalletWindowBlockedError: AN,
    WalletWindowClosedError: IN,
    isIosAndRedirectable: Fd,
    isVersionedTransaction: Jr,
    isWalletAdapterCompatibleStandardWallet: PS,
    scopePollingDetectionStrategy: Bh
}, Symbol.toStringTag, {
    value: "Module"
}));
class P1 extends wt {
    constructor() {
        super(...arguments),
        this.name = "WalletNotSelectedError"
    }
}
const jN = []
  , Wh = {
    autoConnect: !1,
    connecting: !1,
    connected: !1,
    disconnecting: !1,
    select() {
        Mr("call", "select")
    },
    connect() {
        return Promise.reject(Mr("call", "connect"))
    },
    disconnect() {
        return Promise.reject(Mr("call", "disconnect"))
    },
    sendTransaction() {
        return Promise.reject(Mr("call", "sendTransaction"))
    },
    signTransaction() {
        return Promise.reject(Mr("call", "signTransaction"))
    },
    signAllTransactions() {
        return Promise.reject(Mr("call", "signAllTransactions"))
    },
    signMessage() {
        return Promise.reject(Mr("call", "signMessage"))
    },
    signIn() {
        return Promise.reject(Mr("call", "signIn"))
    }
};
Object.defineProperty(Wh, "wallets", {
    get() {
        return Mr("read", "wallets"),
        jN
    }
});
Object.defineProperty(Wh, "wallet", {
    get() {
        return Mr("read", "wallet"),
        null
    }
});
Object.defineProperty(Wh, "publicKey", {
    get() {
        return Mr("read", "publicKey"),
        null
    }
});
function Mr(t, e) {
    const n = new Error(`You have tried to ${t} "${e}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`);
    return console.error(n),
    n
}
const OS = Y.createContext(Wh);
function DS() {
    return Y.useContext(OS)
}
function BN(t, e) {
    const n = Y.useState( () => {
        try {
            const s = localStorage.getItem(t);
            if (s)
                return JSON.parse(s)
        } catch (s) {
            typeof window < "u" && console.error(s)
        }
        return e
    }
    )
      , r = n[0]
      , i = Y.useRef(!0);
    return Y.useEffect( () => {
        if (i.current) {
            i.current = !1;
            return
        }
        try {
            r === null ? localStorage.removeItem(t) : localStorage.setItem(t, JSON.stringify(r))
        } catch (s) {
            typeof window < "u" && console.error(s)
        }
    }
    , [r, t]),
    n
}
var bs = {};
const PN = ms(LN)
  , ON = ms(bN);
var oi = {}
  , Cc = {}
  , DN = function() {
    return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
}
  , zS = {}
  , hr = {};
let wy;
const zN = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
hr.getSymbolSize = function(e) {
    if (!e)
        throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40)
        throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17
}
;
hr.getSymbolTotalCodewords = function(e) {
    return zN[e]
}
;
hr.getBCHDigit = function(t) {
    let e = 0;
    for (; t !== 0; )
        e++,
        t >>>= 1;
    return e
}
;
hr.setToSJISFunction = function(e) {
    if (typeof e != "function")
        throw new Error('"toSJISFunc" is not a valid function.');
    wy = e
}
;
hr.isKanjiModeEnabled = function() {
    return typeof wy < "u"
}
;
hr.toSJIS = function(e) {
    return wy(e)
}
;
var Fh = {};
(function(t) {
    t.L = {
        bit: 1
    },
    t.M = {
        bit: 0
    },
    t.Q = {
        bit: 3
    },
    t.H = {
        bit: 2
    };
    function e(n) {
        if (typeof n != "string")
            throw new Error("Param is not a string");
        switch (n.toLowerCase()) {
        case "l":
        case "low":
            return t.L;
        case "m":
        case "medium":
            return t.M;
        case "q":
        case "quartile":
            return t.Q;
        case "h":
        case "high":
            return t.H;
        default:
            throw new Error("Unknown EC Level: " + n)
        }
    }
    t.isValid = function(r) {
        return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4
    }
    ,
    t.from = function(r, i) {
        if (t.isValid(r))
            return r;
        try {
            return e(r)
        } catch {
            return i
        }
    }
}
)(Fh);
function US() {
    this.buffer = [],
    this.length = 0
}
US.prototype = {
    get: function(t) {
        const e = Math.floor(t / 8);
        return (this.buffer[e] >>> 7 - t % 8 & 1) === 1
    },
    put: function(t, e) {
        for (let n = 0; n < e; n++)
            this.putBit((t >>> e - n - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        const e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0),
        t && (this.buffer[e] |= 128 >>> this.length % 8),
        this.length++
    }
};
var UN = US;
function Rc(t) {
    if (!t || t < 1)
        throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = t,
    this.data = new Uint8Array(t * t),
    this.reservedBit = new Uint8Array(t * t)
}
Rc.prototype.set = function(t, e, n, r) {
    const i = t * this.size + e;
    this.data[i] = n,
    r && (this.reservedBit[i] = !0)
}
;
Rc.prototype.get = function(t, e) {
    return this.data[t * this.size + e]
}
;
Rc.prototype.xor = function(t, e, n) {
    this.data[t * this.size + e] ^= n
}
;
Rc.prototype.isReserved = function(t, e) {
    return this.reservedBit[t * this.size + e]
}
;
var WN = Rc
  , WS = {};
(function(t) {
    const e = hr.getSymbolSize;
    t.getRowColCoords = function(r) {
        if (r === 1)
            return [];
        const i = Math.floor(r / 7) + 2
          , s = e(r)
          , o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2
          , a = [s - 7];
        for (let l = 1; l < i - 1; l++)
            a[l] = a[l - 1] - o;
        return a.push(6),
        a.reverse()
    }
    ,
    t.getPositions = function(r) {
        const i = []
          , s = t.getRowColCoords(r)
          , o = s.length;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++)
                a === 0 && l === 0 || a === 0 && l === o - 1 || a === o - 1 && l === 0 || i.push([s[a], s[l]]);
        return i
    }
}
)(WS);
var FS = {};
const FN = hr.getSymbolSize
  , O1 = 7;
FS.getPositions = function(e) {
    const n = FN(e);
    return [[0, 0], [n - O1, 0], [0, n - O1]]
}
;
var $S = {};
(function(t) {
    t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const e = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    t.isValid = function(i) {
        return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7
    }
    ,
    t.from = function(i) {
        return t.isValid(i) ? parseInt(i, 10) : void 0
    }
    ,
    t.getPenaltyN1 = function(i) {
        const s = i.size;
        let o = 0
          , a = 0
          , l = 0
          , c = null
          , d = null;
        for (let h = 0; h < s; h++) {
            a = l = 0,
            c = d = null;
            for (let y = 0; y < s; y++) {
                let m = i.get(h, y);
                m === c ? a++ : (a >= 5 && (o += e.N1 + (a - 5)),
                c = m,
                a = 1),
                m = i.get(y, h),
                m === d ? l++ : (l >= 5 && (o += e.N1 + (l - 5)),
                d = m,
                l = 1)
            }
            a >= 5 && (o += e.N1 + (a - 5)),
            l >= 5 && (o += e.N1 + (l - 5))
        }
        return o
    }
    ,
    t.getPenaltyN2 = function(i) {
        const s = i.size;
        let o = 0;
        for (let a = 0; a < s - 1; a++)
            for (let l = 0; l < s - 1; l++) {
                const c = i.get(a, l) + i.get(a, l + 1) + i.get(a + 1, l) + i.get(a + 1, l + 1);
                (c === 4 || c === 0) && o++
            }
        return o * e.N2
    }
    ,
    t.getPenaltyN3 = function(i) {
        const s = i.size;
        let o = 0
          , a = 0
          , l = 0;
        for (let c = 0; c < s; c++) {
            a = l = 0;
            for (let d = 0; d < s; d++)
                a = a << 1 & 2047 | i.get(c, d),
                d >= 10 && (a === 1488 || a === 93) && o++,
                l = l << 1 & 2047 | i.get(d, c),
                d >= 10 && (l === 1488 || l === 93) && o++
        }
        return o * e.N3
    }
    ,
    t.getPenaltyN4 = function(i) {
        let s = 0;
        const o = i.data.length;
        for (let l = 0; l < o; l++)
            s += i.data[l];
        return Math.abs(Math.ceil(s * 100 / o / 5) - 10) * e.N4
    }
    ;
    function n(r, i, s) {
        switch (r) {
        case t.Patterns.PATTERN000:
            return (i + s) % 2 === 0;
        case t.Patterns.PATTERN001:
            return i % 2 === 0;
        case t.Patterns.PATTERN010:
            return s % 3 === 0;
        case t.Patterns.PATTERN011:
            return (i + s) % 3 === 0;
        case t.Patterns.PATTERN100:
            return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
        case t.Patterns.PATTERN101:
            return i * s % 2 + i * s % 3 === 0;
        case t.Patterns.PATTERN110:
            return (i * s % 2 + i * s % 3) % 2 === 0;
        case t.Patterns.PATTERN111:
            return (i * s % 3 + (i + s) % 2) % 2 === 0;
        default:
            throw new Error("bad maskPattern:" + r)
        }
    }
    t.applyMask = function(i, s) {
        const o = s.size;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++)
                s.isReserved(l, a) || s.xor(l, a, n(i, l, a))
    }
    ,
    t.getBestMask = function(i, s) {
        const o = Object.keys(t.Patterns).length;
        let a = 0
          , l = 1 / 0;
        for (let c = 0; c < o; c++) {
            s(c),
            t.applyMask(c, i);
            const d = t.getPenaltyN1(i) + t.getPenaltyN2(i) + t.getPenaltyN3(i) + t.getPenaltyN4(i);
            t.applyMask(c, i),
            d < l && (l = d,
            a = c)
        }
        return a
    }
}
)($S);
var $h = {};
const ts = Fh
  , cu = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
  , uu = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
$h.getBlocksCount = function(e, n) {
    switch (n) {
    case ts.L:
        return cu[(e - 1) * 4 + 0];
    case ts.M:
        return cu[(e - 1) * 4 + 1];
    case ts.Q:
        return cu[(e - 1) * 4 + 2];
    case ts.H:
        return cu[(e - 1) * 4 + 3];
    default:
        return
    }
}
;
$h.getTotalCodewordsCount = function(e, n) {
    switch (n) {
    case ts.L:
        return uu[(e - 1) * 4 + 0];
    case ts.M:
        return uu[(e - 1) * 4 + 1];
    case ts.Q:
        return uu[(e - 1) * 4 + 2];
    case ts.H:
        return uu[(e - 1) * 4 + 3];
    default:
        return
    }
}
;
var KS = {}
  , Kh = {};
const Cl = new Uint8Array(512)
  , $d = new Uint8Array(256);
(function() {
    let e = 1;
    for (let n = 0; n < 255; n++)
        Cl[n] = e,
        $d[e] = n,
        e <<= 1,
        e & 256 && (e ^= 285);
    for (let n = 255; n < 512; n++)
        Cl[n] = Cl[n - 255]
}
)();
Kh.log = function(e) {
    if (e < 1)
        throw new Error("log(" + e + ")");
    return $d[e]
}
;
Kh.exp = function(e) {
    return Cl[e]
}
;
Kh.mul = function(e, n) {
    return e === 0 || n === 0 ? 0 : Cl[$d[e] + $d[n]]
}
;
(function(t) {
    const e = Kh;
    t.mul = function(r, i) {
        const s = new Uint8Array(r.length + i.length - 1);
        for (let o = 0; o < r.length; o++)
            for (let a = 0; a < i.length; a++)
                s[o + a] ^= e.mul(r[o], i[a]);
        return s
    }
    ,
    t.mod = function(r, i) {
        let s = new Uint8Array(r);
        for (; s.length - i.length >= 0; ) {
            const o = s[0];
            for (let l = 0; l < i.length; l++)
                s[l] ^= e.mul(i[l], o);
            let a = 0;
            for (; a < s.length && s[a] === 0; )
                a++;
            s = s.slice(a)
        }
        return s
    }
    ,
    t.generateECPolynomial = function(r) {
        let i = new Uint8Array([1]);
        for (let s = 0; s < r; s++)
            i = t.mul(i, new Uint8Array([1, e.exp(s)]));
        return i
    }
}
)(KS);
const VS = KS;
function vy(t) {
    this.genPoly = void 0,
    this.degree = t,
    this.degree && this.initialize(this.degree)
}
vy.prototype.initialize = function(e) {
    this.degree = e,
    this.genPoly = VS.generateECPolynomial(this.degree)
}
;
vy.prototype.encode = function(e) {
    if (!this.genPoly)
        throw new Error("Encoder not initialized");
    const n = new Uint8Array(e.length + this.degree);
    n.set(e);
    const r = VS.mod(n, this.genPoly)
      , i = this.degree - r.length;
    if (i > 0) {
        const s = new Uint8Array(this.degree);
        return s.set(r, i),
        s
    }
    return r
}
;
var $N = vy
  , HS = {}
  , _s = {}
  , by = {};
by.isValid = function(e) {
    return !isNaN(e) && e >= 1 && e <= 40
}
;
var ai = {};
const qS = "[0-9]+"
  , KN = "[A-Z $%*+\\-./:]+";
let uc = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
uc = uc.replace(/u/g, "\\u");
const VN = "(?:(?![A-Z0-9 $%*+\\-./:]|" + uc + `)(?:.|[\r
]))+`;
ai.KANJI = new RegExp(uc,"g");
ai.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g");
ai.BYTE = new RegExp(VN,"g");
ai.NUMERIC = new RegExp(qS,"g");
ai.ALPHANUMERIC = new RegExp(KN,"g");
const HN = new RegExp("^" + uc + "$")
  , qN = new RegExp("^" + qS + "$")
  , GN = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
ai.testKanji = function(e) {
    return HN.test(e)
}
;
ai.testNumeric = function(e) {
    return qN.test(e)
}
;
ai.testAlphanumeric = function(e) {
    return GN.test(e)
}
;
(function(t) {
    const e = by
      , n = ai;
    t.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    },
    t.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    },
    t.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    },
    t.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    },
    t.MIXED = {
        bit: -1
    },
    t.getCharCountIndicator = function(s, o) {
        if (!s.ccBits)
            throw new Error("Invalid mode: " + s);
        if (!e.isValid(o))
            throw new Error("Invalid version: " + o);
        return o >= 1 && o < 10 ? s.ccBits[0] : o < 27 ? s.ccBits[1] : s.ccBits[2]
    }
    ,
    t.getBestModeForData = function(s) {
        return n.testNumeric(s) ? t.NUMERIC : n.testAlphanumeric(s) ? t.ALPHANUMERIC : n.testKanji(s) ? t.KANJI : t.BYTE
    }
    ,
    t.toString = function(s) {
        if (s && s.id)
            return s.id;
        throw new Error("Invalid mode")
    }
    ,
    t.isValid = function(s) {
        return s && s.bit && s.ccBits
    }
    ;
    function r(i) {
        if (typeof i != "string")
            throw new Error("Param is not a string");
        switch (i.toLowerCase()) {
        case "numeric":
            return t.NUMERIC;
        case "alphanumeric":
            return t.ALPHANUMERIC;
        case "kanji":
            return t.KANJI;
        case "byte":
            return t.BYTE;
        default:
            throw new Error("Unknown mode: " + i)
        }
    }
    t.from = function(s, o) {
        if (t.isValid(s))
            return s;
        try {
            return r(s)
        } catch {
            return o
        }
    }
}
)(_s);
(function(t) {
    const e = hr
      , n = $h
      , r = Fh
      , i = _s
      , s = by
      , o = 7973
      , a = e.getBCHDigit(o);
    function l(y, m, v) {
        for (let E = 1; E <= 40; E++)
            if (m <= t.getCapacity(E, v, y))
                return E
    }
    function c(y, m) {
        return i.getCharCountIndicator(y, m) + 4
    }
    function d(y, m) {
        let v = 0;
        return y.forEach(function(E) {
            const A = c(E.mode, m);
            v += A + E.getBitsLength()
        }),
        v
    }
    function h(y, m) {
        for (let v = 1; v <= 40; v++)
            if (d(y, v) <= t.getCapacity(v, m, i.MIXED))
                return v
    }
    t.from = function(m, v) {
        return s.isValid(m) ? parseInt(m, 10) : v
    }
    ,
    t.getCapacity = function(m, v, E) {
        if (!s.isValid(m))
            throw new Error("Invalid QR Code version");
        typeof E > "u" && (E = i.BYTE);
        const A = e.getSymbolTotalCodewords(m)
          , _ = n.getTotalCodewordsCount(m, v)
          , x = (A - _) * 8;
        if (E === i.MIXED)
            return x;
        const b = x - c(E, m);
        switch (E) {
        case i.NUMERIC:
            return Math.floor(b / 10 * 3);
        case i.ALPHANUMERIC:
            return Math.floor(b / 11 * 2);
        case i.KANJI:
            return Math.floor(b / 13);
        case i.BYTE:
        default:
            return Math.floor(b / 8)
        }
    }
    ,
    t.getBestVersionForData = function(m, v) {
        let E;
        const A = r.from(v, r.M);
        if (Array.isArray(m)) {
            if (m.length > 1)
                return h(m, A);
            if (m.length === 0)
                return 1;
            E = m[0]
        } else
            E = m;
        return l(E.mode, E.getLength(), A)
    }
    ,
    t.getEncodedBits = function(m) {
        if (!s.isValid(m) || m < 7)
            throw new Error("Invalid QR Code version");
        let v = m << 12;
        for (; e.getBCHDigit(v) - a >= 0; )
            v ^= o << e.getBCHDigit(v) - a;
        return m << 12 | v
    }
}
)(HS);
var GS = {};
const Dp = hr
  , YS = 1335
  , YN = 21522
  , D1 = Dp.getBCHDigit(YS);
GS.getEncodedBits = function(e, n) {
    const r = e.bit << 3 | n;
    let i = r << 10;
    for (; Dp.getBCHDigit(i) - D1 >= 0; )
        i ^= YS << Dp.getBCHDigit(i) - D1;
    return (r << 10 | i) ^ YN
}
;
var ZS = {};
const ZN = _s;
function Na(t) {
    this.mode = ZN.NUMERIC,
    this.data = t.toString()
}
Na.getBitsLength = function(e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
}
;
Na.prototype.getLength = function() {
    return this.data.length
}
;
Na.prototype.getBitsLength = function() {
    return Na.getBitsLength(this.data.length)
}
;
Na.prototype.write = function(e) {
    let n, r, i;
    for (n = 0; n + 3 <= this.data.length; n += 3)
        r = this.data.substr(n, 3),
        i = parseInt(r, 10),
        e.put(i, 10);
    const s = this.data.length - n;
    s > 0 && (r = this.data.substr(n),
    i = parseInt(r, 10),
    e.put(i, s * 3 + 1))
}
;
var QN = Na;
const JN = _s
  , h0 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function Ca(t) {
    this.mode = JN.ALPHANUMERIC,
    this.data = t
}
Ca.getBitsLength = function(e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2)
}
;
Ca.prototype.getLength = function() {
    return this.data.length
}
;
Ca.prototype.getBitsLength = function() {
    return Ca.getBitsLength(this.data.length)
}
;
Ca.prototype.write = function(e) {
    let n;
    for (n = 0; n + 2 <= this.data.length; n += 2) {
        let r = h0.indexOf(this.data[n]) * 45;
        r += h0.indexOf(this.data[n + 1]),
        e.put(r, 11)
    }
    this.data.length % 2 && e.put(h0.indexOf(this.data[n]), 6)
}
;
var XN = Ca;
const eC = _s;
function Ra(t) {
    this.mode = eC.BYTE,
    typeof t == "string" ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t)
}
Ra.getBitsLength = function(e) {
    return e * 8
}
;
Ra.prototype.getLength = function() {
    return this.data.length
}
;
Ra.prototype.getBitsLength = function() {
    return Ra.getBitsLength(this.data.length)
}
;
Ra.prototype.write = function(t) {
    for (let e = 0, n = this.data.length; e < n; e++)
        t.put(this.data[e], 8)
}
;
var tC = Ra;
const nC = _s
  , rC = hr;
function La(t) {
    this.mode = nC.KANJI,
    this.data = t
}
La.getBitsLength = function(e) {
    return e * 13
}
;
La.prototype.getLength = function() {
    return this.data.length
}
;
La.prototype.getBitsLength = function() {
    return La.getBitsLength(this.data.length)
}
;
La.prototype.write = function(t) {
    let e;
    for (e = 0; e < this.data.length; e++) {
        let n = rC.toSJIS(this.data[e]);
        if (n >= 33088 && n <= 40956)
            n -= 33088;
        else if (n >= 57408 && n <= 60351)
            n -= 49472;
        else
            throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
        n = (n >>> 8 & 255) * 192 + (n & 255),
        t.put(n, 13)
    }
}
;
var iC = La
  , QS = {
    exports: {}
};
(function(t) {
    var e = {
        single_source_shortest_paths: function(n, r, i) {
            var s = {}
              , o = {};
            o[r] = 0;
            var a = e.PriorityQueue.make();
            a.push(r, 0);
            for (var l, c, d, h, y, m, v, E, A; !a.empty(); ) {
                l = a.pop(),
                c = l.value,
                h = l.cost,
                y = n[c] || {};
                for (d in y)
                    y.hasOwnProperty(d) && (m = y[d],
                    v = h + m,
                    E = o[d],
                    A = typeof o[d] > "u",
                    (A || E > v) && (o[d] = v,
                    a.push(d, v),
                    s[d] = c))
            }
            if (typeof i < "u" && typeof o[i] > "u") {
                var _ = ["Could not find a path from ", r, " to ", i, "."].join("");
                throw new Error(_)
            }
            return s
        },
        extract_shortest_path_from_predecessor_list: function(n, r) {
            for (var i = [], s = r; s; )
                i.push(s),
                n[s],
                s = n[s];
            return i.reverse(),
            i
        },
        find_path: function(n, r, i) {
            var s = e.single_source_shortest_paths(n, r, i);
            return e.extract_shortest_path_from_predecessor_list(s, i)
        },
        PriorityQueue: {
            make: function(n) {
                var r = e.PriorityQueue, i = {}, s;
                n = n || {};
                for (s in r)
                    r.hasOwnProperty(s) && (i[s] = r[s]);
                return i.queue = [],
                i.sorter = n.sorter || r.default_sorter,
                i
            },
            default_sorter: function(n, r) {
                return n.cost - r.cost
            },
            push: function(n, r) {
                var i = {
                    value: n,
                    cost: r
                };
                this.queue.push(i),
                this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    t.exports = e
}
)(QS);
var sC = QS.exports;
(function(t) {
    const e = _s
      , n = QN
      , r = XN
      , i = tC
      , s = iC
      , o = ai
      , a = hr
      , l = sC;
    function c(_) {
        return unescape(encodeURIComponent(_)).length
    }
    function d(_, x, b) {
        const R = [];
        let O;
        for (; (O = _.exec(b)) !== null; )
            R.push({
                data: O[0],
                index: O.index,
                mode: x,
                length: O[0].length
            });
        return R
    }
    function h(_) {
        const x = d(o.NUMERIC, e.NUMERIC, _)
          , b = d(o.ALPHANUMERIC, e.ALPHANUMERIC, _);
        let R, O;
        return a.isKanjiModeEnabled() ? (R = d(o.BYTE, e.BYTE, _),
        O = d(o.KANJI, e.KANJI, _)) : (R = d(o.BYTE_KANJI, e.BYTE, _),
        O = []),
        x.concat(b, R, O).sort(function(z, K) {
            return z.index - K.index
        }).map(function(z) {
            return {
                data: z.data,
                mode: z.mode,
                length: z.length
            }
        })
    }
    function y(_, x) {
        switch (x) {
        case e.NUMERIC:
            return n.getBitsLength(_);
        case e.ALPHANUMERIC:
            return r.getBitsLength(_);
        case e.KANJI:
            return s.getBitsLength(_);
        case e.BYTE:
            return i.getBitsLength(_)
        }
    }
    function m(_) {
        return _.reduce(function(x, b) {
            const R = x.length - 1 >= 0 ? x[x.length - 1] : null;
            return R && R.mode === b.mode ? (x[x.length - 1].data += b.data,
            x) : (x.push(b),
            x)
        }, [])
    }
    function v(_) {
        const x = [];
        for (let b = 0; b < _.length; b++) {
            const R = _[b];
            switch (R.mode) {
            case e.NUMERIC:
                x.push([R, {
                    data: R.data,
                    mode: e.ALPHANUMERIC,
                    length: R.length
                }, {
                    data: R.data,
                    mode: e.BYTE,
                    length: R.length
                }]);
                break;
            case e.ALPHANUMERIC:
                x.push([R, {
                    data: R.data,
                    mode: e.BYTE,
                    length: R.length
                }]);
                break;
            case e.KANJI:
                x.push([R, {
                    data: R.data,
                    mode: e.BYTE,
                    length: c(R.data)
                }]);
                break;
            case e.BYTE:
                x.push([{
                    data: R.data,
                    mode: e.BYTE,
                    length: c(R.data)
                }])
            }
        }
        return x
    }
    function E(_, x) {
        const b = {}
          , R = {
            start: {}
        };
        let O = ["start"];
        for (let D = 0; D < _.length; D++) {
            const z = _[D]
              , K = [];
            for (let F = 0; F < z.length; F++) {
                const G = z[F]
                  , Z = "" + D + F;
                K.push(Z),
                b[Z] = {
                    node: G,
                    lastCount: 0
                },
                R[Z] = {};
                for (let X = 0; X < O.length; X++) {
                    const T = O[X];
                    b[T] && b[T].node.mode === G.mode ? (R[T][Z] = y(b[T].lastCount + G.length, G.mode) - y(b[T].lastCount, G.mode),
                    b[T].lastCount += G.length) : (b[T] && (b[T].lastCount = G.length),
                    R[T][Z] = y(G.length, G.mode) + 4 + e.getCharCountIndicator(G.mode, x))
                }
            }
            O = K
        }
        for (let D = 0; D < O.length; D++)
            R[O[D]].end = 0;
        return {
            map: R,
            table: b
        }
    }
    function A(_, x) {
        let b;
        const R = e.getBestModeForData(_);
        if (b = e.from(x, R),
        b !== e.BYTE && b.bit < R.bit)
            throw new Error('"' + _ + '" cannot be encoded with mode ' + e.toString(b) + `.
 Suggested mode is: ` + e.toString(R));
        switch (b === e.KANJI && !a.isKanjiModeEnabled() && (b = e.BYTE),
        b) {
        case e.NUMERIC:
            return new n(_);
        case e.ALPHANUMERIC:
            return new r(_);
        case e.KANJI:
            return new s(_);
        case e.BYTE:
            return new i(_)
        }
    }
    t.fromArray = function(x) {
        return x.reduce(function(b, R) {
            return typeof R == "string" ? b.push(A(R, null)) : R.data && b.push(A(R.data, R.mode)),
            b
        }, [])
    }
    ,
    t.fromString = function(x, b) {
        const R = h(x, a.isKanjiModeEnabled())
          , O = v(R)
          , D = E(O, b)
          , z = l.find_path(D.map, "start", "end")
          , K = [];
        for (let F = 1; F < z.length - 1; F++)
            K.push(D.table[z[F]].node);
        return t.fromArray(m(K))
    }
    ,
    t.rawSplit = function(x) {
        return t.fromArray(h(x, a.isKanjiModeEnabled()))
    }
}
)(ZS);
const Vh = hr
  , f0 = Fh
  , oC = UN
  , aC = WN
  , lC = WS
  , cC = FS
  , zp = $S
  , Up = $h
  , uC = $N
  , Kd = HS
  , dC = GS
  , hC = _s
  , p0 = ZS;
function fC(t, e) {
    const n = t.size
      , r = cC.getPositions(e);
    for (let i = 0; i < r.length; i++) {
        const s = r[i][0]
          , o = r[i][1];
        for (let a = -1; a <= 7; a++)
            if (!(s + a <= -1 || n <= s + a))
                for (let l = -1; l <= 7; l++)
                    o + l <= -1 || n <= o + l || (a >= 0 && a <= 6 && (l === 0 || l === 6) || l >= 0 && l <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && l >= 2 && l <= 4 ? t.set(s + a, o + l, !0, !0) : t.set(s + a, o + l, !1, !0))
    }
}
function pC(t) {
    const e = t.size;
    for (let n = 8; n < e - 8; n++) {
        const r = n % 2 === 0;
        t.set(n, 6, r, !0),
        t.set(6, n, r, !0)
    }
}
function gC(t, e) {
    const n = lC.getPositions(e);
    for (let r = 0; r < n.length; r++) {
        const i = n[r][0]
          , s = n[r][1];
        for (let o = -2; o <= 2; o++)
            for (let a = -2; a <= 2; a++)
                o === -2 || o === 2 || a === -2 || a === 2 || o === 0 && a === 0 ? t.set(i + o, s + a, !0, !0) : t.set(i + o, s + a, !1, !0)
    }
}
function mC(t, e) {
    const n = t.size
      , r = Kd.getEncodedBits(e);
    let i, s, o;
    for (let a = 0; a < 18; a++)
        i = Math.floor(a / 3),
        s = a % 3 + n - 8 - 3,
        o = (r >> a & 1) === 1,
        t.set(i, s, o, !0),
        t.set(s, i, o, !0)
}
function g0(t, e, n) {
    const r = t.size
      , i = dC.getEncodedBits(e, n);
    let s, o;
    for (s = 0; s < 15; s++)
        o = (i >> s & 1) === 1,
        s < 6 ? t.set(s, 8, o, !0) : s < 8 ? t.set(s + 1, 8, o, !0) : t.set(r - 15 + s, 8, o, !0),
        s < 8 ? t.set(8, r - s - 1, o, !0) : s < 9 ? t.set(8, 15 - s - 1 + 1, o, !0) : t.set(8, 15 - s - 1, o, !0);
    t.set(r - 8, 8, 1, !0)
}
function yC(t, e) {
    const n = t.size;
    let r = -1
      , i = n - 1
      , s = 7
      , o = 0;
    for (let a = n - 1; a > 0; a -= 2)
        for (a === 6 && a--; ; ) {
            for (let l = 0; l < 2; l++)
                if (!t.isReserved(i, a - l)) {
                    let c = !1;
                    o < e.length && (c = (e[o] >>> s & 1) === 1),
                    t.set(i, a - l, c),
                    s--,
                    s === -1 && (o++,
                    s = 7)
                }
            if (i += r,
            i < 0 || n <= i) {
                i -= r,
                r = -r;
                break
            }
        }
}
function wC(t, e, n) {
    const r = new oC;
    n.forEach(function(l) {
        r.put(l.mode.bit, 4),
        r.put(l.getLength(), hC.getCharCountIndicator(l.mode, t)),
        l.write(r)
    });
    const i = Vh.getSymbolTotalCodewords(t)
      , s = Up.getTotalCodewordsCount(t, e)
      , o = (i - s) * 8;
    for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 !== 0; )
        r.putBit(0);
    const a = (o - r.getLengthInBits()) / 8;
    for (let l = 0; l < a; l++)
        r.put(l % 2 ? 17 : 236, 8);
    return vC(r, t, e)
}
function vC(t, e, n) {
    const r = Vh.getSymbolTotalCodewords(e)
      , i = Up.getTotalCodewordsCount(e, n)
      , s = r - i
      , o = Up.getBlocksCount(e, n)
      , a = r % o
      , l = o - a
      , c = Math.floor(r / o)
      , d = Math.floor(s / o)
      , h = d + 1
      , y = c - d
      , m = new uC(y);
    let v = 0;
    const E = new Array(o)
      , A = new Array(o);
    let _ = 0;
    const x = new Uint8Array(t.buffer);
    for (let z = 0; z < o; z++) {
        const K = z < l ? d : h;
        E[z] = x.slice(v, v + K),
        A[z] = m.encode(E[z]),
        v += K,
        _ = Math.max(_, K)
    }
    const b = new Uint8Array(r);
    let R = 0, O, D;
    for (O = 0; O < _; O++)
        for (D = 0; D < o; D++)
            O < E[D].length && (b[R++] = E[D][O]);
    for (O = 0; O < y; O++)
        for (D = 0; D < o; D++)
            b[R++] = A[D][O];
    return b
}
function bC(t, e, n, r) {
    let i;
    if (Array.isArray(t))
        i = p0.fromArray(t);
    else if (typeof t == "string") {
        let c = e;
        if (!c) {
            const d = p0.rawSplit(t);
            c = Kd.getBestVersionForData(d, n)
        }
        i = p0.fromString(t, c || 40)
    } else
        throw new Error("Invalid data");
    const s = Kd.getBestVersionForData(i, n);
    if (!s)
        throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!e)
        e = s;
    else if (e < s)
        throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + s + `.
`);
    const o = wC(e, n, i)
      , a = Vh.getSymbolSize(e)
      , l = new aC(a);
    return fC(l, e),
    pC(l),
    gC(l, e),
    g0(l, n, 0),
    e >= 7 && mC(l, e),
    yC(l, o),
    isNaN(r) && (r = zp.getBestMask(l, g0.bind(null, l, n))),
    zp.applyMask(r, l),
    g0(l, n, r),
    {
        modules: l,
        version: e,
        errorCorrectionLevel: n,
        maskPattern: r,
        segments: i
    }
}
zS.create = function(e, n) {
    if (typeof e > "u" || e === "")
        throw new Error("No input text");
    let r = f0.M, i, s;
    return typeof n < "u" && (r = f0.from(n.errorCorrectionLevel, f0.M),
    i = Kd.from(n.version),
    s = zp.from(n.maskPattern),
    n.toSJISFunc && Vh.setToSJISFunction(n.toSJISFunc)),
    bC(e, i, r, s)
}
;
var JS = {}
  , _y = {};
(function(t) {
    function e(n) {
        if (typeof n == "number" && (n = n.toString()),
        typeof n != "string")
            throw new Error("Color should be defined as hex string");
        let r = n.slice().replace("#", "").split("");
        if (r.length < 3 || r.length === 5 || r.length > 8)
            throw new Error("Invalid hex color: " + n);
        (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(s) {
            return [s, s]
        }))),
        r.length === 6 && r.push("F", "F");
        const i = parseInt(r.join(""), 16);
        return {
            r: i >> 24 & 255,
            g: i >> 16 & 255,
            b: i >> 8 & 255,
            a: i & 255,
            hex: "#" + r.slice(0, 6).join("")
        }
    }
    t.getOptions = function(r) {
        r || (r = {}),
        r.color || (r.color = {});
        const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin
          , s = r.width && r.width >= 21 ? r.width : void 0
          , o = r.scale || 4;
        return {
            width: s,
            scale: s ? 4 : o,
            margin: i,
            color: {
                dark: e(r.color.dark || "#000000ff"),
                light: e(r.color.light || "#ffffffff")
            },
            type: r.type,
            rendererOpts: r.rendererOpts || {}
        }
    }
    ,
    t.getScale = function(r, i) {
        return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale
    }
    ,
    t.getImageWidth = function(r, i) {
        const s = t.getScale(r, i);
        return Math.floor((r + i.margin * 2) * s)
    }
    ,
    t.qrToImageData = function(r, i, s) {
        const o = i.modules.size
          , a = i.modules.data
          , l = t.getScale(o, s)
          , c = Math.floor((o + s.margin * 2) * l)
          , d = s.margin * l
          , h = [s.color.light, s.color.dark];
        for (let y = 0; y < c; y++)
            for (let m = 0; m < c; m++) {
                let v = (y * c + m) * 4
                  , E = s.color.light;
                if (y >= d && m >= d && y < c - d && m < c - d) {
                    const A = Math.floor((y - d) / l)
                      , _ = Math.floor((m - d) / l);
                    E = h[a[A * o + _] ? 1 : 0]
                }
                r[v++] = E.r,
                r[v++] = E.g,
                r[v++] = E.b,
                r[v] = E.a
            }
    }
}
)(_y);
(function(t) {
    const e = _y;
    function n(i, s, o) {
        i.clearRect(0, 0, s.width, s.height),
        s.style || (s.style = {}),
        s.height = o,
        s.width = o,
        s.style.height = o + "px",
        s.style.width = o + "px"
    }
    function r() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    t.render = function(s, o, a) {
        let l = a
          , c = o;
        typeof l > "u" && (!o || !o.getContext) && (l = o,
        o = void 0),
        o || (c = r()),
        l = e.getOptions(l);
        const d = e.getImageWidth(s.modules.size, l)
          , h = c.getContext("2d")
          , y = h.createImageData(d, d);
        return e.qrToImageData(y.data, s, l),
        n(h, c, d),
        h.putImageData(y, 0, 0),
        c
    }
    ,
    t.renderToDataURL = function(s, o, a) {
        let l = a;
        typeof l > "u" && (!o || !o.getContext) && (l = o,
        o = void 0),
        l || (l = {});
        const c = t.render(s, o, l)
          , d = l.type || "image/png"
          , h = l.rendererOpts || {};
        return c.toDataURL(d, h.quality)
    }
}
)(JS);
var XS = {};
const _C = _y;
function z1(t, e) {
    const n = t.a / 255
      , r = e + '="' + t.hex + '"';
    return n < 1 ? r + " " + e + '-opacity="' + n.toFixed(2).slice(1) + '"' : r
}
function m0(t, e, n) {
    let r = t + e;
    return typeof n < "u" && (r += " " + n),
    r
}
function xC(t, e, n) {
    let r = ""
      , i = 0
      , s = !1
      , o = 0;
    for (let a = 0; a < t.length; a++) {
        const l = Math.floor(a % e)
          , c = Math.floor(a / e);
        !l && !s && (s = !0),
        t[a] ? (o++,
        a > 0 && l > 0 && t[a - 1] || (r += s ? m0("M", l + n, .5 + c + n) : m0("m", i, 0),
        i = 0,
        s = !1),
        l + 1 < e && t[a + 1] || (r += m0("h", o),
        o = 0)) : i++
    }
    return r
}
XS.render = function(e, n, r) {
    const i = _C.getOptions(n)
      , s = e.modules.size
      , o = e.modules.data
      , a = s + i.margin * 2
      , l = i.color.light.a ? "<path " + z1(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : ""
      , c = "<path " + z1(i.color.dark, "stroke") + ' d="' + xC(o, s, i.margin) + '"/>'
      , d = 'viewBox="0 0 ' + a + " " + a + '"'
      , y = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + d + ' shape-rendering="crispEdges">' + l + c + `</svg>
`;
    return typeof r == "function" && r(null, y),
    y
}
;
const SC = DN
  , Wp = zS
  , ek = JS
  , kC = XS;
function xy(t, e, n, r, i) {
    const s = [].slice.call(arguments, 1)
      , o = s.length
      , a = typeof s[o - 1] == "function";
    if (!a && !SC())
        throw new Error("Callback required as last argument");
    if (a) {
        if (o < 2)
            throw new Error("Too few arguments provided");
        o === 2 ? (i = n,
        n = e,
        e = r = void 0) : o === 3 && (e.getContext && typeof i > "u" ? (i = r,
        r = void 0) : (i = r,
        r = n,
        n = e,
        e = void 0))
    } else {
        if (o < 1)
            throw new Error("Too few arguments provided");
        return o === 1 ? (n = e,
        e = r = void 0) : o === 2 && !e.getContext && (r = n,
        n = e,
        e = void 0),
        new Promise(function(l, c) {
            try {
                const d = Wp.create(n, r);
                l(t(d, e, r))
            } catch (d) {
                c(d)
            }
        }
        )
    }
    try {
        const l = Wp.create(n, r);
        i(null, t(l, e, r))
    } catch (l) {
        i(l)
    }
}
Cc.create = Wp.create;
Cc.toCanvas = xy.bind(null, ek.render);
Cc.toDataURL = xy.bind(null, ek.renderToDataURL);
Cc.toString = xy.bind(null, function(t, e, n) {
    return kC.render(t, n)
});
function y0(t) {
    switch (t) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
        return t;
    case "recent":
        return "processed";
    case "single":
    case "singleGossip":
        return "confirmed";
    case "max":
    case "root":
        return "finalized";
    default:
        return
    }
}
var Zr = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.SOLANA_CHAINS = t.SOLANA_LOCALNET_CHAIN = t.SOLANA_TESTNET_CHAIN = t.SOLANA_DEVNET_CHAIN = t.SOLANA_MAINNET_CHAIN = void 0,
    t.isSolanaChain = e,
    t.SOLANA_MAINNET_CHAIN = "solana:mainnet",
    t.SOLANA_DEVNET_CHAIN = "solana:devnet",
    t.SOLANA_TESTNET_CHAIN = "solana:testnet",
    t.SOLANA_LOCALNET_CHAIN = "solana:localnet",
    t.SOLANA_CHAINS = [t.SOLANA_MAINNET_CHAIN, t.SOLANA_DEVNET_CHAIN, t.SOLANA_TESTNET_CHAIN, t.SOLANA_LOCALNET_CHAIN];
    function e(n) {
        return t.SOLANA_CHAINS.includes(n)
    }
}
)(Zr);
const EC = "https://api.mainnet-beta.solana.com";
function AC(t) {
    return t.includes(EC) ? Zr.SOLANA_MAINNET_CHAIN : /\bdevnet\b/i.test(t) ? Zr.SOLANA_DEVNET_CHAIN : /\btestnet\b/i.test(t) ? Zr.SOLANA_TESTNET_CHAIN : /\blocalhost\b/i.test(t) || /\b127\.0\.0\.1\b/.test(t) ? Zr.SOLANA_LOCALNET_CHAIN : Zr.SOLANA_MAINNET_CHAIN
}
function IC(t) {
    let e = `${t.domain} wants you to sign in with your Solana account:
`;
    e += `${t.address}`,
    t.statement && (e += `

${t.statement}`);
    const n = [];
    if (t.uri && n.push(`URI: ${t.uri}`),
    t.version && n.push(`Version: ${t.version}`),
    t.chainId && n.push(`Chain ID: ${t.chainId}`),
    t.nonce && n.push(`Nonce: ${t.nonce}`),
    t.issuedAt && n.push(`Issued At: ${t.issuedAt}`),
    t.expirationTime && n.push(`Expiration Time: ${t.expirationTime}`),
    t.notBefore && n.push(`Not Before: ${t.notBefore}`),
    t.requestId && n.push(`Request ID: ${t.requestId}`),
    t.resources) {
        n.push("Resources:");
        for (const r of t.resources)
            n.push(`- ${r}`)
    }
    return n.length && (e += `

${n.join(`
`)}`),
    e
}
const or = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_REFLECTOR_ID_OUT_OF_RANGE: "ERROR_REFLECTOR_ID_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
    ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION",
    ERROR_BROWSER_NOT_SUPPORTED: "ERROR_BROWSER_NOT_SUPPORTED"
};
class ar extends Error {
    constructor(...e) {
        const [n,r,i] = e;
        super(r),
        this.code = n,
        this.data = i,
        this.name = "SolanaMobileWalletAdapterError"
    }
}
const MC = {
    ERROR_AUTHORIZATION_FAILED: -1,
    ERROR_INVALID_PAYLOADS: -2,
    ERROR_NOT_SIGNED: -3,
    ERROR_NOT_SUBMITTED: -4,
    ERROR_TOO_MANY_PAYLOADS: -5,
    ERROR_ATTEST_ORIGIN_ANDROID: -100
};
class Hh extends Error {
    constructor(...e) {
        const [n,r,i,s] = e;
        super(i),
        this.code = r,
        this.data = s,
        this.jsonRpcMessageId = n,
        this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}
function $e(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
function TC(t) {
    return window.btoa(t)
}
function Fp(t, e) {
    const n = window.btoa(String.fromCharCode.call(null, ...t));
    return e ? n.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") : n
}
function NC(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}
function Tu(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = yield crypto.subtle.exportKey("raw", t)
          , r = yield crypto.subtle.sign({
            hash: "SHA-256",
            name: "ECDSA"
        }, e, n)
          , i = new Uint8Array(n.byteLength + r.byteLength);
        return i.set(new Uint8Array(n), 0),
        i.set(new Uint8Array(r), n.byteLength),
        i
    })
}
function CC(t) {
    return IC(t)
}
function RC(t) {
    return TC(CC(t))
}
const tk = "solana:signTransactions"
  , $p = "solana:cloneAuthorization"
  , LC = "solana:signInWithSolana";
function nk(t, e) {
    return new Proxy({},{
        get(n, r) {
            return r === "then" ? null : (n[r] == null && (n[r] = function(i) {
                return $e(this, void 0, void 0, function*() {
                    const {method: s, params: o} = jC(r, i, t)
                      , a = yield e(s, o);
                    return s === "authorize" && o.sign_in_payload && !a.sign_in_result && (a.sign_in_result = yield PC(o.sign_in_payload, a, e)),
                    BC(r, a, t)
                })
            }
            ),
            n[r])
        },
        defineProperty() {
            return !1
        },
        deleteProperty() {
            return !1
        }
    })
}
function jC(t, e, n) {
    let r = e
      , i = t.toString().replace(/[A-Z]/g, s => `_${s.toLowerCase()}`).toLowerCase();
    switch (t) {
    case "authorize":
        {
            let {chain: s} = r;
            if (n === "legacy") {
                switch (s) {
                case "solana:testnet":
                    {
                        s = "testnet";
                        break
                    }
                case "solana:devnet":
                    {
                        s = "devnet";
                        break
                    }
                case "solana:mainnet":
                    {
                        s = "mainnet-beta";
                        break
                    }
                default:
                    s = r.cluster
                }
                r.cluster = s
            } else {
                switch (s) {
                case "testnet":
                case "devnet":
                    {
                        s = `solana:${s}`;
                        break
                    }
                case "mainnet-beta":
                    {
                        s = "solana:mainnet";
                        break
                    }
                }
                r.chain = s
            }
        }
    case "reauthorize":
        {
            const {auth_token: s, identity: o} = r;
            if (s)
                switch (n) {
                case "legacy":
                    {
                        i = "reauthorize",
                        r = {
                            auth_token: s,
                            identity: o
                        };
                        break
                    }
                default:
                    {
                        i = "authorize";
                        break
                    }
                }
            break
        }
    }
    return {
        method: i,
        params: r
    }
}
function BC(t, e, n) {
    switch (t) {
    case "getCapabilities":
        {
            const r = e;
            switch (n) {
            case "legacy":
                {
                    const i = [tk];
                    return r.supports_clone_authorization === !0 && i.push($p),
                    Object.assign(Object.assign({}, r), {
                        features: i
                    })
                }
            case "v1":
                return Object.assign(Object.assign({}, r), {
                    supports_sign_and_send_transactions: !0,
                    supports_clone_authorization: r.features.includes($p)
                })
            }
        }
    }
    return e
}
function PC(t, e, n) {
    var r;
    return $e(this, void 0, void 0, function*() {
        const i = (r = t.domain) !== null && r !== void 0 ? r : window.location.host
          , s = e.accounts[0].address
          , o = RC(Object.assign(Object.assign({}, t), {
            domain: i,
            address: s
        }))
          , a = yield n("sign_messages", {
            addresses: [s],
            payloads: [o]
        });
        return {
            address: s,
            signed_message: o,
            signature: a.signed_payloads[0].slice(o.length)
        }
    })
}
const Ei = 4;
function OC(t) {
    if (t >= 4294967296)
        throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    const e = new ArrayBuffer(Ei);
    return new DataView(e).setUint32(0, t, !1),
    new Uint8Array(e)
}
const Kp = 12
  , Sy = 65;
function DC(t, e, n) {
    return $e(this, void 0, void 0, function*() {
        const r = OC(e)
          , i = new Uint8Array(Kp);
        crypto.getRandomValues(i);
        const s = yield crypto.subtle.encrypt(ik(r, i), n, new TextEncoder().encode(t))
          , o = new Uint8Array(r.byteLength + i.byteLength + s.byteLength);
        return o.set(new Uint8Array(r), 0),
        o.set(new Uint8Array(i), r.byteLength),
        o.set(new Uint8Array(s), r.byteLength + i.byteLength),
        o
    })
}
function rk(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = t.slice(0, Ei)
          , r = t.slice(Ei, Ei + Kp)
          , i = t.slice(Ei + Kp)
          , s = yield crypto.subtle.decrypt(ik(n, r), e, i);
        return zC().decode(s)
    })
}
function ik(t, e) {
    return {
        additionalData: t,
        iv: e,
        name: "AES-GCM",
        tagLength: 128
    }
}
let w0;
function zC() {
    return w0 === void 0 && (w0 = new TextDecoder("utf-8")),
    w0
}
function sk() {
    return $e(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-256"
        }, !1, ["sign"])
    })
}
function Nu() {
    return $e(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, ["deriveKey", "deriveBits"])
    })
}
function ok(t) {
    let e = "";
    const n = new Uint8Array(t)
      , r = n.byteLength;
    for (let i = 0; i < r; i++)
        e += String.fromCharCode(n[i]);
    return window.btoa(e)
}
function UC() {
    return ak(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)))
}
function ak(t) {
    if (t < 49152 || t > 65535)
        throw new ar(or.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,`Association port number must be between 49152 and 65535. ${t} given.`,{
            port: t
        });
    return t
}
function lk(t) {
    return t.replace(/[/+=]/g, e => ({
        "/": "_",
        "+": "-",
        "=": "."
    })[e])
}
const WC = "solana-wallet";
function U1(t) {
    return t.replace(/(^\/+|\/+$)/g, "").split("/")
}
function ck(t, e) {
    let n = null;
    if (e) {
        try {
            n = new URL(e)
        } catch {}
        if (n?.protocol !== "https:")
            throw new ar(or.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
    }
    n || (n = new URL(`${WC}:/`));
    const r = t.startsWith("/") ? t : [...U1(n.pathname), ...U1(t)].join("/");
    return new URL(r,n)
}
function FC(t, e, n, r=["v1"]) {
    return $e(this, void 0, void 0, function*() {
        const i = ak(e)
          , s = yield crypto.subtle.exportKey("raw", t)
          , o = ok(s)
          , a = ck("v1/associate/local", n);
        return a.searchParams.set("association", lk(o)),
        a.searchParams.set("port", `${i}`),
        r.forEach(l => {
            a.searchParams.set("v", l)
        }
        ),
        a
    })
}
function $C(t, e, n, r, i=["v1"]) {
    return $e(this, void 0, void 0, function*() {
        const s = yield crypto.subtle.exportKey("raw", t)
          , o = ok(s)
          , a = ck("v1/associate/remote", r);
        return a.searchParams.set("association", lk(o)),
        a.searchParams.set("reflector", `${e}`),
        a.searchParams.set("id", `${Fp(n, !0)}`),
        i.forEach(l => {
            a.searchParams.set("v", l)
        }
        ),
        a
    })
}
function uk(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = JSON.stringify(t)
          , r = t.id;
        return DC(n, r, e)
    })
}
function dk(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = yield rk(t, e)
          , r = JSON.parse(n);
        if (Object.hasOwnProperty.call(r, "error"))
            throw new Hh(r.id,r.error.code,r.error.message);
        return r
    })
}
function hk(t, e, n) {
    return $e(this, void 0, void 0, function*() {
        const [r,i] = yield Promise.all([crypto.subtle.exportKey("raw", e), crypto.subtle.importKey("raw", t.slice(0, Sy), {
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, [])])
          , s = yield crypto.subtle.deriveBits({
            name: "ECDH",
            public: i
        }, n, 256)
          , o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(r),
            info: new Uint8Array
        }, o, {
            name: "AES-GCM",
            length: 128
        }, !1, ["encrypt", "decrypt"])
    })
}
function fk(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = yield rk(t, e)
          , r = JSON.parse(n);
        let i = "legacy";
        if (Object.hasOwnProperty.call(r, "v"))
            switch (r.v) {
            case 1:
            case "1":
            case "v1":
                i = "v1";
                break;
            case "legacy":
                i = "legacy";
                break;
            default:
                throw new ar(or.ERROR_INVALID_PROTOCOL_VERSION,`Unknown/unsupported protocol version: ${r.v}`)
            }
        return {
            protocol_version: i
        }
    })
}
const Vd = {
    Firefox: 0,
    Other: 1
};
function KC() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? Vd.Firefox : Vd.Other
}
function VC() {
    return new Promise( (t, e) => {
        function n() {
            clearTimeout(i),
            window.removeEventListener("blur", r)
        }
        function r() {
            n(),
            t()
        }
        window.addEventListener("blur", r);
        const i = setTimeout( () => {
            n(),
            e()
        }
        , 3e3)
    }
    )
}
let rl = null;
function HC(t) {
    rl == null && (rl = document.createElement("iframe"),
    rl.style.display = "none",
    document.body.appendChild(rl)),
    rl.contentWindow.location.href = t.toString()
}
function qC(t) {
    return $e(this, void 0, void 0, function*() {
        if (t.protocol === "https:")
            window.location.assign(t);
        else
            try {
                const e = KC();
                switch (e) {
                case Vd.Firefox:
                    HC(t);
                    break;
                case Vd.Other:
                    {
                        const n = VC();
                        window.location.assign(t),
                        yield n;
                        break
                    }
                default:
                }
            } catch {
                throw new ar(or.ERROR_WALLET_NOT_FOUND,"Found no installed wallet that supports the mobile wallet protocol.")
            }
    })
}
function GC(t, e) {
    return $e(this, void 0, void 0, function*() {
        const n = UC()
          , r = yield FC(t, n, e);
        return yield qC(r),
        n
    })
}
const Hd = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4
}
  , pk = "com.solana.mobilewalletadapter.v1"
  , W1 = "com.solana.mobilewalletadapter.v1.base64";
function gk() {
    if (typeof window > "u" || window.isSecureContext !== !0)
        throw new ar(or.ERROR_SECURE_CONTEXT_REQUIRED,"The mobile wallet adapter protocol must be used in a secure context (`https`).")
}
function mk(t) {
    let e;
    try {
        e = new URL(t)
    } catch {
        throw new ar(or.ERROR_FORBIDDEN_WALLET_BASE_URL,"Invalid base URL supplied by wallet")
    }
    if (e.protocol !== "https:")
        throw new ar(or.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
}
function qd(t) {
    return new DataView(t).getUint32(0, !1)
}
function YC(t) {
    var e = new Uint8Array(t), n = t.byteLength, r = 10, i = 0, s = 0, o;
    do {
        if (s >= n || s > r)
            throw new RangeError("Failed to decode varint");
        o = e[s++],
        i |= (o & 127) << 7 * s
    } while (o >= 128);
    return {
        value: i,
        offset: s
    }
}
function ZC(t) {
    let {value: e, offset: n} = YC(t);
    return new Uint8Array(t.slice(n, n + e))
}
function QC(t, e) {
    return $e(this, void 0, void 0, function*() {
        gk();
        const n = yield sk()
          , i = `ws://localhost:${yield GC(n.publicKey, e?.baseUri)}/solana-wallet`;
        let s;
        const o = ( () => {
            const d = [...Hd.retryDelayScheduleMs];
            return () => d.length > 1 ? d.shift() : d[0]
        }
        )();
        let a = 1
          , l = 0
          , c = {
            __type: "disconnected"
        };
        return new Promise( (d, h) => {
            let y;
            const m = {}
              , v = () => $e(this, void 0, void 0, function*() {
                if (c.__type !== "connecting") {
                    console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${c.__type}\`.`);
                    return
                }
                y.removeEventListener("open", v);
                const {associationKeypair: O} = c
                  , D = yield Nu();
                y.send(yield Tu(D.publicKey, O.privateKey)),
                c = {
                    __type: "hello_req_sent",
                    associationPublicKey: O.publicKey,
                    ecdhPrivateKey: D.privateKey
                }
            })
              , E = O => {
                O.wasClean ? c = {
                    __type: "disconnected"
                } : h(new ar(or.ERROR_SESSION_CLOSED,`The wallet session dropped unexpectedly (${O.code}: ${O.reason}).`,{
                    closeEvent: O
                })),
                x()
            }
              , A = O => $e(this, void 0, void 0, function*() {
                x(),
                Date.now() - s >= Hd.timeoutMs ? h(new ar(or.ERROR_SESSION_TIMEOUT,`Failed to connect to the wallet websocket at ${i}.`)) : (yield new Promise(D => {
                    const z = o();
                    b = window.setTimeout(D, z)
                }
                ),
                R())
            })
              , _ = O => $e(this, void 0, void 0, function*() {
                const D = yield O.data.arrayBuffer();
                switch (c.__type) {
                case "connecting":
                    if (D.byteLength !== 0)
                        throw new Error("Encountered unexpected message while connecting");
                    const z = yield Nu();
                    y.send(yield Tu(z.publicKey, n.privateKey)),
                    c = {
                        __type: "hello_req_sent",
                        associationPublicKey: n.publicKey,
                        ecdhPrivateKey: z.privateKey
                    };
                    break;
                case "connected":
                    try {
                        const K = D.slice(0, Ei)
                          , F = qd(K);
                        if (F !== l + 1)
                            throw new Error("Encrypted message has invalid sequence number");
                        l = F;
                        const G = yield dk(D, c.sharedSecret)
                          , Z = m[G.id];
                        delete m[G.id],
                        Z.resolve(G.result)
                    } catch (K) {
                        if (K instanceof Hh) {
                            const F = m[K.jsonRpcMessageId];
                            delete m[K.jsonRpcMessageId],
                            F.reject(K)
                        } else
                            throw K
                    }
                    break;
                case "hello_req_sent":
                    {
                        if (D.byteLength === 0) {
                            const X = yield Nu();
                            y.send(yield Tu(X.publicKey, n.privateKey)),
                            c = {
                                __type: "hello_req_sent",
                                associationPublicKey: n.publicKey,
                                ecdhPrivateKey: X.privateKey
                            };
                            break
                        }
                        const K = yield hk(D, c.associationPublicKey, c.ecdhPrivateKey)
                          , F = D.slice(Sy)
                          , G = F.byteLength !== 0 ? yield( () => $e(this, void 0, void 0, function*() {
                            const X = F.slice(0, Ei)
                              , T = qd(X);
                            if (T !== l + 1)
                                throw new Error("Encrypted message has invalid sequence number");
                            return l = T,
                            fk(F, K)
                        }))() : {
                            protocol_version: "legacy"
                        };
                        c = {
                            __type: "connected",
                            sharedSecret: K,
                            sessionProperties: G
                        };
                        const Z = nk(G.protocol_version, (X, T) => $e(this, void 0, void 0, function*() {
                            const u = a++;
                            return y.send(yield uk({
                                id: u,
                                jsonrpc: "2.0",
                                method: X,
                                params: T ?? {}
                            }, K)),
                            new Promise( (p, k) => {
                                m[u] = {
                                    resolve(C) {
                                        switch (X) {
                                        case "authorize":
                                        case "reauthorize":
                                            {
                                                const {wallet_uri_base: I} = C;
                                                if (I != null)
                                                    try {
                                                        mk(I)
                                                    } catch (L) {
                                                        k(L);
                                                        return
                                                    }
                                                break
                                            }
                                        }
                                        p(C)
                                    },
                                    reject: k
                                }
                            }
                            )
                        }));
                        try {
                            d(yield t(Z))
                        } catch (X) {
                            h(X)
                        } finally {
                            x(),
                            y.close()
                        }
                        break
                    }
                }
            });
            let x, b;
            const R = () => {
                x && x(),
                c = {
                    __type: "connecting",
                    associationKeypair: n
                },
                s === void 0 && (s = Date.now()),
                y = new WebSocket(i,[pk]),
                y.addEventListener("open", v),
                y.addEventListener("close", E),
                y.addEventListener("error", A),
                y.addEventListener("message", _),
                x = () => {
                    window.clearTimeout(b),
                    y.removeEventListener("open", v),
                    y.removeEventListener("close", E),
                    y.removeEventListener("error", A),
                    y.removeEventListener("message", _)
                }
            }
            ;
            R()
        }
        )
    })
}
function JC(t) {
    return $e(this, void 0, void 0, function*() {
        gk();
        const e = yield sk()
          , n = `wss://${t?.remoteHostAuthority}/reflect`;
        let r;
        const i = ( () => {
            const E = [...Hd.retryDelayScheduleMs];
            return () => E.length > 1 ? E.shift() : E[0]
        }
        )();
        let s = 1, o = 0, a, l = {
            __type: "disconnected"
        }, c, d, h = E => $e(this, void 0, void 0, function*() {
            if (a == "base64") {
                const A = yield E.data;
                return NC(A).buffer
            } else
                return yield E.data.arrayBuffer()
        });
        const y = yield new Promise( (E, A) => {
            const _ = () => $e(this, void 0, void 0, function*() {
                if (l.__type !== "connecting") {
                    console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${l.__type}\`.`);
                    return
                }
                c.protocol.includes(W1) ? a = "base64" : a = "binary",
                c.removeEventListener("open", _)
            })
              , x = z => {
                z.wasClean ? l = {
                    __type: "disconnected"
                } : A(new ar(or.ERROR_SESSION_CLOSED,`The wallet session dropped unexpectedly (${z.code}: ${z.reason}).`,{
                    closeEvent: z
                })),
                d()
            }
              , b = z => $e(this, void 0, void 0, function*() {
                d(),
                Date.now() - r >= Hd.timeoutMs ? A(new ar(or.ERROR_SESSION_TIMEOUT,`Failed to connect to the wallet websocket at ${n}.`)) : (yield new Promise(K => {
                    const F = i();
                    O = window.setTimeout(K, F)
                }
                ),
                D())
            })
              , R = z => $e(this, void 0, void 0, function*() {
                const K = yield h(z);
                if (l.__type === "connecting") {
                    if (K.byteLength == 0)
                        throw new Error("Encountered unexpected message while connecting");
                    const F = ZC(K);
                    l = {
                        __type: "reflector_id_received",
                        reflectorId: F
                    };
                    const G = yield $C(e.publicKey, t.remoteHostAuthority, F, t?.baseUri);
                    c.removeEventListener("message", R),
                    E(G)
                }
            });
            let O;
            const D = () => {
                d && d(),
                l = {
                    __type: "connecting",
                    associationKeypair: e
                },
                r === void 0 && (r = Date.now()),
                c = new WebSocket(n,[pk, W1]),
                c.addEventListener("open", _),
                c.addEventListener("close", x),
                c.addEventListener("error", b),
                c.addEventListener("message", R),
                d = () => {
                    window.clearTimeout(O),
                    c.removeEventListener("open", _),
                    c.removeEventListener("close", x),
                    c.removeEventListener("error", b),
                    c.removeEventListener("message", R)
                }
            }
            ;
            D()
        }
        );
        let m = !1, v;
        return {
            associationUrl: y,
            close: () => {
                c.close(),
                v()
            }
            ,
            wallet: new Promise( (E, A) => {
                const _ = {}
                  , x = b => $e(this, void 0, void 0, function*() {
                    const R = yield h(b);
                    switch (l.__type) {
                    case "reflector_id_received":
                        if (R.byteLength !== 0)
                            throw new Error("Encountered unexpected message while awaiting reflection");
                        const O = yield Nu()
                          , D = yield Tu(O.publicKey, e.privateKey);
                        a == "base64" ? c.send(Fp(D)) : c.send(D),
                        l = {
                            __type: "hello_req_sent",
                            associationPublicKey: e.publicKey,
                            ecdhPrivateKey: O.privateKey
                        };
                        break;
                    case "connected":
                        try {
                            const z = R.slice(0, Ei)
                              , K = qd(z);
                            if (K !== o + 1)
                                throw new Error("Encrypted message has invalid sequence number");
                            o = K;
                            const F = yield dk(R, l.sharedSecret)
                              , G = _[F.id];
                            delete _[F.id],
                            G.resolve(F.result)
                        } catch (z) {
                            if (z instanceof Hh) {
                                const K = _[z.jsonRpcMessageId];
                                delete _[z.jsonRpcMessageId],
                                K.reject(z)
                            } else
                                throw z
                        }
                        break;
                    case "hello_req_sent":
                        {
                            const z = yield hk(R, l.associationPublicKey, l.ecdhPrivateKey)
                              , K = R.slice(Sy)
                              , F = K.byteLength !== 0 ? yield( () => $e(this, void 0, void 0, function*() {
                                const Z = K.slice(0, Ei)
                                  , X = qd(Z);
                                if (X !== o + 1)
                                    throw new Error("Encrypted message has invalid sequence number");
                                return o = X,
                                fk(K, z)
                            }))() : {
                                protocol_version: "legacy"
                            };
                            l = {
                                __type: "connected",
                                sharedSecret: z,
                                sessionProperties: F
                            };
                            const G = nk(F.protocol_version, (Z, X) => $e(this, void 0, void 0, function*() {
                                const T = s++
                                  , u = yield uk({
                                    id: T,
                                    jsonrpc: "2.0",
                                    method: Z,
                                    params: X ?? {}
                                }, z);
                                return a == "base64" ? c.send(Fp(u)) : c.send(u),
                                new Promise( (p, k) => {
                                    _[T] = {
                                        resolve(C) {
                                            switch (Z) {
                                            case "authorize":
                                            case "reauthorize":
                                                {
                                                    const {wallet_uri_base: I} = C;
                                                    if (I != null)
                                                        try {
                                                            mk(I)
                                                        } catch (L) {
                                                            k(L);
                                                            return
                                                        }
                                                    break
                                                }
                                            }
                                            p(C)
                                        },
                                        reject: k
                                    }
                                }
                                )
                            }));
                            m = !0;
                            try {
                                E(G)
                            } catch (Z) {
                                A(Z)
                            }
                            break
                        }
                    }
                });
                c.addEventListener("message", x),
                v = () => {
                    c.removeEventListener("message", x),
                    d(),
                    m || A(new ar(or.ERROR_SESSION_CLOSED,"The wallet session was closed before connection.",{
                        closeEvent: new CloseEvent("socket was closed before connection")
                    }))
                }
            }
            )
        }
    })
}
const XC = Object.freeze(Object.defineProperty({
    __proto__: null,
    SolanaCloneAuthorization: $p,
    SolanaMobileWalletAdapterError: ar,
    SolanaMobileWalletAdapterErrorCode: or,
    SolanaMobileWalletAdapterProtocolError: Hh,
    SolanaMobileWalletAdapterProtocolErrorCode: MC,
    SolanaSignInWithSolana: LC,
    SolanaSignTransactions: tk,
    startRemoteScenario: JC,
    transact: QC
}, Symbol.toStringTag, {
    value: "Module"
}))
  , e6 = ms(XC)
  , t6 = ms(RN);
function n6(t) {
    if (t.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), n = 0; n < e.length; n++)
        e[n] = 255;
    for (var r = 0; r < t.length; r++) {
        var i = t.charAt(r)
          , s = i.charCodeAt(0);
        if (e[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        e[s] = r
    }
    var o = t.length
      , a = t.charAt(0)
      , l = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function d(m) {
        if (m instanceof Uint8Array || (ArrayBuffer.isView(m) ? m = new Uint8Array(m.buffer,m.byteOffset,m.byteLength) : Array.isArray(m) && (m = Uint8Array.from(m))),
        !(m instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (m.length === 0)
            return "";
        for (var v = 0, E = 0, A = 0, _ = m.length; A !== _ && m[A] === 0; )
            A++,
            v++;
        for (var x = (_ - A) * c + 1 >>> 0, b = new Uint8Array(x); A !== _; ) {
            for (var R = m[A], O = 0, D = x - 1; (R !== 0 || O < E) && D !== -1; D--,
            O++)
                R += 256 * b[D] >>> 0,
                b[D] = R % o >>> 0,
                R = R / o >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            E = O,
            A++
        }
        for (var z = x - E; z !== x && b[z] === 0; )
            z++;
        for (var K = a.repeat(v); z < x; ++z)
            K += t.charAt(b[z]);
        return K
    }
    function h(m) {
        if (typeof m != "string")
            throw new TypeError("Expected String");
        if (m.length === 0)
            return new Uint8Array;
        for (var v = 0, E = 0, A = 0; m[v] === a; )
            E++,
            v++;
        for (var _ = (m.length - v) * l + 1 >>> 0, x = new Uint8Array(_); m[v]; ) {
            var b = m.charCodeAt(v);
            if (b > 255)
                return;
            var R = e[b];
            if (R === 255)
                return;
            for (var O = 0, D = _ - 1; (R !== 0 || O < A) && D !== -1; D--,
            O++)
                R += o * x[D] >>> 0,
                x[D] = R % 256 >>> 0,
                R = R / 256 >>> 0;
            if (R !== 0)
                throw new Error("Non-zero carry");
            A = O,
            v++
        }
        for (var z = _ - A; z !== _ && x[z] === 0; )
            z++;
        for (var K = new Uint8Array(E + (_ - z)), F = E; z !== _; )
            K[F++] = x[z++];
        return K
    }
    function y(m) {
        var v = h(m);
        if (v)
            return v;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: y
    }
}
var r6 = n6;
const i6 = r6
  , s6 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var yk = i6(s6);
const H8 = ho(yk);
Object.defineProperty(oi, "__esModule", {
    value: !0
});
var Gt = Me
  , o6 = Cc
  , wk = e6
  , ga = t6
  , a6 = yk
  , F1 = Zr;
function vk(t) {
    return t && typeof t == "object" && "default"in t ? t : {
        default: t
    }
}
var l6 = vk(o6)
  , dc = vk(a6);
function _e(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
function W(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
function Te(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
var cl, Qt, Ms, jo, bk, _k, xk, Cu;
const c6 = `
<div class="mobile-wallet-adapter-embedded-modal-container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
    <div data-modal-close style="position: absolute; width: 100%; height: 100%;"></div>
	<div class="mobile-wallet-adapter-embedded-modal-card">
		<div>
			<button data-modal-close class="mobile-wallet-adapter-embedded-modal-close">
				<svg width="14" height="14">
					<path d="M 6.7125,8.3036995 1.9082,13.108199 c -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 C 0.1056,12.896899 0,12.631699 0,12.312499 c 0,-0.3192 0.1056,-0.5844 0.3167,-0.7958 L 5.1212,6.7124995 0.3167,1.9082 C 0.1056,1.6969 0,1.4317 0,1.1125 0,0.7933 0.1056,0.5281 0.3167,0.3167 0.5281,0.1056 0.7933,0 1.1125,0 1.4317,0 1.6969,0.1056 1.9082,0.3167 L 6.7125,5.1212 11.5167,0.3167 C 11.7281,0.1056 11.9933,0 12.3125,0 c 0.3192,0 0.5844,0.1056 0.7957,0.3167 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 L 8.3037001,6.7124995 13.1082,11.516699 c 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 z" />
				</svg>
			</button>
		</div>
		<div class="mobile-wallet-adapter-embedded-modal-content"></div>
	</div>
</div>
`
  , u6 = `
.mobile-wallet-adapter-embedded-modal-container {
    display: flex; /* Use flexbox to center content */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    overflow-y: auto; /* enable scrolling */
}

.mobile-wallet-adapter-embedded-modal-card {
    display: flex;
    flex-direction: column;
    margin: auto 20px;
    max-width: 780px;
    padding: 20px;
    border-radius: 24px;
    background: #ffffff;
    font-family: "Inter Tight", "PT Sans", Calibri, sans-serif;
    transform: translateY(-200%);
    animation: slide-in 0.5s forwards;
}

@keyframes slide-in {
    100% { transform: translateY(0%); }
}

.mobile-wallet-adapter-embedded-modal-close {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    cursor: pointer;
    background: #e4e9e9;
    border: none;
    border-radius: 50%;
}

.mobile-wallet-adapter-embedded-modal-close:focus-visible {
    outline-color: red;
}

.mobile-wallet-adapter-embedded-modal-close svg {
    fill: #546266;
    transition: fill 200ms ease 0s;
}

.mobile-wallet-adapter-embedded-modal-close:hover svg {
    fill: #fff;
}
`
  , d6 = `
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter+Tight:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
`;
class Sk {
    constructor() {
        cl.add(this),
        Qt.set(this, null),
        Ms.set(this, {}),
        jo.set(this, !1),
        this.dom = null,
        this.open = () => {
            console.debug("Modal open"),
            W(this, cl, "m", _k).call(this),
            W(this, Qt, "f") && (W(this, Qt, "f").style.display = "flex")
        }
        ,
        this.close = (e=void 0) => {
            var n;
            console.debug("Modal close"),
            W(this, cl, "m", xk).call(this),
            W(this, Qt, "f") && (W(this, Qt, "f").style.display = "none"),
            (n = W(this, Ms, "f").close) === null || n === void 0 || n.forEach(r => r(e))
        }
        ,
        Cu.set(this, e => {
            e.key === "Escape" && this.close(e)
        }
        ),
        this.init = this.init.bind(this),
        Te(this, Qt, document.getElementById("mobile-wallet-adapter-embedded-root-ui"), "f")
    }
    init() {
        return _e(this, void 0, void 0, function*() {
            console.log("Injecting modal"),
            W(this, cl, "m", bk).call(this)
        })
    }
    addEventListener(e, n) {
        var r;
        return !((r = W(this, Ms, "f")[e]) === null || r === void 0) && r.push(n) || (W(this, Ms, "f")[e] = [n]),
        () => this.removeEventListener(e, n)
    }
    removeEventListener(e, n) {
        var r;
        W(this, Ms, "f")[e] = (r = W(this, Ms, "f")[e]) === null || r === void 0 ? void 0 : r.filter(i => n !== i)
    }
}
Qt = new WeakMap,
Ms = new WeakMap,
jo = new WeakMap,
Cu = new WeakMap,
cl = new WeakSet,
bk = function() {
    if (document.getElementById("mobile-wallet-adapter-embedded-root-ui")) {
        W(this, Qt, "f") || Te(this, Qt, document.getElementById("mobile-wallet-adapter-embedded-root-ui"), "f");
        return
    }
    Te(this, Qt, document.createElement("div"), "f"),
    W(this, Qt, "f").id = "mobile-wallet-adapter-embedded-root-ui",
    W(this, Qt, "f").innerHTML = c6,
    W(this, Qt, "f").style.display = "none";
    const e = W(this, Qt, "f").querySelector(".mobile-wallet-adapter-embedded-modal-content");
    e && (e.innerHTML = this.contentHtml);
    const n = document.createElement("style");
    n.id = "mobile-wallet-adapter-embedded-modal-styles",
    n.textContent = u6 + this.contentStyles;
    const r = document.createElement("div");
    r.innerHTML = d6,
    this.dom = r.attachShadow({
        mode: "closed"
    }),
    this.dom.appendChild(n),
    this.dom.appendChild(W(this, Qt, "f")),
    document.body.appendChild(r)
}
,
_k = function() {
    if (!W(this, Qt, "f") || W(this, jo, "f"))
        return;
    [...W(this, Qt, "f").querySelectorAll("[data-modal-close]")].forEach(n => n?.addEventListener("click", this.close)),
    window.addEventListener("load", this.close),
    document.addEventListener("keydown", W(this, Cu, "f")),
    Te(this, jo, !0, "f")
}
,
xk = function() {
    if (!W(this, jo, "f") || (window.removeEventListener("load", this.close),
    document.removeEventListener("keydown", W(this, Cu, "f")),
    !W(this, Qt, "f")))
        return;
    [...W(this, Qt, "f").querySelectorAll("[data-modal-close]")].forEach(n => n?.removeEventListener("click", this.close)),
    Te(this, jo, !1, "f")
}
;
class h6 extends Sk {
    constructor() {
        super(...arguments),
        this.contentStyles = p6,
        this.contentHtml = f6
    }
    initWithQR(e) {
        const n = Object.create(null, {
            init: {
                get: () => super.init
            }
        });
        return _e(this, void 0, void 0, function*() {
            n.init.call(this),
            this.populateQRCode(e)
        })
    }
    populateQRCode(e) {
        var n;
        return _e(this, void 0, void 0, function*() {
            const r = (n = this.dom) === null || n === void 0 ? void 0 : n.getElementById("mobile-wallet-adapter-embedded-modal-qr-code-container");
            if (r) {
                const i = yield l6.default.toCanvas(e, {
                    width: 200,
                    margin: 0
                });
                r.firstElementChild !== null ? r.replaceChild(i, r.firstElementChild) : r.appendChild(i)
            } else
                console.error("QRCode Container not found")
        })
    }
}
const f6 = `
<div class="mobile-wallet-adapter-embedded-modal-qr-content">
    <div>
        <svg class="mobile-wallet-adapter-embedded-modal-icon" width="100%" height="100%">
            <circle r="52" cx="53" cy="53" fill="#99b3be" stroke="#000000" stroke-width="2"/>
            <path d="m 53,82.7305 c -3.3116,0 -6.1361,-1.169 -8.4735,-3.507 -2.338,-2.338 -3.507,-5.1625 -3.507,-8.4735 0,-3.3116 1.169,-6.1364 3.507,-8.4744 2.3374,-2.338 5.1619,-3.507 8.4735,-3.507 3.3116,0 6.1361,1.169 8.4735,3.507 2.338,2.338 3.507,5.1628 3.507,8.4744 0,3.311 -1.169,6.1355 -3.507,8.4735 -2.3374,2.338 -5.1619,3.507 -8.4735,3.507 z m 0.007,-5.25 c 1.8532,0 3.437,-0.6598 4.7512,-1.9793 1.3149,-1.3195 1.9723,-2.9058 1.9723,-4.7591 0,-1.8526 -0.6598,-3.4364 -1.9793,-4.7512 -1.3195,-1.3149 -2.9055,-1.9723 -4.7582,-1.9723 -1.8533,0 -3.437,0.6598 -4.7513,1.9793 -1.3148,1.3195 -1.9722,2.9058 -1.9722,4.7591 0,1.8527 0.6597,3.4364 1.9792,4.7512 1.3195,1.3149 2.9056,1.9723 4.7583,1.9723 z m -28,-33.5729 -3.85,-3.6347 c 4.1195,-4.025 8.8792,-7.1984 14.2791,-9.52 5.4005,-2.3223 11.2551,-3.4834 17.5639,-3.4834 6.3087,0 12.1634,1.1611 17.5639,3.4834 5.3999,2.3216 10.1596,5.495 14.2791,9.52 l -3.85,3.6347 C 77.2999,40.358 73.0684,37.5726 68.2985,35.5514 63.5292,33.5301 58.4296,32.5195 53,32.5195 c -5.4297,0 -10.5292,1.0106 -15.2985,3.0319 -4.7699,2.0212 -9.0014,4.8066 -12.6945,8.3562 z m 44.625,10.8771 c -2.2709,-2.1046 -4.7962,-3.7167 -7.5758,-4.8361 -2.7795,-1.12 -5.7983,-1.68 -9.0562,-1.68 -3.2579,0 -6.2621,0.56 -9.0125,1.68 -2.7504,1.1194 -5.2903,2.7315 -7.6195,4.8361 L 32.5189,51.15 c 2.8355,-2.6028 5.9777,-4.6086 9.4263,-6.0174 3.4481,-1.4087 7.133,-2.1131 11.0548,-2.1131 3.9217,0 7.5979,0.7044 11.0285,2.1131 3.43,1.4088 6.5631,3.4146 9.3992,6.0174 z"/>
        </svg>
        <div class="mobile-wallet-adapter-embedded-modal-title">Remote Mobile Wallet Adapter</div>
    </div>
    <div>
        <div>
            <h4 class="mobile-wallet-adapter-embedded-modal-qr-label">
                Open your wallet and scan this code
            </h4>
        </div>
        <div id="mobile-wallet-adapter-embedded-modal-qr-code-container" class="mobile-wallet-adapter-embedded-modal-qr-code-container"></div>
    </div>
</div>
<div class="mobile-wallet-adapter-embedded-modal-divider"><hr></div>
<div class="mobile-wallet-adapter-embedded-modal-footer">
    <div class="mobile-wallet-adapter-embedded-modal-subtitle">
        Follow the instructions on your device. When you're finished, this screen will update.
    </div>
    <div class="mobile-wallet-adapter-embedded-modal-progress-badge">
        <div>
            <div class="spinner">
                <div class="leftWrapper">
                    <div class="left">
                        <div class="circle"></div>
                    </div>
                </div>
                <div class="rightWrapper">
                    <div class="right">
                        <div class="circle"></div>
                    </div>
                </div>
            </div>
        </div>
        <div>Waiting for scan</div>
    </div>
</div>
`
  , p6 = `
.mobile-wallet-adapter-embedded-modal-qr-content {
    display: flex; 
    margin-top: 10px;
    padding: 10px;
}

.mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {
    display: flex;
    flex-direction: column;
    flex: 2;
    margin-top: auto;
    margin-right: 30px;
}

.mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {
    display: flex;
    flex-direction: column;
    flex: 1;
    margin-left: auto;
}

.mobile-wallet-adapter-embedded-modal-footer {
    display: flex;
    padding: 10px;
}

.mobile-wallet-adapter-embedded-modal-icon {}

.mobile-wallet-adapter-embedded-modal-title {
    color: #000000;
    font-size: 2.5em;
    font-weight: 600;
}

.mobile-wallet-adapter-embedded-modal-qr-label {
    text-align: right;
    color: #000000;
}

.mobile-wallet-adapter-embedded-modal-qr-code-container {
    margin-left: auto;
}

.mobile-wallet-adapter-embedded-modal-divider {
    margin-top: 20px;
    padding-left: 10px;
    padding-right: 10px;
}

.mobile-wallet-adapter-embedded-modal-divider hr {
    border-top: 1px solid #D9DEDE;
}

.mobile-wallet-adapter-embedded-modal-subtitle {
    margin: auto;
    margin-right: 60px;
    padding: 20px;
    color: #6E8286;
}

.mobile-wallet-adapter-embedded-modal-progress-badge {
    display: flex;
    background: #F7F8F8;
    height: 56px;
    min-width: 200px;
    margin: auto;
    padding-left: 20px;
    padding-right: 20px;
    border-radius: 18px;
    color: #A8B6B8;
    align-items: center;
}

.mobile-wallet-adapter-embedded-modal-progress-badge > div:first-child {
    margin-left: auto;
    margin-right: 20px;
}

.mobile-wallet-adapter-embedded-modal-progress-badge > div:nth-child(2) {
    margin-right: auto;
}

/* Smaller screens */
@media all and (max-width: 600px) {
    .mobile-wallet-adapter-embedded-modal-card {
        text-align: center;
    }
    .mobile-wallet-adapter-embedded-modal-qr-content {
        flex-direction: column;
    }
    .mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {
        margin: auto;
    }
    .mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {
        margin: auto;
        flex: 2 auto;
    }
    .mobile-wallet-adapter-embedded-modal-footer {
        flex-direction: column;
    }
    .mobile-wallet-adapter-embedded-modal-icon {
        display: none;
    }
    .mobile-wallet-adapter-embedded-modal-title {
        font-size: 1.5em;
    }
    .mobile-wallet-adapter-embedded-modal-subtitle {
        margin-right: unset;
    }
    .mobile-wallet-adapter-embedded-modal-qr-label {
        text-align: center;
    }
    .mobile-wallet-adapter-embedded-modal-qr-code-container {
        margin: auto;
    }
}

/* Spinner */
@keyframes spinLeft {
    0% {
        transform: rotate(20deg);
    }
    50% {
        transform: rotate(160deg);
    }
    100% {
        transform: rotate(20deg);
    }
}
@keyframes spinRight {
    0% {
        transform: rotate(160deg);
    }
    50% {
        transform: rotate(20deg);
    }
    100% {
        transform: rotate(160deg);
    }
}
@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(2520deg);
    }
}

.spinner {
    position: relative;
    width: 1.5em;
    height: 1.5em;
    margin: auto;
    animation: spin 10s linear infinite;
}
.spinner::before {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
}
.right, .rightWrapper, .left, .leftWrapper {
    position: absolute;
    top: 0;
    overflow: hidden;
    width: .75em;
    height: 1.5em;
}
.left, .leftWrapper {
    left: 0;
}
.right {
    left: -12px;
}
.rightWrapper {
    right: 0;
}
.circle {
    border: .125em solid #A8B6B8;
    width: 1.25em; /* 1.5em - 2*0.125em border */
    height: 1.25em; /* 1.5em - 2*0.125em border */
    border-radius: 0.75em; /* 0.5*1.5em spinner size 8 */
}
.left {
    transform-origin: 100% 50%;
    animation: spinLeft 2.5s cubic-bezier(.2,0,.8,1) infinite;
}
.right {
    transform-origin: 100% 50%;
    animation: spinRight 2.5s cubic-bezier(.2,0,.8,1) infinite;
}
`
  , kk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDIuNUgxN0MxNy44Mjg0IDIuNSAxOC41IDMuMTcxNTcgMTguNSA0VjIwQzE4LjUgMjAuODI4NCAxNy44Mjg0IDIxLjUgMTcgMjEuNUg3QzYuMTcxNTcgMjEuNSA1LjUgMjAuODI4NCA1LjUgMjBWNEM1LjUgMy4xNzE1NyA2LjE3MTU3IDIuNSA3IDIuNVpNMyA0QzMgMS43OTA4NiA0Ljc5MDg2IDAgNyAwSDE3QzE5LjIwOTEgMCAyMSAxLjc5MDg2IDIxIDRWMjBDMjEgMjIuMjA5MSAxOS4yMDkxIDI0IDE3IDI0SDdDNC43OTA4NiAyNCAzIDIyLjIwOTEgMyAyMFY0Wk0xMSA0LjYxNTM4QzEwLjQ0NzcgNC42MTUzOCAxMCA1LjA2MzEgMTAgNS42MTUzOFY2LjM4NDYyQzEwIDYuOTM2OSAxMC40NDc3IDcuMzg0NjIgMTEgNy4zODQ2MkgxM0MxMy41NTIzIDcuMzg0NjIgMTQgNi45MzY5IDE0IDYuMzg0NjJWNS42MTUzOEMxNCA1LjA2MzEgMTMuNTUyMyA0LjYxNTM4IDEzIDQuNjE1MzhIMTFaIiBmaWxsPSIjRENCOEZGIi8+Cjwvc3ZnPgo=";
function ns(t) {
    return window.btoa(String.fromCharCode.call(null, ...t))
}
function Nn(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}
var Bo, qs, Vp, Hp, qp, Gp, ul, In, di, Ui, Po, Ts, Ru, dl, Lu, Yp, ju, Ek, Zp, Bu, Oo, Pu, hl, Ou, Do, fl, Du, Qp, Jp, zu, Uu, Xp, eg, Wu, zo, Gs, tg, ng, rg, ig, pl, Mn, Wi, Fi, Uo, Ns, Fu, gl, $u, Ku, Er, sg, Vu, Ak, og, Hu, ml, ag, yl, qu, Wo, wl, Gu, lg, cg, Yu, Zu, ug, dg, Qu;
const ky = "Mobile Wallet Adapter"
  , Ik = 64
  , Mk = [Gt.SolanaSignAndSendTransaction, Gt.SolanaSignTransaction, Gt.SolanaSignMessage, Gt.SolanaSignIn];
class Tk {
    constructor(e) {
        Bo.add(this),
        qs.set(this, {}),
        Vp.set(this, "1.0.0"),
        Hp.set(this, ky),
        qp.set(this, "https://solanamobile.com/wallets"),
        Gp.set(this, kk),
        ul.set(this, void 0),
        In.set(this, void 0),
        di.set(this, void 0),
        Ui.set(this, !1),
        Po.set(this, 0),
        Ts.set(this, []),
        Ru.set(this, void 0),
        dl.set(this, void 0),
        Lu.set(this, void 0),
        Yp.set(this, (n, r) => {
            var i;
            return !((i = W(this, qs, "f")[n]) === null || i === void 0) && i.push(r) || (W(this, qs, "f")[n] = [r]),
            () => W(this, Bo, "m", Ek).call(this, n, r)
        }
        ),
        Zp.set(this, ({silent: n}={}) => _e(this, void 0, void 0, function*() {
            if (W(this, Ui, "f") || this.connected)
                return {
                    accounts: this.accounts
                };
            Te(this, Ui, !0, "f");
            try {
                if (n) {
                    const r = yield W(this, di, "f").get();
                    if (r)
                        yield W(this, Pu, "f").call(this, r.capabilities),
                        yield W(this, Oo, "f").call(this, r);
                    else
                        return {
                            accounts: this.accounts
                        }
                } else
                    yield W(this, Bu, "f").call(this)
            } catch (r) {
                throw new Error(r instanceof Error && r.message || "Unknown error")
            } finally {
                Te(this, Ui, !1, "f")
            }
            return {
                accounts: this.accounts
            }
        })),
        Bu.set(this, n => _e(this, void 0, void 0, function*() {
            try {
                const r = yield W(this, di, "f").get();
                if (r)
                    return W(this, Oo, "f").call(this, r),
                    r;
                const i = yield W(this, Ru, "f").select(W(this, Ts, "f"));
                return yield W(this, Do, "f").call(this, s => _e(this, void 0, void 0, function*() {
                    const [o,a] = yield Promise.all([s.getCapabilities(), s.authorize({
                        chain: i,
                        identity: W(this, ul, "f"),
                        sign_in_payload: n
                    })])
                      , l = W(this, Du, "f").call(this, a.accounts)
                      , c = Object.assign(Object.assign({}, a), {
                        accounts: l,
                        chain: i,
                        capabilities: o
                    });
                    return Promise.all([W(this, Pu, "f").call(this, o), W(this, di, "f").set(c), W(this, Oo, "f").call(this, c)]),
                    c
                }))
            } catch (r) {
                throw new Error(r instanceof Error && r.message || "Unknown error")
            }
        })),
        Oo.set(this, n => _e(this, void 0, void 0, function*() {
            var r;
            const i = W(this, In, "f") == null || ((r = W(this, In, "f")) === null || r === void 0 ? void 0 : r.accounts.length) !== n.accounts.length || W(this, In, "f").accounts.some( (s, o) => s.address !== n.accounts[o].address);
            Te(this, In, n, "f"),
            i && W(this, Bo, "m", ju).call(this, "change", {
                accounts: this.accounts
            })
        })),
        Pu.set(this, n => _e(this, void 0, void 0, function*() {
            const r = n.features.includes("solana:signTransactions")
              , i = n.supports_sign_and_send_transactions
              , s = Gt.SolanaSignAndSendTransaction in this.features !== i || Gt.SolanaSignTransaction in this.features !== r;
            Te(this, dl, Object.assign(Object.assign({}, (i || !i && !r) && {
                [Gt.SolanaSignAndSendTransaction]: {
                    version: "1.0.0",
                    supportedTransactionVersions: ["legacy", 0],
                    signAndSendTransaction: W(this, zu, "f")
                }
            }), r && {
                [Gt.SolanaSignTransaction]: {
                    version: "1.0.0",
                    supportedTransactionVersions: ["legacy", 0],
                    signTransaction: W(this, Uu, "f")
                }
            }), "f"),
            s && W(this, Bo, "m", ju).call(this, "change", {
                features: this.features
            })
        })),
        hl.set(this, (n, r, i) => _e(this, void 0, void 0, function*() {
            var s, o;
            try {
                const [a,l] = yield Promise.all([(o = (s = W(this, In, "f")) === null || s === void 0 ? void 0 : s.capabilities) !== null && o !== void 0 ? o : yield n.getCapabilities(), n.authorize({
                    auth_token: r,
                    identity: W(this, ul, "f"),
                    chain: i
                })])
                  , c = W(this, Du, "f").call(this, l.accounts)
                  , d = Object.assign(Object.assign({}, l), {
                    accounts: c,
                    chain: i,
                    capabilities: a
                });
                Promise.all([W(this, di, "f").set(d), W(this, Oo, "f").call(this, d)])
            } catch (a) {
                throw W(this, Ou, "f").call(this),
                new Error(a instanceof Error && a.message || "Unknown error")
            }
        })),
        Ou.set(this, () => _e(this, void 0, void 0, function*() {
            var n;
            W(this, di, "f").clear(),
            Te(this, Ui, !1, "f"),
            Te(this, Po, (n = W(this, Po, "f"),
            n++,
            n), "f"),
            Te(this, In, void 0, "f"),
            W(this, Bo, "m", ju).call(this, "change", {
                accounts: this.accounts
            })
        })),
        Do.set(this, n => _e(this, void 0, void 0, function*() {
            var r;
            const i = (r = W(this, In, "f")) === null || r === void 0 ? void 0 : r.wallet_uri_base
              , s = i ? {
                baseUri: i
            } : void 0
              , o = W(this, Po, "f");
            try {
                return yield wk.transact(n, s)
            } catch (a) {
                throw W(this, Po, "f") !== o && (yield new Promise( () => {}
                )),
                a instanceof Error && a.name === "SolanaMobileWalletAdapterError" && a.code === "ERROR_WALLET_NOT_FOUND" && (yield W(this, Lu, "f").call(this, this)),
                a
            }
        })),
        fl.set(this, () => {
            if (!W(this, In, "f"))
                throw new Error("Wallet not connected");
            return {
                authToken: W(this, In, "f").auth_token,
                chain: W(this, In, "f").chain
            }
        }
        ),
        Du.set(this, n => n.map(r => {
            var i, s;
            const o = Nn(r.address);
            return {
                address: dc.default.encode(o),
                publicKey: o,
                label: r.label,
                icon: r.icon,
                chains: (i = r.chains) !== null && i !== void 0 ? i : W(this, Ts, "f"),
                features: (s = r.features) !== null && s !== void 0 ? s : Mk
            }
        }
        )),
        Qp.set(this, n => _e(this, void 0, void 0, function*() {
            const {authToken: r, chain: i} = W(this, fl, "f").call(this);
            try {
                const s = n.map(o => ns(o));
                return yield W(this, Do, "f").call(this, o => _e(this, void 0, void 0, function*() {
                    return yield W(this, hl, "f").call(this, o, r, i),
                    (yield o.signTransactions({
                        payloads: s
                    })).signed_payloads.map(Nn)
                }))
            } catch (s) {
                throw new Error(s instanceof Error && s.message || "Unknown error")
            }
        })),
        Jp.set(this, (n, r) => _e(this, void 0, void 0, function*() {
            const {authToken: i, chain: s} = W(this, fl, "f").call(this);
            try {
                return yield W(this, Do, "f").call(this, o => _e(this, void 0, void 0, function*() {
                    const [a,l] = yield Promise.all([o.getCapabilities(), W(this, hl, "f").call(this, o, i, s)]);
                    if (a.supports_sign_and_send_transactions) {
                        const c = ns(n);
                        return (yield o.signAndSendTransactions(Object.assign(Object.assign({}, r), {
                            payloads: [c]
                        }))).signatures.map(Nn)[0]
                    } else
                        throw new Error("connected wallet does not support signAndSendTransaction")
                }))
            } catch (o) {
                throw new Error(o instanceof Error && o.message || "Unknown error")
            }
        })),
        zu.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const r = [];
            for (const i of n) {
                const s = yield W(this, Jp, "f").call(this, i.transaction, i.options);
                r.push({
                    signature: s
                })
            }
            return r
        })),
        Uu.set(this, (...n) => _e(this, void 0, void 0, function*() {
            return (yield W(this, Qp, "f").call(this, n.map( ({transaction: r}) => r))).map(r => ({
                signedTransaction: r
            }))
        })),
        Xp.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const {authToken: r, chain: i} = W(this, fl, "f").call(this)
              , s = n.map( ({account: a}) => ns(a.publicKey))
              , o = n.map( ({message: a}) => ns(a));
            try {
                return yield W(this, Do, "f").call(this, a => _e(this, void 0, void 0, function*() {
                    return yield W(this, hl, "f").call(this, a, r, i),
                    (yield a.signMessages({
                        addresses: s,
                        payloads: o
                    })).signed_payloads.map(Nn).map(c => ({
                        signedMessage: c,
                        signature: c.slice(-Ik)
                    }))
                }))
            } catch (a) {
                throw new Error(a instanceof Error && a.message || "Unknown error")
            }
        })),
        eg.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const r = [];
            if (n.length > 1)
                for (const i of n)
                    r.push(yield W(this, Wu, "f").call(this, i));
            else
                return [yield W(this, Wu, "f").call(this, n[0])];
            return r
        })),
        Wu.set(this, n => _e(this, void 0, void 0, function*() {
            var r, i, s;
            Te(this, Ui, !0, "f");
            try {
                const o = yield W(this, Bu, "f").call(this, Object.assign(Object.assign({}, n), {
                    domain: (r = n?.domain) !== null && r !== void 0 ? r : window.location.host
                }));
                if (!o.sign_in_result)
                    throw new Error("Sign in failed, no sign in result returned by wallet");
                const a = o.sign_in_result.address
                  , l = o.accounts.find(c => c.address == a);
                return {
                    account: Object.assign(Object.assign({}, l ?? {
                        address: dc.default.encode(Nn(a))
                    }), {
                        publicKey: Nn(a),
                        chains: (i = l?.chains) !== null && i !== void 0 ? i : W(this, Ts, "f"),
                        features: (s = l?.features) !== null && s !== void 0 ? s : o.capabilities.features
                    }),
                    signedMessage: Nn(o.sign_in_result.signed_message),
                    signature: Nn(o.sign_in_result.signature)
                }
            } catch (o) {
                throw new Error(o instanceof Error && o.message || "Unknown error")
            } finally {
                Te(this, Ui, !1, "f")
            }
        })),
        Te(this, di, e.authorizationCache, "f"),
        Te(this, ul, e.appIdentity, "f"),
        Te(this, Ts, e.chains, "f"),
        Te(this, Ru, e.chainSelector, "f"),
        Te(this, Lu, e.onWalletNotFound, "f"),
        Te(this, dl, {
            [Gt.SolanaSignAndSendTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: W(this, zu, "f")
            },
            [Gt.SolanaSignTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: W(this, Uu, "f")
            }
        }, "f")
    }
    get version() {
        return W(this, Vp, "f")
    }
    get name() {
        return W(this, Hp, "f")
    }
    get url() {
        return W(this, qp, "f")
    }
    get icon() {
        return W(this, Gp, "f")
    }
    get chains() {
        return W(this, Ts, "f")
    }
    get features() {
        return Object.assign({
            [ga.StandardConnect]: {
                version: "1.0.0",
                connect: W(this, Zp, "f")
            },
            [ga.StandardDisconnect]: {
                version: "1.0.0",
                disconnect: W(this, Ou, "f")
            },
            [ga.StandardEvents]: {
                version: "1.0.0",
                on: W(this, Yp, "f")
            },
            [Gt.SolanaSignMessage]: {
                version: "1.0.0",
                signMessage: W(this, Xp, "f")
            },
            [Gt.SolanaSignIn]: {
                version: "1.0.0",
                signIn: W(this, eg, "f")
            }
        }, W(this, dl, "f"))
    }
    get accounts() {
        var e, n;
        return (n = (e = W(this, In, "f")) === null || e === void 0 ? void 0 : e.accounts) !== null && n !== void 0 ? n : []
    }
    get connected() {
        return !!W(this, In, "f")
    }
    get isAuthorized() {
        return !!W(this, In, "f")
    }
    get currentAuthorization() {
        return W(this, In, "f")
    }
    get cachedAuthorizationResult() {
        return W(this, di, "f").get()
    }
}
qs = new WeakMap,
Vp = new WeakMap,
Hp = new WeakMap,
qp = new WeakMap,
Gp = new WeakMap,
ul = new WeakMap,
In = new WeakMap,
di = new WeakMap,
Ui = new WeakMap,
Po = new WeakMap,
Ts = new WeakMap,
Ru = new WeakMap,
dl = new WeakMap,
Lu = new WeakMap,
Yp = new WeakMap,
Zp = new WeakMap,
Bu = new WeakMap,
Oo = new WeakMap,
Pu = new WeakMap,
hl = new WeakMap,
Ou = new WeakMap,
Do = new WeakMap,
fl = new WeakMap,
Du = new WeakMap,
Qp = new WeakMap,
Jp = new WeakMap,
zu = new WeakMap,
Uu = new WeakMap,
Xp = new WeakMap,
eg = new WeakMap,
Wu = new WeakMap,
Bo = new WeakSet,
ju = function(e, ...n) {
    var r;
    (r = W(this, qs, "f")[e]) === null || r === void 0 || r.forEach(i => i.apply(null, n))
}
,
Ek = function(e, n) {
    var r;
    W(this, qs, "f")[e] = (r = W(this, qs, "f")[e]) === null || r === void 0 ? void 0 : r.filter(i => n !== i)
}
;
class Nk {
    constructor(e) {
        zo.add(this),
        Gs.set(this, {}),
        tg.set(this, "1.0.0"),
        ng.set(this, ky),
        rg.set(this, "https://solanamobile.com/wallets"),
        ig.set(this, kk),
        pl.set(this, void 0),
        Mn.set(this, void 0),
        Wi.set(this, void 0),
        Fi.set(this, !1),
        Uo.set(this, 0),
        Ns.set(this, []),
        Fu.set(this, void 0),
        gl.set(this, void 0),
        $u.set(this, void 0),
        Ku.set(this, void 0),
        Er.set(this, void 0),
        sg.set(this, (n, r) => {
            var i;
            return !((i = W(this, Gs, "f")[n]) === null || i === void 0) && i.push(r) || (W(this, Gs, "f")[n] = [r]),
            () => W(this, zo, "m", Ak).call(this, n, r)
        }
        ),
        og.set(this, ({silent: n}={}) => _e(this, void 0, void 0, function*() {
            if (W(this, Fi, "f") || this.connected)
                return {
                    accounts: this.accounts
                };
            Te(this, Fi, !0, "f");
            try {
                yield W(this, Hu, "f").call(this)
            } catch (r) {
                throw new Error(r instanceof Error && r.message || "Unknown error")
            } finally {
                Te(this, Fi, !1, "f")
            }
            return {
                accounts: this.accounts
            }
        })),
        Hu.set(this, n => _e(this, void 0, void 0, function*() {
            try {
                const r = yield W(this, Wi, "f").get();
                if (r)
                    return W(this, ml, "f").call(this, r),
                    r;
                W(this, Er, "f") && Te(this, Er, void 0, "f");
                const i = yield W(this, Fu, "f").select(W(this, Ns, "f"));
                return yield W(this, Wo, "f").call(this, s => _e(this, void 0, void 0, function*() {
                    const [o,a] = yield Promise.all([s.getCapabilities(), s.authorize({
                        chain: i,
                        identity: W(this, pl, "f"),
                        sign_in_payload: n
                    })])
                      , l = W(this, Gu, "f").call(this, a.accounts)
                      , c = Object.assign(Object.assign({}, a), {
                        accounts: l,
                        chain: i,
                        capabilities: o
                    });
                    return Promise.all([W(this, ag, "f").call(this, o), W(this, Wi, "f").set(c), W(this, ml, "f").call(this, c)]),
                    c
                }))
            } catch (r) {
                throw new Error(r instanceof Error && r.message || "Unknown error")
            }
        })),
        ml.set(this, n => _e(this, void 0, void 0, function*() {
            var r;
            const i = W(this, Mn, "f") == null || ((r = W(this, Mn, "f")) === null || r === void 0 ? void 0 : r.accounts.length) !== n.accounts.length || W(this, Mn, "f").accounts.some( (s, o) => s.address !== n.accounts[o].address);
            Te(this, Mn, n, "f"),
            i && W(this, zo, "m", Vu).call(this, "change", {
                accounts: this.accounts
            })
        })),
        ag.set(this, n => _e(this, void 0, void 0, function*() {
            const r = n.features.includes("solana:signTransactions")
              , i = n.supports_sign_and_send_transactions || n.features.includes("solana:signAndSendTransaction")
              , s = Gt.SolanaSignAndSendTransaction in this.features !== i || Gt.SolanaSignTransaction in this.features !== r;
            Te(this, gl, Object.assign(Object.assign({}, i && {
                [Gt.SolanaSignAndSendTransaction]: {
                    version: "1.0.0",
                    supportedTransactionVersions: n.supported_transaction_versions,
                    signAndSendTransaction: W(this, Yu, "f")
                }
            }), r && {
                [Gt.SolanaSignTransaction]: {
                    version: "1.0.0",
                    supportedTransactionVersions: n.supported_transaction_versions,
                    signTransaction: W(this, Zu, "f")
                }
            }), "f"),
            s && W(this, zo, "m", Vu).call(this, "change", {
                features: this.features
            })
        })),
        yl.set(this, (n, r, i) => _e(this, void 0, void 0, function*() {
            var s, o;
            try {
                const [a,l] = yield Promise.all([(o = (s = W(this, Mn, "f")) === null || s === void 0 ? void 0 : s.capabilities) !== null && o !== void 0 ? o : yield n.getCapabilities(), n.authorize({
                    auth_token: r,
                    identity: W(this, pl, "f"),
                    chain: i
                })])
                  , c = W(this, Gu, "f").call(this, l.accounts)
                  , d = Object.assign(Object.assign({}, l), {
                    accounts: c,
                    chain: i,
                    capabilities: a
                });
                Promise.all([W(this, Wi, "f").set(d), W(this, ml, "f").call(this, d)])
            } catch (a) {
                throw W(this, qu, "f").call(this),
                new Error(a instanceof Error && a.message || "Unknown error")
            }
        })),
        qu.set(this, () => _e(this, void 0, void 0, function*() {
            var n, r;
            (n = W(this, Er, "f")) === null || n === void 0 || n.close(),
            W(this, Wi, "f").clear(),
            Te(this, Fi, !1, "f"),
            Te(this, Uo, (r = W(this, Uo, "f"),
            r++,
            r), "f"),
            Te(this, Mn, void 0, "f"),
            Te(this, Er, void 0, "f"),
            W(this, zo, "m", Vu).call(this, "change", {
                accounts: this.accounts
            })
        })),
        Wo.set(this, n => _e(this, void 0, void 0, function*() {
            var r;
            const i = (r = W(this, Mn, "f")) === null || r === void 0 ? void 0 : r.wallet_uri_base
              , o = Object.assign(Object.assign({}, i ? {
                baseUri: i
            } : void 0), {
                remoteHostAuthority: W(this, Ku, "f")
            })
              , a = W(this, Uo, "f")
              , l = new h6;
            if (W(this, Er, "f"))
                return n(W(this, Er, "f").wallet);
            try {
                const {associationUrl: c, close: d, wallet: h} = yield wk.startRemoteScenario(o)
                  , y = l.addEventListener("close", m => {
                    m && d()
                }
                );
                return l.initWithQR(c.toString()),
                l.open(),
                Te(this, Er, {
                    close: d,
                    wallet: yield h
                }, "f"),
                y(),
                l.close(),
                yield n(W(this, Er, "f").wallet)
            } catch (c) {
                throw l.close(),
                W(this, Uo, "f") !== a && (yield new Promise( () => {}
                )),
                c instanceof Error && c.name === "SolanaMobileWalletAdapterError" && c.code === "ERROR_WALLET_NOT_FOUND" && (yield W(this, $u, "f").call(this, this)),
                c
            }
        })),
        wl.set(this, () => {
            if (!W(this, Mn, "f"))
                throw new Error("Wallet not connected");
            return {
                authToken: W(this, Mn, "f").auth_token,
                chain: W(this, Mn, "f").chain
            }
        }
        ),
        Gu.set(this, n => n.map(r => {
            var i, s;
            const o = Nn(r.address);
            return {
                address: dc.default.encode(o),
                publicKey: o,
                label: r.label,
                icon: r.icon,
                chains: (i = r.chains) !== null && i !== void 0 ? i : W(this, Ns, "f"),
                features: (s = r.features) !== null && s !== void 0 ? s : Mk
            }
        }
        )),
        lg.set(this, n => _e(this, void 0, void 0, function*() {
            const {authToken: r, chain: i} = W(this, wl, "f").call(this);
            try {
                return yield W(this, Wo, "f").call(this, s => _e(this, void 0, void 0, function*() {
                    return yield W(this, yl, "f").call(this, s, r, i),
                    (yield s.signTransactions({
                        payloads: n.map(ns)
                    })).signed_payloads.map(Nn)
                }))
            } catch (s) {
                throw new Error(s instanceof Error && s.message || "Unknown error")
            }
        })),
        cg.set(this, (n, r) => _e(this, void 0, void 0, function*() {
            const {authToken: i, chain: s} = W(this, wl, "f").call(this);
            try {
                return yield W(this, Wo, "f").call(this, o => _e(this, void 0, void 0, function*() {
                    const [a,l] = yield Promise.all([o.getCapabilities(), W(this, yl, "f").call(this, o, i, s)]);
                    if (a.supports_sign_and_send_transactions)
                        return (yield o.signAndSendTransactions(Object.assign(Object.assign({}, r), {
                            payloads: [ns(n)]
                        }))).signatures.map(Nn)[0];
                    throw new Error("connected wallet does not support signAndSendTransaction")
                }))
            } catch (o) {
                throw new Error(o instanceof Error && o.message || "Unknown error")
            }
        })),
        Yu.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const r = [];
            for (const i of n) {
                const s = yield W(this, cg, "f").call(this, i.transaction, i.options);
                r.push({
                    signature: s
                })
            }
            return r
        })),
        Zu.set(this, (...n) => _e(this, void 0, void 0, function*() {
            return (yield W(this, lg, "f").call(this, n.map( ({transaction: r}) => r))).map(r => ({
                signedTransaction: r
            }))
        })),
        ug.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const {authToken: r, chain: i} = W(this, wl, "f").call(this)
              , s = n.map( ({account: a}) => ns(a.publicKey))
              , o = n.map( ({message: a}) => ns(a));
            try {
                return yield W(this, Wo, "f").call(this, a => _e(this, void 0, void 0, function*() {
                    return yield W(this, yl, "f").call(this, a, r, i),
                    (yield a.signMessages({
                        addresses: s,
                        payloads: o
                    })).signed_payloads.map(Nn).map(c => ({
                        signedMessage: c,
                        signature: c.slice(-Ik)
                    }))
                }))
            } catch (a) {
                throw new Error(a instanceof Error && a.message || "Unknown error")
            }
        })),
        dg.set(this, (...n) => _e(this, void 0, void 0, function*() {
            const r = [];
            if (n.length > 1)
                for (const i of n)
                    r.push(yield W(this, Qu, "f").call(this, i));
            else
                return [yield W(this, Qu, "f").call(this, n[0])];
            return r
        })),
        Qu.set(this, n => _e(this, void 0, void 0, function*() {
            var r, i, s;
            Te(this, Fi, !0, "f");
            try {
                const o = yield W(this, Hu, "f").call(this, Object.assign(Object.assign({}, n), {
                    domain: (r = n?.domain) !== null && r !== void 0 ? r : window.location.host
                }));
                if (!o.sign_in_result)
                    throw new Error("Sign in failed, no sign in result returned by wallet");
                const a = o.sign_in_result.address
                  , l = o.accounts.find(c => c.address == a);
                return {
                    account: Object.assign(Object.assign({}, l ?? {
                        address: dc.default.encode(Nn(a))
                    }), {
                        publicKey: Nn(a),
                        chains: (i = l?.chains) !== null && i !== void 0 ? i : W(this, Ns, "f"),
                        features: (s = l?.features) !== null && s !== void 0 ? s : o.capabilities.features
                    }),
                    signedMessage: Nn(o.sign_in_result.signed_message),
                    signature: Nn(o.sign_in_result.signature)
                }
            } catch (o) {
                throw new Error(o instanceof Error && o.message || "Unknown error")
            } finally {
                Te(this, Fi, !1, "f")
            }
        })),
        Te(this, Wi, e.authorizationCache, "f"),
        Te(this, pl, e.appIdentity, "f"),
        Te(this, Ns, e.chains, "f"),
        Te(this, Fu, e.chainSelector, "f"),
        Te(this, Ku, e.remoteHostAuthority, "f"),
        Te(this, $u, e.onWalletNotFound, "f"),
        Te(this, gl, {
            [Gt.SolanaSignAndSendTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: W(this, Yu, "f")
            },
            [Gt.SolanaSignTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: W(this, Zu, "f")
            }
        }, "f")
    }
    get version() {
        return W(this, tg, "f")
    }
    get name() {
        return W(this, ng, "f")
    }
    get url() {
        return W(this, rg, "f")
    }
    get icon() {
        return W(this, ig, "f")
    }
    get chains() {
        return W(this, Ns, "f")
    }
    get features() {
        return Object.assign({
            [ga.StandardConnect]: {
                version: "1.0.0",
                connect: W(this, og, "f")
            },
            [ga.StandardDisconnect]: {
                version: "1.0.0",
                disconnect: W(this, qu, "f")
            },
            [ga.StandardEvents]: {
                version: "1.0.0",
                on: W(this, sg, "f")
            },
            [Gt.SolanaSignMessage]: {
                version: "1.0.0",
                signMessage: W(this, ug, "f")
            },
            [Gt.SolanaSignIn]: {
                version: "1.0.0",
                signIn: W(this, dg, "f")
            }
        }, W(this, gl, "f"))
    }
    get accounts() {
        var e, n;
        return (n = (e = W(this, Mn, "f")) === null || e === void 0 ? void 0 : e.accounts) !== null && n !== void 0 ? n : []
    }
    get connected() {
        return !!W(this, Er, "f") && !!W(this, Mn, "f")
    }
    get isAuthorized() {
        return !!W(this, Mn, "f")
    }
    get currentAuthorization() {
        return W(this, Mn, "f")
    }
    get cachedAuthorizationResult() {
        return W(this, Wi, "f").get()
    }
}
Gs = new WeakMap,
tg = new WeakMap,
ng = new WeakMap,
rg = new WeakMap,
ig = new WeakMap,
pl = new WeakMap,
Mn = new WeakMap,
Wi = new WeakMap,
Fi = new WeakMap,
Uo = new WeakMap,
Ns = new WeakMap,
Fu = new WeakMap,
gl = new WeakMap,
$u = new WeakMap,
Ku = new WeakMap,
Er = new WeakMap,
sg = new WeakMap,
og = new WeakMap,
Hu = new WeakMap,
ml = new WeakMap,
ag = new WeakMap,
yl = new WeakMap,
qu = new WeakMap,
Wo = new WeakMap,
wl = new WeakMap,
Gu = new WeakMap,
lg = new WeakMap,
cg = new WeakMap,
Yu = new WeakMap,
Zu = new WeakMap,
ug = new WeakMap,
dg = new WeakMap,
Qu = new WeakMap,
zo = new WeakSet,
Vu = function(e, ...n) {
    var r;
    (r = W(this, Gs, "f")[e]) === null || r === void 0 || r.forEach(i => i.apply(null, n))
}
,
Ak = function(e, n) {
    var r;
    W(this, Gs, "f")[e] = (r = W(this, Gs, "f")[e]) === null || r === void 0 ? void 0 : r.filter(i => n !== i)
}
;
var g6 = function(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}, m6 = function(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}, Ju;
function $1(t) {
    const e = ({register: n}) => n(t);
    try {
        window.dispatchEvent(new y6(e))
    } catch (n) {
        console.error(`wallet-standard:register-wallet event could not be dispatched
`, n)
    }
    try {
        window.addEventListener("wallet-standard:app-ready", ({detail: n}) => e(n))
    } catch (n) {
        console.error(`wallet-standard:app-ready event listener could not be added
`, n)
    }
}
let y6 = class extends Event {
    constructor(e) {
        super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        Ju.set(this, void 0),
        g6(this, Ju, e, "f")
    }
    get detail() {
        return m6(this, Ju, "f")
    }
    get type() {
        return "wallet-standard:register-wallet"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
;
Ju = new WeakMap;
function w6() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
function v6() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
}
function b6(t) {
    w6() ? $1(new Tk(t)) : v6() && t.remoteHostAuthority !== void 0 && $1(new Nk(Object.assign(Object.assign({}, t), {
        remoteHostAuthority: t.remoteHostAuthority
    })))
}
const _6 = "To use mobile wallet adapter, you must have a compatible mobile wallet application installed on your device."
  , x6 = "This browser appears to be incompatible with mobile wallet adapter. Open this page in a compatible mobile browser app and try again.";
class S6 extends Sk {
    constructor() {
        super(...arguments),
        this.contentStyles = E6,
        this.contentHtml = k6
    }
    initWithError(e) {
        super.init(),
        this.populateError(e)
    }
    populateError(e) {
        var n, r;
        const i = (n = this.dom) === null || n === void 0 ? void 0 : n.getElementById("mobile-wallet-adapter-error-message")
          , s = (r = this.dom) === null || r === void 0 ? void 0 : r.getElementById("mobile-wallet-adapter-error-action");
        if (i) {
            if (e.name === "SolanaMobileWalletAdapterError")
                switch (e.code) {
                case "ERROR_WALLET_NOT_FOUND":
                    i.innerHTML = _6,
                    s && s.addEventListener("click", () => {
                        window.location.href = "https://solanamobile.com/wallets"
                    }
                    );
                    return;
                case "ERROR_BROWSER_NOT_SUPPORTED":
                    i.innerHTML = x6,
                    s && (s.style.display = "none");
                    return
                }
            i.innerHTML = `An unexpected error occurred: ${e.message}`
        } else
            console.log("Failed to locate error dialog element")
    }
}
const k6 = `
<svg class="mobile-wallet-adapter-embedded-modal-error-icon" xmlns="http://www.w3.org/2000/svg" height="50px" viewBox="0 -960 960 960" width="50px" fill="#000000"><path d="M 280,-80 Q 197,-80 138.5,-138.5 80,-197 80,-280 80,-363 138.5,-421.5 197,-480 280,-480 q 83,0 141.5,58.5 58.5,58.5 58.5,141.5 0,83 -58.5,141.5 Q 363,-80 280,-80 Z M 824,-120 568,-376 Q 556,-389 542.5,-402.5 529,-416 516,-428 q 38,-24 61,-64 23,-40 23,-88 0,-75 -52.5,-127.5 Q 495,-760 420,-760 345,-760 292.5,-707.5 240,-655 240,-580 q 0,6 0.5,11.5 0.5,5.5 1.5,11.5 -18,2 -39.5,8 -21.5,6 -38.5,14 -2,-11 -3,-22 -1,-11 -1,-23 0,-109 75.5,-184.5 Q 311,-840 420,-840 q 109,0 184.5,75.5 75.5,75.5 75.5,184.5 0,43 -13.5,81.5 Q 653,-460 629,-428 l 251,252 z m -615,-61 71,-71 70,71 29,-28 -71,-71 71,-71 -28,-28 -71,71 -71,-71 -28,28 71,71 -71,71 z"/></svg>
<div class="mobile-wallet-adapter-embedded-modal-title">We can't find a wallet.</div>
<div id="mobile-wallet-adapter-error-message" class="mobile-wallet-adapter-embedded-modal-subtitle"></div>
<div>
    <button data-error-action id="mobile-wallet-adapter-error-action" class="mobile-wallet-adapter-embedded-modal-error-action">
        Find a wallet
    </button>
</div>
`
  , E6 = `
.mobile-wallet-adapter-embedded-modal-content {
    text-align: center;
}

.mobile-wallet-adapter-embedded-modal-error-icon {
    margin-top: 24px;
}

.mobile-wallet-adapter-embedded-modal-title {
    margin: 18px 100px auto 100px;
    color: #000000;
    font-size: 2.75em;
    font-weight: 600;
}

.mobile-wallet-adapter-embedded-modal-subtitle {
    margin: 30px 60px 40px 60px;
    color: #000000;
    font-size: 1.25em;
    font-weight: 400;
}

.mobile-wallet-adapter-embedded-modal-error-action {
    display: block;
    width: 100%;
    height: 56px;
    /*margin-top: 40px;*/
    font-size: 1.25em;
    /*line-height: 24px;*/
    /*letter-spacing: -1%;*/
    background: #000000;
    color: #FFFFFF;
    border-radius: 18px;
}

/* Smaller screens */
@media all and (max-width: 600px) {
    .mobile-wallet-adapter-embedded-modal-title {
        font-size: 1.5em;
        margin-right: 12px;
        margin-left: 12px;
    }
    .mobile-wallet-adapter-embedded-modal-subtitle {
        margin-right: 12px;
        margin-left: 12px;
    }
}
`;
function Ck() {
    return _e(this, void 0, void 0, function*() {
        if (typeof window < "u") {
            const t = window.navigator.userAgent.toLowerCase()
              , e = new S6;
            t.includes("wv") ? e.initWithError({
                name: "SolanaMobileWalletAdapterError",
                code: "ERROR_BROWSER_NOT_SUPPORTED",
                message: ""
            }) : e.initWithError({
                name: "SolanaMobileWalletAdapterError",
                code: "ERROR_WALLET_NOT_FOUND",
                message: ""
            }),
            e.open()
        }
    })
}
function A6() {
    return () => _e(this, void 0, void 0, function*() {
        Ck()
    })
}
const v0 = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function I6() {
    let t;
    try {
        t = window.localStorage
    } catch {}
    return {
        clear() {
            return _e(this, void 0, void 0, function*() {
                if (t)
                    try {
                        t.removeItem(v0)
                    } catch {}
            })
        },
        get() {
            return _e(this, void 0, void 0, function*() {
                if (t)
                    try {
                        const e = JSON.parse(t.getItem(v0));
                        if (e && e.accounts) {
                            const n = e.accounts.map(r => Object.assign(Object.assign({}, r), {
                                publicKey: "publicKey"in r ? new Uint8Array(Object.values(r.publicKey)) : dc.default.decode(r.address)
                            }));
                            return Object.assign(Object.assign({}, e), {
                                accounts: n
                            })
                        } else
                            return e || void 0
                    } catch {}
            })
        },
        set(e) {
            return _e(this, void 0, void 0, function*() {
                if (t)
                    try {
                        t.setItem(v0, JSON.stringify(e))
                    } catch {}
            })
        }
    }
}
function M6() {
    return {
        select(t) {
            return _e(this, void 0, void 0, function*() {
                return t.length === 1 ? t[0] : t.includes(F1.SOLANA_MAINNET_CHAIN) ? F1.SOLANA_MAINNET_CHAIN : t[0]
            })
        }
    }
}
oi.LocalSolanaMobileWalletAdapterWallet = Tk;
oi.RemoteSolanaMobileWalletAdapterWallet = Nk;
oi.SolanaMobileWalletAdapterWalletName = ky;
oi.createDefaultAuthorizationCache = I6;
oi.createDefaultChainSelector = M6;
oi.createDefaultWalletNotFoundHandler = A6;
oi.defaultErrorModalWalletNotFoundHandler = Ck;
oi.registerMwa = b6;
Object.defineProperty(bs, "__esModule", {
    value: !0
});
var Xt = PN
  , Xu = ON
  , Os = Me
  , ja = oi;
function He(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
function me(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
function Jn(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
const hg = "standard:connect"
  , T6 = "standard:disconnect"
  , N6 = "standard:events";
function b0(t) {
    return window.btoa(String.fromCharCode.call(null, ...t))
}
function C6() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
var rn, ht, Yi, bi, ed, yi, Cs, fg, pg, Rk, Gd, td, Hi;
const R6 = "Mobile Wallet Adapter"
  , L6 = 64;
function j6(t) {
    return "version"in t
}
function Ey(t) {
    switch (t) {
    case "mainnet-beta":
        return "solana:mainnet";
    case "testnet":
        return "solana:testnet";
    case "devnet":
        return "solana:devnet";
    default:
        return t
    }
}
class Lk extends Xt.BaseSignInMessageSignerWalletAdapter {
    constructor(e, n) {
        super(),
        rn.add(this),
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        ht.set(this, void 0),
        Yi.set(this, !1),
        bi.set(this, C6() ? Xt.WalletReadyState.Loadable : Xt.WalletReadyState.Unsupported),
        ed.set(this, void 0),
        yi.set(this, void 0),
        Cs.set(this, void 0),
        fg.set(this, r => He(this, void 0, void 0, function*() {
            if (r.accounts && r.accounts.length > 0) {
                me(this, rn, "m", Rk).call(this);
                const i = yield me(this, ed, "f").call(this, r.accounts);
                i !== me(this, yi, "f") && (Jn(this, yi, i, "f"),
                Jn(this, Cs, void 0, "f"),
                this.emit("connect", this.publicKey))
            }
        })),
        Jn(this, ed, r => He(this, void 0, void 0, function*() {
            var i;
            const s = yield n.addressSelector.select(r.map( ({publicKey: o}) => b0(o)));
            return (i = r.find( ({publicKey: o}) => b0(o) === s)) !== null && i !== void 0 ? i : r[0]
        }), "f"),
        Jn(this, ht, e, "f"),
        me(this, ht, "f").features[N6].on("change", me(this, fg, "f")),
        this.name = me(this, ht, "f").name,
        this.icon = me(this, ht, "f").icon,
        this.url = me(this, ht, "f").url
    }
    get publicKey() {
        var e;
        if (!me(this, Cs, "f") && me(this, yi, "f"))
            try {
                Jn(this, Cs, new Xu.PublicKey(me(this, yi, "f").publicKey), "f")
            } catch (n) {
                throw new Xt.WalletPublicKeyError(n instanceof Error && n?.message || "Unknown error",n)
            }
        return (e = me(this, Cs, "f")) !== null && e !== void 0 ? e : null
    }
    get connected() {
        return me(this, ht, "f").connected
    }
    get connecting() {
        return me(this, Yi, "f")
    }
    get readyState() {
        return me(this, bi, "f")
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return He(this, void 0, void 0, function*() {
            return yield this.autoConnect()
        })
    }
    autoConnect() {
        return He(this, void 0, void 0, function*() {
            me(this, rn, "m", pg).call(this, !0)
        })
    }
    connect() {
        return He(this, void 0, void 0, function*() {
            me(this, rn, "m", pg).call(this)
        })
    }
    performAuthorization(e) {
        return He(this, void 0, void 0, function*() {
            try {
                const n = yield me(this, ht, "f").cachedAuthorizationResult;
                return n ? (yield me(this, ht, "f").features[hg].connect({
                    silent: !0
                }),
                n) : (e ? yield me(this, ht, "f").features[Os.SolanaSignIn].signIn(e) : yield me(this, ht, "f").features[hg].connect(),
                yield yield me(this, ht, "f").cachedAuthorizationResult)
            } catch (n) {
                throw new Xt.WalletConnectionError(n instanceof Error && n.message || "Unknown error",n)
            }
        })
    }
    disconnect() {
        return He(this, void 0, void 0, function*() {
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                Jn(this, Yi, !1, "f"),
                Jn(this, Cs, void 0, "f"),
                Jn(this, yi, void 0, "f"),
                yield me(this, ht, "f").features[T6].disconnect(),
                this.emit("disconnect")
            }))
        })
    }
    signIn(e) {
        return He(this, void 0, void 0, function*() {
            return me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                var n;
                if (me(this, bi, "f") !== Xt.WalletReadyState.Installed && me(this, bi, "f") !== Xt.WalletReadyState.Loadable)
                    throw new Xt.WalletNotReadyError;
                Jn(this, Yi, !0, "f");
                try {
                    const r = yield me(this, ht, "f").features[Os.SolanaSignIn].signIn(Object.assign(Object.assign({}, e), {
                        domain: (n = e?.domain) !== null && n !== void 0 ? n : window.location.host
                    }));
                    if (r.length > 0)
                        return r[0];
                    throw new Error("Sign in failed, no sign in result returned by wallet")
                } catch (r) {
                    throw new Xt.WalletConnectionError(r instanceof Error && r.message || "Unknown error",r)
                } finally {
                    Jn(this, Yi, !1, "f")
                }
            }))
        })
    }
    signMessage(e) {
        return He(this, void 0, void 0, function*() {
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                const n = me(this, rn, "m", Gd).call(this);
                try {
                    return (yield me(this, ht, "f").features[Os.SolanaSignMessage].signMessage({
                        account: n,
                        message: e
                    }))[0].signature
                } catch (r) {
                    throw new Xt.WalletSignMessageError(r?.message,r)
                }
            }))
        })
    }
    sendTransaction(e, n, r) {
        return He(this, void 0, void 0, function*() {
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                const i = me(this, rn, "m", Gd).call(this);
                try {
                    let s = function() {
                        let o;
                        switch (n.commitment) {
                        case "confirmed":
                        case "finalized":
                        case "processed":
                            o = n.commitment;
                            break;
                        default:
                            o = "finalized"
                        }
                        let a;
                        switch (r?.preflightCommitment) {
                        case "confirmed":
                        case "finalized":
                        case "processed":
                            a = r.preflightCommitment;
                            break;
                        case void 0:
                            a = o;
                            break;
                        default:
                            a = "finalized"
                        }
                        return (a === "finalized" ? 2 : a === "confirmed" ? 1 : 0) < (o === "finalized" ? 2 : o === "confirmed" ? 1 : 0) ? a : o
                    };
                    if (Os.SolanaSignAndSendTransaction in me(this, ht, "f").features) {
                        const o = Ey(me(this, ht, "f").currentAuthorization.chain)
                          , [a] = (yield me(this, ht, "f").features[Os.SolanaSignAndSendTransaction].signAndSendTransaction({
                            account: i,
                            transaction: e.serialize(),
                            chain: o,
                            options: r ? {
                                skipPreflight: r.skipPreflight,
                                maxRetries: r.maxRetries
                            } : void 0
                        })).map(l => b0(l.signature));
                        return a
                    } else {
                        const [o] = yield me(this, rn, "m", td).call(this, [e]);
                        if (j6(o))
                            return yield n.sendTransaction(o);
                        {
                            const a = o.serialize();
                            return yield n.sendRawTransaction(a, Object.assign(Object.assign({}, r), {
                                preflightCommitment: s()
                            }))
                        }
                    }
                } catch (s) {
                    throw new Xt.WalletSendTransactionError(s?.message,s)
                }
            }))
        })
    }
    signTransaction(e) {
        return He(this, void 0, void 0, function*() {
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                const [n] = yield me(this, rn, "m", td).call(this, [e]);
                return n
            }))
        })
    }
    signAllTransactions(e) {
        return He(this, void 0, void 0, function*() {
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                return yield me(this, rn, "m", td).call(this, e)
            }))
        })
    }
}
ht = new WeakMap,
Yi = new WeakMap,
bi = new WeakMap,
ed = new WeakMap,
yi = new WeakMap,
Cs = new WeakMap,
fg = new WeakMap,
rn = new WeakSet,
pg = function(e=!1) {
    return He(this, void 0, void 0, function*() {
        if (!(this.connecting || this.connected))
            return yield me(this, rn, "m", Hi).call(this, () => He(this, void 0, void 0, function*() {
                if (me(this, bi, "f") !== Xt.WalletReadyState.Installed && me(this, bi, "f") !== Xt.WalletReadyState.Loadable)
                    throw new Xt.WalletNotReadyError;
                Jn(this, Yi, !0, "f");
                try {
                    yield me(this, ht, "f").features[hg].connect({
                        silent: e
                    })
                } catch (n) {
                    throw new Xt.WalletConnectionError(n instanceof Error && n.message || "Unknown error",n)
                } finally {
                    Jn(this, Yi, !1, "f")
                }
            }))
    })
}
,
Rk = function() {
    me(this, bi, "f") !== Xt.WalletReadyState.Installed && this.emit("readyStateChange", Jn(this, bi, Xt.WalletReadyState.Installed, "f"))
}
,
Gd = function() {
    if (!me(this, ht, "f").isAuthorized || !me(this, yi, "f"))
        throw new Xt.WalletNotConnectedError;
    return me(this, yi, "f")
}
,
td = function(e) {
    return He(this, void 0, void 0, function*() {
        const n = me(this, rn, "m", Gd).call(this);
        try {
            if (Os.SolanaSignTransaction in me(this, ht, "f").features)
                return me(this, ht, "f").features[Os.SolanaSignTransaction].signTransaction(...e.map(r => ({
                    account: n,
                    transaction: r.serialize()
                }))).then(r => r.map(i => {
                    const s = i.signedTransaction
                      , a = s[0] * L6 + 1;
                    return Xu.VersionedMessage.deserializeMessageVersion(s.slice(a, s.length)) === "legacy" ? Xu.Transaction.from(s) : Xu.VersionedTransaction.deserialize(s)
                }
                ));
            throw new Error("Connected wallet does not support signing transactions")
        } catch (r) {
            throw new Xt.WalletSignTransactionError(r?.message,r)
        }
    })
}
,
Hi = function(e) {
    return He(this, void 0, void 0, function*() {
        try {
            return yield e()
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    })
}
;
class jk extends Lk {
    constructor(e) {
        var n;
        const r = Ey((n = e.chain) !== null && n !== void 0 ? n : e.cluster);
        super(new ja.LocalSolanaMobileWalletAdapterWallet({
            appIdentity: e.appIdentity,
            authorizationCache: {
                set: e.authorizationResultCache.set,
                get: () => He(this, void 0, void 0, function*() {
                    return yield e.authorizationResultCache.get()
                }),
                clear: e.authorizationResultCache.clear
            },
            chains: [r],
            chainSelector: ja.createDefaultChainSelector(),
            onWalletNotFound: () => He(this, void 0, void 0, function*() {
                e.onWalletNotFound(this)
            })
        }), {
            addressSelector: e.addressSelector,
            chain: r
        })
    }
}
class B6 extends Lk {
    constructor(e) {
        const n = Ey(e.chain);
        super(new ja.RemoteSolanaMobileWalletAdapterWallet({
            appIdentity: e.appIdentity,
            authorizationCache: {
                set: e.authorizationResultCache.set,
                get: () => He(this, void 0, void 0, function*() {
                    return yield e.authorizationResultCache.get()
                }),
                clear: e.authorizationResultCache.clear
            },
            chains: [n],
            chainSelector: ja.createDefaultChainSelector(),
            remoteHostAuthority: e.remoteHostAuthority,
            onWalletNotFound: () => He(this, void 0, void 0, function*() {
                e.onWalletNotFound(this)
            })
        }), {
            addressSelector: e.addressSelector,
            chain: n
        })
    }
}
class P6 extends jk {
}
function O6() {
    return {
        select(t) {
            return He(this, void 0, void 0, function*() {
                return t[0]
            })
        }
    }
}
function D6() {
    return ja.createDefaultAuthorizationCache()
}
function z6(t) {
    return He(this, void 0, void 0, function*() {
        return ja.defaultErrorModalWalletNotFoundHandler()
    })
}
function U6() {
    return z6
}
bs.LocalSolanaMobileWalletAdapter = jk;
bs.RemoteSolanaMobileWalletAdapter = B6;
var W6 = bs.SolanaMobileWalletAdapter = P6, nd = bs.SolanaMobileWalletAdapterWalletName = R6, F6 = bs.createDefaultAddressSelector = O6, $6 = bs.createDefaultAuthorizationResultCache = D6, K6 = bs.createDefaultWalletNotFoundHandler = U6, V6 = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
, H6 = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
, rd;
function q6(t) {
    const e = ({register: n}) => n(t);
    try {
        window.dispatchEvent(new G6(e))
    } catch (n) {
        console.error(`wallet-standard:register-wallet event could not be dispatched
`, n)
    }
    try {
        window.addEventListener("wallet-standard:app-ready", ({detail: n}) => e(n))
    } catch (n) {
        console.error(`wallet-standard:app-ready event listener could not be added
`, n)
    }
}
class G6 extends Event {
    get detail() {
        return V6(this, rd, "f")
    }
    get type() {
        return "wallet-standard:register-wallet"
    }
    constructor(e) {
        super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        rd.set(this, void 0),
        H6(this, rd, e, "f")
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
rd = new WeakMap;
globalThis && globalThis.__classPrivateFieldGet;
globalThis && globalThis.__classPrivateFieldSet;
function Y6(t, e) {
    if (t === e)
        return !0;
    const n = t.length;
    if (n !== e.length)
        return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function Z6(t) {
    if (t.length >= 255)
        throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let c = 0; c < e.length; c++)
        e[c] = 255;
    for (let c = 0; c < t.length; c++) {
        const d = t.charAt(c)
          , h = d.charCodeAt(0);
        if (e[h] !== 255)
            throw new TypeError(d + " is ambiguous");
        e[h] = c
    }
    const n = t.length
      , r = t.charAt(0)
      , i = Math.log(n) / Math.log(256)
      , s = Math.log(256) / Math.log(n);
    function o(c) {
        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer,c.byteOffset,c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))),
        !(c instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (c.length === 0)
            return "";
        let d = 0
          , h = 0
          , y = 0;
        const m = c.length;
        for (; y !== m && c[y] === 0; )
            y++,
            d++;
        const v = (m - y) * s + 1 >>> 0
          , E = new Uint8Array(v);
        for (; y !== m; ) {
            let x = c[y]
              , b = 0;
            for (let R = v - 1; (x !== 0 || b < h) && R !== -1; R--,
            b++)
                x += 256 * E[R] >>> 0,
                E[R] = x % n >>> 0,
                x = x / n >>> 0;
            if (x !== 0)
                throw new Error("Non-zero carry");
            h = b,
            y++
        }
        let A = v - h;
        for (; A !== v && E[A] === 0; )
            A++;
        let _ = r.repeat(d);
        for (; A < v; ++A)
            _ += t.charAt(E[A]);
        return _
    }
    function a(c) {
        if (typeof c != "string")
            throw new TypeError("Expected String");
        if (c.length === 0)
            return new Uint8Array;
        let d = 0
          , h = 0
          , y = 0;
        for (; c[d] === r; )
            h++,
            d++;
        const m = (c.length - d) * i + 1 >>> 0
          , v = new Uint8Array(m);
        for (; d < c.length; ) {
            const x = c.charCodeAt(d);
            if (x > 255)
                return;
            let b = e[x];
            if (b === 255)
                return;
            let R = 0;
            for (let O = m - 1; (b !== 0 || R < y) && O !== -1; O--,
            R++)
                b += n * v[O] >>> 0,
                v[O] = b % 256 >>> 0,
                b = b / 256 >>> 0;
            if (b !== 0)
                throw new Error("Non-zero carry");
            y = R,
            d++
        }
        let E = m - y;
        for (; E !== m && v[E] === 0; )
            E++;
        const A = new Uint8Array(h + (m - E));
        let _ = h;
        for (; E !== m; )
            A[_++] = v[E++];
        return A
    }
    function l(c) {
        const d = a(c);
        if (d)
            return d;
        throw new Error("Non-base" + n + " character")
    }
    return {
        encode: o,
        decodeUnsafe: a,
        decode: l
    }
}
var Q6 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const J6 = Z6(Q6);
var he = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
, Ht = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
, fn, Un, Ys, Zs, Rs, vl, Yd, De, Zd, gg, id, mg, Rl, yg, K1, V1, H1, q1;
class X6 extends yy {
    get name() {
        return he(this, De, "f").name
    }
    get url() {
        return "https://github.com/solana-labs/wallet-standard"
    }
    get icon() {
        return he(this, De, "f").icon
    }
    get readyState() {
        return he(this, Zd, "f")
    }
    get publicKey() {
        return he(this, Ys, "f")
    }
    get connecting() {
        return he(this, Zs, "f")
    }
    get supportedTransactionVersions() {
        return he(this, Yd, "f")
    }
    get wallet() {
        return he(this, De, "f")
    }
    get standard() {
        return !0
    }
    constructor({wallet: e}) {
        super(),
        fn.add(this),
        Un.set(this, void 0),
        Ys.set(this, void 0),
        Zs.set(this, void 0),
        Rs.set(this, void 0),
        vl.set(this, void 0),
        Yd.set(this, void 0),
        De.set(this, void 0),
        Zd.set(this, typeof window > "u" || typeof document > "u" ? Re.Unsupported : Re.Installed),
        yg.set(this, n => {
            if ("accounts"in n) {
                const r = he(this, De, "f").accounts[0];
                he(this, Un, "f") && !he(this, Rs, "f") && r !== he(this, Un, "f") && (r ? he(this, fn, "m", id).call(this, r) : (this.emit("error", new Ec),
                he(this, fn, "m", mg).call(this)))
            }
            "features"in n && he(this, fn, "m", Rl).call(this)
        }
        ),
        Ht(this, De, e, "f"),
        Ht(this, Un, null, "f"),
        Ht(this, Ys, null, "f"),
        Ht(this, Zs, !1, "f"),
        Ht(this, Rs, !1, "f"),
        Ht(this, vl, he(this, De, "f").features[Nc].on("change", he(this, yg, "f")), "f"),
        he(this, fn, "m", Rl).call(this)
    }
    destroy() {
        Ht(this, Un, null, "f"),
        Ht(this, Ys, null, "f"),
        Ht(this, Zs, !1, "f"),
        Ht(this, Rs, !1, "f");
        const e = he(this, vl, "f");
        e && (Ht(this, vl, null, "f"),
        e())
    }
    async autoConnect() {
        return he(this, fn, "m", gg).call(this, {
            silent: !0
        })
    }
    async connect() {
        return he(this, fn, "m", gg).call(this)
    }
    async disconnect() {
        if (cc in he(this, De, "f").features)
            try {
                Ht(this, Rs, !0, "f"),
                await he(this, De, "f").features[cc].disconnect()
            } catch (e) {
                this.emit("error", new Ac(e?.message,e))
            } finally {
                Ht(this, Rs, !1, "f")
            }
        he(this, fn, "m", mg).call(this)
    }
    async sendTransaction(e, n, r={}) {
        try {
            const i = he(this, Un, "f");
            if (!i)
                throw new at;
            let s;
            if (Me.SolanaSignAndSendTransaction in he(this, De, "f").features)
                if (i.features.includes(Me.SolanaSignAndSendTransaction))
                    s = Me.SolanaSignAndSendTransaction;
                else if (Me.SolanaSignTransaction in he(this, De, "f").features && i.features.includes(Me.SolanaSignTransaction))
                    s = Me.SolanaSignTransaction;
                else
                    throw new ki;
            else if (Me.SolanaSignTransaction in he(this, De, "f").features) {
                if (!i.features.includes(Me.SolanaSignTransaction))
                    throw new ki;
                s = Me.SolanaSignTransaction
            } else
                throw new Hs;
            const o = AC(n.rpcEndpoint);
            if (!i.chains.includes(o))
                throw new Qr;
            try {
                const {signers: a, ...l} = r;
                let c;
                if (Jr(e) ? (a?.length && e.sign(a),
                c = e.serialize()) : (e = await this.prepareTransaction(e, n, l),
                a?.length && e.partialSign(...a),
                c = new Uint8Array(e.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))),
                s === Me.SolanaSignAndSendTransaction) {
                    const [d] = await he(this, De, "f").features[Me.SolanaSignAndSendTransaction].signAndSendTransaction({
                        account: i,
                        chain: o,
                        transaction: c,
                        options: {
                            preflightCommitment: y0(l.preflightCommitment || n.commitment),
                            skipPreflight: l.skipPreflight,
                            maxRetries: l.maxRetries,
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return J6.encode(d.signature)
                } else {
                    const [d] = await he(this, De, "f").features[Me.SolanaSignTransaction].signTransaction({
                        account: i,
                        chain: o,
                        transaction: c,
                        options: {
                            preflightCommitment: y0(l.preflightCommitment || n.commitment),
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return await n.sendRawTransaction(d.signedTransaction, {
                        ...l,
                        preflightCommitment: y0(l.preflightCommitment || n.commitment)
                    })
                }
            } catch (a) {
                throw a instanceof wt ? a : new Qr(a?.message,a)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
}
Un = new WeakMap,
Ys = new WeakMap,
Zs = new WeakMap,
Rs = new WeakMap,
vl = new WeakMap,
Yd = new WeakMap,
De = new WeakMap,
Zd = new WeakMap,
yg = new WeakMap,
fn = new WeakSet,
gg = async function(e) {
    try {
        if (this.connected || this.connecting)
            return;
        if (he(this, Zd, "f") !== Re.Installed)
            throw new co;
        if (Ht(this, Zs, !0, "f"),
        !he(this, De, "f").accounts.length)
            try {
                await he(this, De, "f").features[Tc].connect(e)
            } catch (r) {
                throw new Ta(r?.message,r)
            }
        const n = he(this, De, "f").accounts[0];
        if (!n)
            throw new ki;
        he(this, fn, "m", id).call(this, n)
    } catch (n) {
        throw this.emit("error", n),
        n
    } finally {
        Ht(this, Zs, !1, "f")
    }
}
,
id = function(e) {
    let n;
    try {
        n = new ne(e.address)
    } catch (r) {
        throw new uo(r?.message,r)
    }
    Ht(this, Un, e, "f"),
    Ht(this, Ys, n, "f"),
    he(this, fn, "m", Rl).call(this),
    this.emit("connect", n)
}
,
mg = function() {
    Ht(this, Un, null, "f"),
    Ht(this, Ys, null, "f"),
    he(this, fn, "m", Rl).call(this),
    this.emit("disconnect")
}
,
Rl = function() {
    const e = Me.SolanaSignAndSendTransaction in he(this, De, "f").features ? he(this, De, "f").features[Me.SolanaSignAndSendTransaction].supportedTransactionVersions : he(this, De, "f").features[Me.SolanaSignTransaction].supportedTransactionVersions;
    Ht(this, Yd, Y6(e, ["legacy"]) ? null : new Set(e), "f"),
    Me.SolanaSignTransaction in he(this, De, "f").features && he(this, Un, "f")?.features.includes(Me.SolanaSignTransaction) ? (this.signTransaction = he(this, fn, "m", K1),
    this.signAllTransactions = he(this, fn, "m", V1)) : (delete this.signTransaction,
    delete this.signAllTransactions),
    Me.SolanaSignMessage in he(this, De, "f").features && he(this, Un, "f")?.features.includes(Me.SolanaSignMessage) ? this.signMessage = he(this, fn, "m", H1) : delete this.signMessage,
    Me.SolanaSignIn in he(this, De, "f").features ? this.signIn = he(this, fn, "m", q1) : delete this.signIn
}
,
K1 = async function(e) {
    try {
        const n = he(this, Un, "f");
        if (!n)
            throw new at;
        if (!(Me.SolanaSignTransaction in he(this, De, "f").features))
            throw new Hs;
        if (!n.features.includes(Me.SolanaSignTransaction))
            throw new ki;
        try {
            const i = (await he(this, De, "f").features[Me.SolanaSignTransaction].signTransaction({
                account: n,
                transaction: Jr(e) ? e.serialize() : new Uint8Array(e.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return Jr(e) ? oc.deserialize(i) : Be.from(i)
        } catch (r) {
            throw r instanceof wt ? r : new ir(r?.message,r)
        }
    } catch (n) {
        throw this.emit("error", n),
        n
    }
}
,
V1 = async function(e) {
    try {
        const n = he(this, Un, "f");
        if (!n)
            throw new at;
        if (!(Me.SolanaSignTransaction in he(this, De, "f").features))
            throw new Hs;
        if (!n.features.includes(Me.SolanaSignTransaction))
            throw new ki;
        try {
            const r = await he(this, De, "f").features[Me.SolanaSignTransaction].signTransaction(...e.map(i => ({
                account: n,
                transaction: Jr(i) ? i.serialize() : new Uint8Array(i.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            })));
            return e.map( (i, s) => {
                const o = r[s].signedTransaction;
                return Jr(i) ? oc.deserialize(o) : Be.from(o)
            }
            )
        } catch (r) {
            throw new ir(r?.message,r)
        }
    } catch (n) {
        throw this.emit("error", n),
        n
    }
}
,
H1 = async function(e) {
    try {
        const n = he(this, Un, "f");
        if (!n)
            throw new at;
        if (!(Me.SolanaSignMessage in he(this, De, "f").features))
            throw new Hs;
        if (!n.features.includes(Me.SolanaSignMessage))
            throw new ki;
        try {
            return (await he(this, De, "f").features[Me.SolanaSignMessage].signMessage({
                account: n,
                message: e
            }))[0].signature
        } catch (r) {
            throw new Ic(r?.message,r)
        }
    } catch (n) {
        throw this.emit("error", n),
        n
    }
}
,
q1 = async function(e={}) {
    try {
        if (!(Me.SolanaSignIn in he(this, De, "f").features))
            throw new Hs;
        let n;
        try {
            [n] = await he(this, De, "f").features[Me.SolanaSignIn].signIn(e)
        } catch (r) {
            throw new Pp(r?.message,r)
        }
        if (!n)
            throw new Pp;
        return he(this, fn, "m", id).call(this, n.account),
        n
    } catch (n) {
        throw this.emit("error", n),
        n
    }
}
;
const eR = PS;
var tR = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
, nR = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
, sd;
let er;
const qh = new Set;
function rR(t) {
    Ll = void 0,
    qh.add(t)
}
function iR(t) {
    Ll = void 0,
    qh.delete(t)
}
const ia = {};
function sR() {
    if (er || (er = Object.freeze({
        register: G1,
        get: oR,
        on: aR
    }),
    typeof window > "u"))
        return er;
    const t = Object.freeze({
        register: G1
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", ({detail: e}) => e(t))
    } catch (e) {
        console.error(`wallet-standard:register-wallet event listener could not be added
`, e)
    }
    try {
        window.dispatchEvent(new lR(t))
    } catch (e) {
        console.error(`wallet-standard:app-ready event could not be dispatched
`, e)
    }
    return er
}
function G1(...t) {
    return t = t.filter(e => !qh.has(e)),
    t.length ? (t.forEach(e => rR(e)),
    ia.register?.forEach(e => wg( () => e(...t))),
    function() {
        t.forEach(n => iR(n)),
        ia.unregister?.forEach(n => wg( () => n(...t)))
    }
    ) : () => {}
}
let Ll;
function oR() {
    return Ll || (Ll = [...qh]),
    Ll
}
function aR(t, e) {
    return ia[t]?.push(e) || (ia[t] = [e]),
    function() {
        ia[t] = ia[t]?.filter(r => e !== r)
    }
}
function wg(t) {
    try {
        t()
    } catch (e) {
        console.error(e)
    }
}
class lR extends Event {
    get detail() {
        return tR(this, sd, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    constructor(e) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        sd.set(this, void 0),
        nR(this, sd, e, "f")
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
sd = new WeakMap;
function cR() {
    if (er || (er = sR(),
    typeof window > "u"))
        return er;
    const t = window.navigator.wallets || [];
    if (!Array.isArray(t))
        return console.error("window.navigator.wallets is not an array"),
        er;
    const {register: e} = er
      , n = (...r) => r.forEach(i => wg( () => i({
        register: e
    })));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: n
            })
        })
    } catch {
        return console.error("window.navigator.wallets could not be set"),
        er
    }
    return n(...t),
    er
}
function uR(t) {
    const e = Y1( () => new Set)
      , {get: n, on: r} = Y1( () => cR())
      , [i,s] = Y.useState( () => Z1(n()));
    Y.useEffect( () => {
        const a = [r("register", (...l) => s(c => [...c, ...Z1(l)])), r("unregister", (...l) => s(c => c.filter(d => l.some(h => h === d.wallet))))];
        return () => a.forEach(l => l())
    }
    , [r]);
    const o = dR(i);
    return Y.useEffect( () => {
        if (!o)
            return;
        const a = new Set(i);
        new Set(o.filter(c => !a.has(c))).forEach(c => c.destroy())
    }
    , [o, i]),
    Y.useEffect( () => () => i.forEach(a => a.destroy()), []),
    Y.useMemo( () => [...i, ...t.filter( ({name: a}) => i.some(l => l.name === a) ? (e.has(a) || (e.add(a),
    console.warn(`${a} was registered as a Standard Wallet. The Wallet Adapter for ${a} can be removed from your app.`)),
    !1) : !0)], [i, t, e])
}
function Y1(t) {
    const e = Y.useRef(void 0);
    return e.current === void 0 && (e.current = {
        value: t()
    }),
    e.current.value
}
function dR(t) {
    const e = Y.useRef(void 0);
    return Y.useEffect( () => {
        e.current = t
    }
    ),
    e.current
}
function Z1(t) {
    return t.filter(eR).map(e => new X6({
        wallet: e
    }))
}
var ma;
(function(t) {
    t[t.DESKTOP_WEB = 0] = "DESKTOP_WEB",
    t[t.MOBILE_WEB = 1] = "MOBILE_WEB"
}
)(ma || (ma = {}));
function hR(t) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(t)
}
function fR({adapters: t, userAgentString: e}) {
    return t.some(n => n.name !== nd && n.readyState === Re.Installed) ? ma.DESKTOP_WEB : e && /android/i.test(e) && !hR(e) ? ma.MOBILE_WEB : ma.DESKTOP_WEB
}
function pR(t) {
    return t ? /devnet/i.test(t) ? "devnet" : /testnet/i.test(t) ? "testnet" : "mainnet-beta" : "mainnet-beta"
}
function gR({children: t, wallets: e, adapter: n, isUnloadingRef: r, onAutoConnectRequest: i, onConnectError: s, onError: o, onSelectWallet: a}) {
    const l = Y.useRef(!1)
      , [c,d] = Y.useState(!1)
      , h = Y.useRef(!1)
      , [y,m] = Y.useState(!1)
      , [v,E] = Y.useState( () => n?.publicKey ?? null)
      , [A,_] = Y.useState( () => n?.connected ?? !1)
      , x = Y.useRef(o);
    Y.useEffect( () => (x.current = o,
    () => {
        x.current = void 0
    }
    ), [o]);
    const b = Y.useRef( (p, k) => (r.current || (x.current ? x.current(p, k) : (console.error(p, k),
    p instanceof co && typeof window < "u" && k && window.open(k.url, "_blank"))),
    p))
      , [R,O] = Y.useState( () => e.map(p => ({
        adapter: p,
        readyState: p.readyState
    })).filter( ({readyState: p}) => p !== Re.Unsupported));
    Y.useEffect( () => {
        O(k => e.map( (C, I) => {
            const L = k[I];
            return L && L.adapter === C && L.readyState === C.readyState ? L : {
                adapter: C,
                readyState: C.readyState
            }
        }
        ).filter( ({readyState: C}) => C !== Re.Unsupported));
        function p(k) {
            O(C => {
                const I = C.findIndex( ({adapter: P}) => P === this);
                if (I === -1)
                    return C;
                const {adapter: L} = C[I];
                return [...C.slice(0, I), {
                    adapter: L,
                    readyState: k
                }, ...C.slice(I + 1)].filter( ({readyState: P}) => P !== Re.Unsupported)
            }
            )
        }
        return e.forEach(k => k.on("readyStateChange", p, k)),
        () => {
            e.forEach(k => k.off("readyStateChange", p, k))
        }
    }
    , [n, e]);
    const D = Y.useMemo( () => R.find(p => p.adapter === n) ?? null, [n, R]);
    Y.useEffect( () => {
        if (!n)
            return;
        const p = I => {
            E(I),
            l.current = !1,
            d(!1),
            _(!0),
            h.current = !1,
            m(!1)
        }
          , k = () => {
            r.current || (E(null),
            l.current = !1,
            d(!1),
            _(!1),
            h.current = !1,
            m(!1))
        }
          , C = I => {
            b.current(I, n)
        }
        ;
        return n.on("connect", p),
        n.on("disconnect", k),
        n.on("error", C),
        () => {
            n.off("connect", p),
            n.off("disconnect", k),
            n.off("error", C),
            k()
        }
    }
    , [n, r]);
    const z = Y.useRef(!1);
    Y.useEffect( () => () => {
        z.current = !1
    }
    , [n]),
    Y.useEffect( () => {
        z.current || l.current || A || !i || !(D?.readyState === Re.Installed || D?.readyState === Re.Loadable) || (l.current = !0,
        d(!0),
        z.current = !0,
        async function() {
            try {
                await i()
            } catch {
                s()
            } finally {
                d(!1),
                l.current = !1
            }
        }())
    }
    , [A, i, s, D]);
    const K = Y.useCallback(async (p, k, C) => {
        if (!n)
            throw b.current(new P1);
        if (!A)
            throw b.current(new at, n);
        return await n.sendTransaction(p, k, C)
    }
    , [n, A])
      , F = Y.useMemo( () => n && "signTransaction"in n ? async p => {
        if (!A)
            throw b.current(new at, n);
        return await n.signTransaction(p)
    }
    : void 0, [n, A])
      , G = Y.useMemo( () => n && "signAllTransactions"in n ? async p => {
        if (!A)
            throw b.current(new at, n);
        return await n.signAllTransactions(p)
    }
    : void 0, [n, A])
      , Z = Y.useMemo( () => n && "signMessage"in n ? async p => {
        if (!A)
            throw b.current(new at, n);
        return await n.signMessage(p)
    }
    : void 0, [n, A])
      , X = Y.useMemo( () => n && "signIn"in n ? async p => await n.signIn(p) : void 0, [n])
      , T = Y.useCallback(async () => {
        if (l.current || h.current || D?.adapter.connected)
            return;
        if (!D)
            throw b.current(new P1);
        const {adapter: p, readyState: k} = D;
        if (!(k === Re.Installed || k === Re.Loadable))
            throw b.current(new co, p);
        l.current = !0,
        d(!0);
        try {
            await p.connect()
        } catch (C) {
            throw s(),
            C
        } finally {
            d(!1),
            l.current = !1
        }
    }
    , [s, D])
      , u = Y.useCallback(async () => {
        if (!h.current && n) {
            h.current = !0,
            m(!0);
            try {
                await n.disconnect()
            } finally {
                m(!1),
                h.current = !1
            }
        }
    }
    , [n]);
    return J.createElement(OS.Provider, {
        value: {
            autoConnect: !!i,
            wallets: R,
            wallet: D,
            publicKey: v,
            connected: A,
            connecting: c,
            disconnecting: y,
            select: a,
            connect: T,
            disconnect: u,
            sendTransaction: K,
            signTransaction: F,
            signAllTransactions: G,
            signMessage: Z,
            signIn: X
        }
    }, t)
}
let _0;
function mR() {
    return _0 === void 0 && (_0 = globalThis.navigator?.userAgent ?? null),
    _0
}
function Q1(t) {
    const e = mR();
    return fR({
        adapters: t,
        userAgentString: e
    }) === ma.MOBILE_WEB
}
function yR() {
    const t = globalThis.location;
    if (t)
        return `${t.protocol}//${t.host}`
}
function wR({children: t, wallets: e, autoConnect: n, localStorageKey: r="walletName", onError: i}) {
    const {connection: s} = _N()
      , o = uR(e)
      , a = Y.useMemo( () => {
        if (!Q1(o))
            return null;
        const x = o.find(b => b.name === nd);
        return x || new W6({
            addressSelector: F6(),
            appIdentity: {
                uri: yR()
            },
            authorizationResultCache: $6(),
            cluster: pR(s?.rpcEndpoint),
            onWalletNotFound: K6()
        })
    }
    , [o, s?.rpcEndpoint])
      , l = Y.useMemo( () => a == null || o.indexOf(a) !== -1 ? o : [a, ...o], [o, a])
      , [c,d] = BN(r, null)
      , h = Y.useMemo( () => l.find(x => x.name === c) ?? null, [l, c])
      , y = Y.useCallback(x => {
        c !== x && (h && h.name !== nd && h.disconnect(),
        d(x))
    }
    , [h, d, c]);
    Y.useEffect( () => {
        if (!h)
            return;
        function x() {
            E.current || d(null)
        }
        return h.on("disconnect", x),
        () => {
            h.off("disconnect", x)
        }
    }
    , [h, o, d, c]);
    const m = Y.useRef(!1)
      , v = Y.useMemo( () => {
        if (!(!n || !h))
            return async () => {
                (n === !0 || await n(h)) && (m.current ? await h.connect() : await h.autoConnect())
            }
    }
    , [n, h])
      , E = Y.useRef(!1);
    Y.useEffect( () => {
        if (c === nd && Q1(o)) {
            E.current = !1;
            return
        }
        function x() {
            E.current = !0
        }
        return window.addEventListener("beforeunload", x),
        () => {
            window.removeEventListener("beforeunload", x)
        }
    }
    , [o, c]);
    const A = Y.useCallback( () => {
        h && y(null)
    }
    , [h, y])
      , _ = Y.useCallback(x => {
        m.current = !0,
        y(x)
    }
    , [y]);
    return J.createElement(gR, {
        wallets: l,
        adapter: h,
        isUnloadingRef: E,
        onAutoConnectRequest: v,
        onConnectError: A,
        onError: i,
        onSelectWallet: _
    }, t)
}
const Bk = {
    setVisible(t) {
        console.error(Pk("call", "setVisible"))
    },
    visible: !1
};
Object.defineProperty(Bk, "visible", {
    get() {
        return console.error(Pk("read", "visible")),
        !1
    }
});
function Pk(t, e) {
    return `You have tried to  ${t} "${e}" on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext`
}
const Ok = Y.createContext(Bk);
function Dk() {
    return Y.useContext(Ok)
}
function vR({onSelectWallet: t}) {
    const {connect: e, connected: n, connecting: r, disconnect: i, disconnecting: s, publicKey: o, select: a, wallet: l, wallets: c} = DS();
    let d;
    r ? d = "connecting" : n ? d = "connected" : s ? d = "disconnecting" : l ? d = "has-wallet" : d = "no-wallet";
    const h = Y.useCallback( () => {
        e().catch( () => {}
        )
    }
    , [e])
      , y = Y.useCallback( () => {
        i().catch( () => {}
        )
    }
    , [i])
      , m = Y.useCallback( () => {
        t({
            onSelectWallet: a,
            wallets: c
        })
    }
    , [t, a, c]);
    return {
        buttonState: d,
        onConnect: d === "has-wallet" ? h : void 0,
        onDisconnect: d !== "disconnecting" && d !== "no-wallet" ? y : void 0,
        onSelectWallet: m,
        publicKey: o ?? void 0,
        walletIcon: l?.adapter.icon,
        walletName: l?.adapter.name
    }
}
const zk = t => J.createElement("button", {
    className: `wallet-adapter-button ${t.className || ""}`,
    disabled: t.disabled,
    style: t.style,
    onClick: t.onClick,
    tabIndex: t.tabIndex || 0,
    type: "button"
}, t.startIcon && J.createElement("i", {
    className: "wallet-adapter-button-start-icon"
}, t.startIcon), t.children, t.endIcon && J.createElement("i", {
    className: "wallet-adapter-button-end-icon"
}, t.endIcon))
  , Uk = ({wallet: t, ...e}) => t && J.createElement("img", {
    src: t.adapter.icon,
    alt: `${t.adapter.name} icon`,
    ...e
});
function bR({walletIcon: t, walletName: e, ...n}) {
    return J.createElement(zk, {
        ...n,
        className: "wallet-adapter-button-trigger",
        startIcon: t && e ? J.createElement(Uk, {
            wallet: {
                adapter: {
                    icon: t,
                    name: e
                }
            }
        }) : void 0
    })
}
function _R({children: t, labels: e, ...n}) {
    const {setVisible: r} = Dk()
      , {buttonState: i, onConnect: s, onDisconnect: o, publicKey: a, walletIcon: l, walletName: c} = vR({
        onSelectWallet() {
            r(!0)
        }
    })
      , [d,h] = Y.useState(!1)
      , [y,m] = Y.useState(!1)
      , v = Y.useRef(null);
    Y.useEffect( () => {
        const A = _ => {
            const x = v.current;
            !x || x.contains(_.target) || m(!1)
        }
        ;
        return document.addEventListener("mousedown", A),
        document.addEventListener("touchstart", A),
        () => {
            document.removeEventListener("mousedown", A),
            document.removeEventListener("touchstart", A)
        }
    }
    , []);
    const E = Y.useMemo( () => {
        if (t)
            return t;
        if (a) {
            const A = a.toBase58();
            return A.slice(0, 4) + ".." + A.slice(-4)
        } else
            return i === "connecting" || i === "has-wallet" ? e[i] : e["no-wallet"]
    }
    , [i, t, e, a]);
    return J.createElement("div", {
        className: "wallet-adapter-dropdown"
    }, J.createElement(bR, {
        ...n,
        "aria-expanded": y,
        style: {
            pointerEvents: y ? "none" : "auto",
            ...n.style
        },
        onClick: () => {
            switch (i) {
            case "no-wallet":
                r(!0);
                break;
            case "has-wallet":
                s && s();
                break;
            case "connected":
                m(!0);
                break
            }
        }
        ,
        walletIcon: l,
        walletName: c
    }, E), J.createElement("ul", {
        "aria-label": "dropdown-list",
        className: `wallet-adapter-dropdown-list ${y && "wallet-adapter-dropdown-list-active"}`,
        ref: v,
        role: "menu"
    }, a ? J.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: async () => {
            await navigator.clipboard.writeText(a.toBase58()),
            h(!0),
            setTimeout( () => h(!1), 400)
        }
        ,
        role: "menuitem"
    }, d ? e.copied : e["copy-address"]) : null, J.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: () => {
            r(!0),
            m(!1)
        }
        ,
        role: "menuitem"
    }, e["change-wallet"]), o ? J.createElement("li", {
        className: "wallet-adapter-dropdown-list-item",
        onClick: () => {
            o(),
            m(!1)
        }
        ,
        role: "menuitem"
    }, e.disconnect) : null))
}
const J1 = ({id: t, children: e, expanded: n=!1}) => {
    const r = Y.useRef(null)
      , i = Y.useRef(!0)
      , s = "height 250ms ease-out"
      , o = () => {
        const l = r.current;
        l && requestAnimationFrame( () => {
            l.style.height = l.scrollHeight + "px"
        }
        )
    }
      , a = () => {
        const l = r.current;
        l && requestAnimationFrame( () => {
            l.style.height = l.offsetHeight + "px",
            l.style.overflow = "hidden",
            requestAnimationFrame( () => {
                l.style.height = "0"
            }
            )
        }
        )
    }
    ;
    return Y.useLayoutEffect( () => {
        n ? o() : a()
    }
    , [n]),
    Y.useLayoutEffect( () => {
        const l = r.current;
        if (!l)
            return;
        function c() {
            l && (l.style.overflow = n ? "initial" : "hidden",
            n && (l.style.height = "auto"))
        }
        function d(h) {
            l && h.target === l && h.propertyName === "height" && c()
        }
        return i.current && (c(),
        i.current = !1),
        l.addEventListener("transitionend", d),
        () => l.removeEventListener("transitionend", d)
    }
    , [n]),
    J.createElement("div", {
        className: "wallet-adapter-collapse",
        id: t,
        ref: r,
        role: "region",
        style: {
            height: 0,
            transition: i.current ? void 0 : s
        }
    }, e)
}
  , x0 = ({handleClick: t, tabIndex: e, wallet: n}) => J.createElement("li", null, J.createElement(zk, {
    onClick: t,
    startIcon: J.createElement(Uk, {
        wallet: n
    }),
    tabIndex: e
}, n.adapter.name, n.readyState === Re.Installed && J.createElement("span", null, "Detected")))
  , xR = () => J.createElement("svg", {
    width: "97",
    height: "96",
    viewBox: "0 0 97 96",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
}, J.createElement("circle", {
    cx: "48.5",
    cy: "48",
    r: "48",
    fill: "url(#paint0_linear_880_5115)",
    fillOpacity: "0.1"
}), J.createElement("circle", {
    cx: "48.5",
    cy: "48",
    r: "47",
    stroke: "url(#paint1_linear_880_5115)",
    strokeOpacity: "0.4",
    strokeWidth: "2"
}), J.createElement("g", {
    clipPath: "url(#clip0_880_5115)"
}, J.createElement("path", {
    d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
    fill: "url(#paint2_linear_880_5115)"
}), J.createElement("path", {
    d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
    fill: "url(#paint3_linear_880_5115)"
})), J.createElement("defs", null, J.createElement("linearGradient", {
    id: "paint0_linear_880_5115",
    x1: "3.41664",
    y1: "98.0933",
    x2: "103.05",
    y2: "8.42498",
    gradientUnits: "userSpaceOnUse"
}, J.createElement("stop", {
    stopColor: "#9945FF"
}), J.createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), J.createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), J.createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), J.createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), J.createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), J.createElement("linearGradient", {
    id: "paint1_linear_880_5115",
    x1: "3.41664",
    y1: "98.0933",
    x2: "103.05",
    y2: "8.42498",
    gradientUnits: "userSpaceOnUse"
}, J.createElement("stop", {
    stopColor: "#9945FF"
}), J.createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), J.createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), J.createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), J.createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), J.createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), J.createElement("linearGradient", {
    id: "paint2_linear_880_5115",
    x1: "25.9583",
    y1: "68.7101",
    x2: "67.2337",
    y2: "23.7879",
    gradientUnits: "userSpaceOnUse"
}, J.createElement("stop", {
    stopColor: "#9945FF"
}), J.createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), J.createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), J.createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), J.createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), J.createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), J.createElement("linearGradient", {
    id: "paint3_linear_880_5115",
    x1: "58.3326",
    y1: "49.4467",
    x2: "61.0002",
    y2: "45.4453",
    gradientUnits: "userSpaceOnUse"
}, J.createElement("stop", {
    stopColor: "#9945FF"
}), J.createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), J.createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), J.createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), J.createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), J.createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), J.createElement("clipPath", {
    id: "clip0_880_5115"
}, J.createElement("rect", {
    width: "48",
    height: "48",
    fill: "white",
    transform: "translate(24.5 24)"
}))))
  , SR = ({className: t="", container: e="body"}) => {
    const n = Y.useRef(null)
      , {wallets: r, select: i} = DS()
      , {setVisible: s} = Dk()
      , [o,a] = Y.useState(!1)
      , [l,c] = Y.useState(!1)
      , [d,h] = Y.useState(null)
      , [y,m] = Y.useMemo( () => {
        const b = []
          , R = [];
        for (const O of r)
            O.readyState === Re.Installed ? b.push(O) : R.push(O);
        return b.length ? [b, R] : [R, []]
    }
    , [r])
      , v = Y.useCallback( () => {
        c(!1),
        setTimeout( () => s(!1), 150)
    }
    , [s])
      , E = Y.useCallback(b => {
        b.preventDefault(),
        v()
    }
    , [v])
      , A = Y.useCallback( (b, R) => {
        i(R),
        E(b)
    }
    , [i, E])
      , _ = Y.useCallback( () => a(!o), [o])
      , x = Y.useCallback(b => {
        const R = n.current;
        if (!R)
            return;
        const O = R.querySelectorAll("button")
          , D = O[0]
          , z = O[O.length - 1];
        b.shiftKey ? document.activeElement === D && (z.focus(),
        b.preventDefault()) : document.activeElement === z && (D.focus(),
        b.preventDefault())
    }
    , [n]);
    return Y.useLayoutEffect( () => {
        const b = O => {
            O.key === "Escape" ? v() : O.key === "Tab" && x(O)
        }
          , {overflow: R} = window.getComputedStyle(document.body);
        return setTimeout( () => c(!0), 0),
        document.body.style.overflow = "hidden",
        window.addEventListener("keydown", b, !1),
        () => {
            document.body.style.overflow = R,
            window.removeEventListener("keydown", b, !1)
        }
    }
    , [v, x]),
    Y.useLayoutEffect( () => h(document.querySelector(e)), [e]),
    d && O_.createPortal(J.createElement("div", {
        "aria-labelledby": "wallet-adapter-modal-title",
        "aria-modal": "true",
        className: `wallet-adapter-modal ${l && "wallet-adapter-modal-fade-in"} ${t}`,
        ref: n,
        role: "dialog"
    }, J.createElement("div", {
        className: "wallet-adapter-modal-container"
    }, J.createElement("div", {
        className: "wallet-adapter-modal-wrapper"
    }, J.createElement("button", {
        onClick: E,
        className: "wallet-adapter-modal-button-close"
    }, J.createElement("svg", {
        width: "14",
        height: "14"
    }, J.createElement("path", {
        d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z"
    }))), y.length ? J.createElement(J.Fragment, null, J.createElement("h1", {
        className: "wallet-adapter-modal-title"
    }, "Connect a wallet on Solana to continue"), J.createElement("ul", {
        className: "wallet-adapter-modal-list"
    }, y.map(b => J.createElement(x0, {
        key: b.adapter.name,
        handleClick: R => A(R, b.adapter.name),
        wallet: b
    })), m.length ? J.createElement(J1, {
        expanded: o,
        id: "wallet-adapter-modal-collapse"
    }, m.map(b => J.createElement(x0, {
        key: b.adapter.name,
        handleClick: R => A(R, b.adapter.name),
        tabIndex: o ? 0 : -1,
        wallet: b
    }))) : null), m.length ? J.createElement("button", {
        className: "wallet-adapter-modal-list-more",
        onClick: _,
        tabIndex: 0
    }, J.createElement("span", null, o ? "Less " : "More ", "options"), J.createElement("svg", {
        width: "13",
        height: "7",
        viewBox: "0 0 13 7",
        xmlns: "http://www.w3.org/2000/svg",
        className: `${o ? "wallet-adapter-modal-list-more-icon-rotate" : ""}`
    }, J.createElement("path", {
        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
    }))) : null) : J.createElement(J.Fragment, null, J.createElement("h1", {
        className: "wallet-adapter-modal-title"
    }, "You'll need a wallet on Solana to continue"), J.createElement("div", {
        className: "wallet-adapter-modal-middle"
    }, J.createElement(xR, null)), m.length ? J.createElement(J.Fragment, null, J.createElement("button", {
        className: "wallet-adapter-modal-list-more",
        onClick: _,
        tabIndex: 0
    }, J.createElement("span", null, o ? "Hide " : "Already have a wallet? View ", "options"), J.createElement("svg", {
        width: "13",
        height: "7",
        viewBox: "0 0 13 7",
        xmlns: "http://www.w3.org/2000/svg",
        className: `${o ? "wallet-adapter-modal-list-more-icon-rotate" : ""}`
    }, J.createElement("path", {
        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
    }))), J.createElement(J1, {
        expanded: o,
        id: "wallet-adapter-modal-collapse"
    }, J.createElement("ul", {
        className: "wallet-adapter-modal-list"
    }, m.map(b => J.createElement(x0, {
        key: b.adapter.name,
        handleClick: R => A(R, b.adapter.name),
        tabIndex: o ? 0 : -1,
        wallet: b
    }))))) : null))), J.createElement("div", {
        className: "wallet-adapter-modal-overlay",
        onMouseDown: E
    })), d)
}
  , kR = ({children: t, ...e}) => {
    const [n,r] = Y.useState(!1);
    return J.createElement(Ok.Provider, {
        value: {
            visible: n,
            setVisible: r
        }
    }, t, n && J.createElement(SR, {
        ...e
    }))
}
  , ER = {
    "change-wallet": "Change wallet",
    connecting: "Connecting ...",
    "copy-address": "Copy address",
    copied: "Copied",
    disconnect: "Disconnect",
    "has-wallet": "Connect",
    "no-wallet": "Select Wallet"
};
function X1(t) {
    return J.createElement(_R, {
        ...t,
        labels: ER
    })
}
const AR = "Phantom";
class IR extends Mc {
    constructor(e={}) {
        super(),
        this.name = AR,
        this.url = "https://phantom.app",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? Re.Unsupported : Re.NotDetected,
        this._disconnected = () => {
            const n = this._wallet;
            n && (n.off("disconnect", this._disconnected),
            n.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Ec),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = n => {
            const r = this._publicKey;
            if (r) {
                try {
                    n = new ne(n.toBytes())
                } catch (i) {
                    this.emit("error", new uo(i?.message,i));
                    return
                }
                r.equals(n) || (this._publicKey = n,
                this.emit("connect", n))
            }
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Re.Unsupported && (Fd() ? (this._readyState = Re.Loadable,
        this.emit("readyStateChange", this._readyState)) : Bh( () => window.phantom?.solana?.isPhantom || window.solana?.isPhantom ? (this._readyState = Re.Installed,
        this.emit("readyStateChange", this._readyState),
        !0) : !1))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === Re.Installed && await this.connect()
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this.readyState === Re.Loadable) {
                const r = encodeURIComponent(window.location.href)
                  , i = encodeURIComponent(window.location.origin);
                window.location.href = `https://phantom.app/ul/browse/${r}?ref=${i}`;
                return
            }
            if (this.readyState !== Re.Installed)
                throw new co;
            this._connecting = !0;
            const e = window.phantom?.solana || window.solana;
            if (!e.isConnected)
                try {
                    await e.connect()
                } catch (r) {
                    throw new Ta(r?.message,r)
                }
            if (!e.publicKey)
                throw new ki;
            let n;
            try {
                n = new ne(e.publicKey.toBytes())
            } catch (r) {
                throw new uo(r?.message,r)
            }
            e.on("disconnect", this._disconnected),
            e.on("accountChanged", this._accountChanged),
            this._wallet = e,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (e) {
            throw this.emit("error", e),
            e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected),
            e.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await e.disconnect()
            } catch (n) {
                this.emit("error", new Ac(n?.message,n))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(e, n, r={}) {
        try {
            const i = this._wallet;
            if (!i)
                throw new at;
            try {
                const {signers: s, ...o} = r;
                Jr(e) ? s?.length && e.sign(s) : (e = await this.prepareTransaction(e, n, o),
                s?.length && e.partialSign(...s)),
                o.preflightCommitment = o.preflightCommitment || n.commitment;
                const {signature: a} = await i.signAndSendTransaction(e, o);
                return a
            } catch (s) {
                throw s instanceof wt ? s : new Qr(s?.message,s)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
    async signTransaction(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signTransaction(e) || e
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signAllTransactions(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signAllTransactions(e) || e
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signMessage(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                const {signature: r} = await n.signMessage(e);
                return r
            } catch (r) {
                throw new Ic(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
}
const MR = "modulepreload"
  , TR = function(t) {
    return "/" + t
}
  , ev = {}
  , bo = function(e, n, r) {
    if (!n || n.length === 0)
        return e();
    const i = document.getElementsByTagName("link");
    return Promise.all(n.map(s => {
        if (s = TR(s),
        s in ev)
            return;
        ev[s] = !0;
        const o = s.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!r)
            for (let d = i.length - 1; d >= 0; d--) {
                const h = i[d];
                if (h.href === s && (!o || h.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${s}"]${a}`))
            return;
        const c = document.createElement("link");
        if (c.rel = o ? "stylesheet" : MR,
        o || (c.as = "script",
        c.crossOrigin = ""),
        c.href = s,
        document.head.appendChild(c),
        o)
            return new Promise( (d, h) => {
                c.addEventListener("load", d),
                c.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${s}`)))
            }
            )
    }
    )).then( () => e()).catch(s => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
}
  , NR = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
var Fe = globalThis && globalThis.__classPrivateFieldGet || function(t, e, n, r) {
    if (n === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}
, CR = globalThis && globalThis.__classPrivateFieldSet || function(t, e, n, r, i) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}
, od, Qs, vg, bg, _g, Tn, xg, Wk, Fk, Sg, kg, Eg, Ag, Ig;
class RR {
    constructor() {
        od.add(this),
        Qs.set(this, {}),
        vg.set(this, "1.0.0"),
        bg.set(this, "MetaMask"),
        _g.set(this, NR),
        Tn.set(this, null),
        xg.set(this, (e, n) => (Fe(this, Qs, "f")[e]?.push(n) || (Fe(this, Qs, "f")[e] = [n]),
        () => Fe(this, od, "m", Fk).call(this, e, n))),
        Sg.set(this, async () => {
            if (!Fe(this, Tn, "f")) {
                let e;
                try {
                    e = (await bo( () => import("./index-9e1c7ee4.js"), ["assets/index-9e1c7ee4.js", "assets/v4-4a60fe23.js"])).default
                } catch {
                    throw new Error("Unable to load Solflare MetaMask SDK")
                }
                CR(this, Tn, new e, "f"),
                Fe(this, Tn, "f").on("standard_change", n => Fe(this, od, "m", Wk).call(this, "change", n))
            }
            return this.accounts.length || await Fe(this, Tn, "f").connect(),
            {
                accounts: this.accounts
            }
        }
        ),
        kg.set(this, async () => {
            Fe(this, Tn, "f") && await Fe(this, Tn, "f").disconnect()
        }
        ),
        Eg.set(this, async (...e) => {
            if (!Fe(this, Tn, "f"))
                throw new at;
            return await Fe(this, Tn, "f").standardSignAndSendTransaction(...e)
        }
        ),
        Ag.set(this, async (...e) => {
            if (!Fe(this, Tn, "f"))
                throw new at;
            return await Fe(this, Tn, "f").standardSignTransaction(...e)
        }
        ),
        Ig.set(this, async (...e) => {
            if (!Fe(this, Tn, "f"))
                throw new at;
            return await Fe(this, Tn, "f").standardSignMessage(...e)
        }
        )
    }
    get version() {
        return Fe(this, vg, "f")
    }
    get name() {
        return Fe(this, bg, "f")
    }
    get icon() {
        return Fe(this, _g, "f")
    }
    get chains() {
        return [Zr.SOLANA_MAINNET_CHAIN, Zr.SOLANA_DEVNET_CHAIN, Zr.SOLANA_TESTNET_CHAIN]
    }
    get features() {
        return {
            [Tc]: {
                version: "1.0.0",
                connect: Fe(this, Sg, "f")
            },
            [cc]: {
                version: "1.0.0",
                disconnect: Fe(this, kg, "f")
            },
            [Nc]: {
                version: "1.0.0",
                on: Fe(this, xg, "f")
            },
            [Me.SolanaSignAndSendTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: Fe(this, Eg, "f")
            },
            [Me.SolanaSignTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: Fe(this, Ag, "f")
            },
            [Me.SolanaSignMessage]: {
                version: "1.0.0",
                signMessage: Fe(this, Ig, "f")
            }
        }
    }
    get accounts() {
        return Fe(this, Tn, "f") ? Fe(this, Tn, "f").standardAccounts : []
    }
}
Qs = new WeakMap,
vg = new WeakMap,
bg = new WeakMap,
_g = new WeakMap,
Tn = new WeakMap,
xg = new WeakMap,
Sg = new WeakMap,
kg = new WeakMap,
Eg = new WeakMap,
Ag = new WeakMap,
Ig = new WeakMap,
od = new WeakSet,
Wk = function(e, ...n) {
    Fe(this, Qs, "f")[e]?.forEach(r => r.apply(null, n))
}
,
Fk = function(e, n) {
    Fe(this, Qs, "f")[e] = Fe(this, Qs, "f")[e]?.filter(r => n !== r)
}
;
let tv = !1;
function LR() {
    tv || (q6(new RR),
    tv = !0)
}
async function jR() {
    const t = "solflare-detect-metamask";
    function e() {
        window.postMessage({
            target: "metamask-contentscript",
            data: {
                name: "metamask-provider",
                data: {
                    id: t,
                    jsonrpc: "2.0",
                    method: "wallet_getSnaps"
                }
            }
        }, window.location.origin)
    }
    function n(r) {
        const i = r.data;
        i?.target === "metamask-inpage" && i.data?.name === "metamask-provider" && (i.data.data?.id === t ? (window.removeEventListener("message", n),
        i.data.data.error || LR()) : e())
    }
    window.addEventListener("message", n),
    window.setTimeout( () => window.removeEventListener("message", n), 5e3),
    e()
}
const BR = "Solflare";
class PR extends Mc {
    constructor(e={}) {
        super(),
        this.name = BR,
        this.url = "https://solflare.com",
        this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJTIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMjA1MGE7c3Ryb2tlOiNmZmVmNDY7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLXdpZHRoOi41cHg7fS5jbHMtMntmaWxsOiNmZmVmNDY7fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJjbHMtMiIgeD0iMCIgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiByeD0iMTIiIHJ5PSIxMiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTI0LjIzLDI2LjQybDIuNDYtMi4zOCw0LjU5LDEuNWMzLjAxLDEsNC41MSwyLjg0LDQuNTEsNS40MywwLDEuOTYtLjc1LDMuMjYtMi4yNSw0LjkzbC0uNDYuNS4xNy0xLjE3Yy42Ny00LjI2LS41OC02LjA5LTQuNzItNy40M2wtNC4zLTEuMzhoMFpNMTguMDUsMTEuODVsMTIuNTIsNC4xNy0yLjcxLDIuNTktNi41MS0yLjE3Yy0yLjI1LS43NS0zLjAxLTEuOTYtMy4zLTQuNTF2LS4wOGgwWk0xNy4zLDMzLjA2bDIuODQtMi43MSw1LjM0LDEuNzVjMi44LjkyLDMuNzYsMi4xMywzLjQ2LDUuMThsLTExLjY1LTQuMjJoMFpNMTMuNzEsMjAuOTVjMC0uNzkuNDItMS41NCwxLjEzLTIuMTcuNzUsMS4wOSwyLjA1LDIuMDUsNC4wOSwyLjcxbDQuNDIsMS40Ni0yLjQ2LDIuMzgtNC4zNC0xLjQyYy0yLS42Ny0yLjg0LTEuNjctMi44NC0yLjk2TTI2LjgyLDQyLjg3YzkuMTgtNi4wOSwxNC4xMS0xMC4yMywxNC4xMS0xNS4zMiwwLTMuMzgtMi01LjI2LTYuNDMtNi43MmwtMy4zNC0xLjEzLDkuMTQtOC43Ny0xLjg0LTEuOTYtMi43MSwyLjM4LTEyLjgxLTQuMjJjLTMuOTcsMS4yOS04Ljk3LDUuMDktOC45Nyw4Ljg5LDAsLjQyLjA0LjgzLjE3LDEuMjktMy4zLDEuODgtNC42MywzLjYzLTQuNjMsNS44LDAsMi4wNSwxLjA5LDQuMDksNC41NSw1LjIybDIuNzUuOTItOS41Miw5LjE0LDEuODQsMS45NiwyLjk2LTIuNzEsMTQuNzMsNS4yMmgwWiIvPjwvc3ZnPg==",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? Re.Unsupported : Re.Loadable,
        this._disconnected = () => {
            const n = this._wallet;
            n && (n.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Ec),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = n => {
            if (!n)
                return;
            const r = this._publicKey;
            if (r) {
                try {
                    n = new ne(n.toBytes())
                } catch (i) {
                    this.emit("error", new uo(i?.message,i));
                    return
                }
                r.equals(n) || (this._publicKey = n,
                this.emit("connect", n))
            }
        }
        ,
        this._connecting = !1,
        this._publicKey = null,
        this._wallet = null,
        this._config = e,
        this._readyState !== Re.Unsupported && (Bh( () => window.solflare?.isSolflare || window.SolflareApp ? (this._readyState = Re.Installed,
        this.emit("readyStateChange", this._readyState),
        !0) : !1),
        jR())
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.connected
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === Re.Loadable && Fd() || await this.connect()
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Re.Loadable && this._readyState !== Re.Installed)
                throw new co;
            if (this.readyState === Re.Loadable && Fd()) {
                const i = encodeURIComponent(window.location.href)
                  , s = encodeURIComponent(window.location.origin);
                window.location.href = `https://solflare.com/ul/v1/browse/${i}?ref=${s}`;
                return
            }
            let e;
            try {
                e = (await bo( () => import("./index-c3d4972b.js"), ["assets/index-c3d4972b.js", "assets/v4-4a60fe23.js"])).default
            } catch (i) {
                throw new jS(i?.message,i)
            }
            let n;
            try {
                n = new e({
                    network: this._config.network
                })
            } catch (i) {
                throw new Hs(i?.message,i)
            }
            if (this._connecting = !0,
            !n.connected)
                try {
                    await n.connect()
                } catch (i) {
                    throw new Ta(i?.message,i)
                }
            if (!n.publicKey)
                throw new Ta;
            let r;
            try {
                r = new ne(n.publicKey.toBytes())
            } catch (i) {
                throw new uo(i?.message,i)
            }
            n.on("disconnect", this._disconnected),
            n.on("accountChanged", this._accountChanged),
            this._wallet = n,
            this._publicKey = r,
            this.emit("connect", r)
        } catch (e) {
            throw this.emit("error", e),
            e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected),
            e.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await e.disconnect()
            } catch (n) {
                this.emit("error", new Ac(n?.message,n))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(e, n, r={}) {
        try {
            const i = this._wallet;
            if (!i)
                throw new at;
            try {
                const {signers: s, ...o} = r;
                return Jr(e) ? s?.length && e.sign(s) : (e = await this.prepareTransaction(e, n, o),
                s?.length && e.partialSign(...s)),
                o.preflightCommitment = o.preflightCommitment || n.commitment,
                await i.signAndSendTransaction(e, o)
            } catch (s) {
                throw s instanceof wt ? s : new Qr(s?.message,s)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
    async signTransaction(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signTransaction(e) || e
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signAllTransactions(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signAllTransactions(e) || e
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signMessage(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signMessage(e, "utf8")
            } catch (r) {
                throw new Ic(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
}
const OR = "Backpack";
class DR extends Mc {
    constructor(e={}) {
        super(),
        this.name = OR,
        this.url = "https://backpack.app",
        this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbvSURBVHgB7Z1dUtxGEMf/LZH3fU0V4PUJQg4QVj5BnBOAT2BzAsMJAicwPoHJCRDrAxifgLVxVV73ObDqdEtsjKn4C8+0NDv9e7AxprRC85uvnp4RYYW5qKpxCVTcYKsgfiDfGjMwIsZIvh7d/lkmzAiYy5fzhultyZhdlagf1vU5VhjCiiGFXq01zYSJdqWgx/hB5AHN5I/6iuilyFBjxVgZAdqCZ34ORoVIqAzSOhxsvq6PsSIkL4A281LwL2IW/F1UhLKgRz/X9QyJUyBhuuae31gWviLjiPF1wxeX29vPkTjJtgAftrd3GHSMnmHw4eZ0uodESVKAoRT+kpQlSE6Ats/XZv/ONK5vZHC49+B1fYjESG4MUDKfYmCFr0ic4fmHqtpCYiQlgA66QsztIzFi5j+RGMl0AXebfgn0aOTuvGG8owIarZsXOj3ronlRuEYnn84CJLo4Lgi/QL/H/LHmy/RwI6GA0RoS4acFHi8kGieFXS/QhmijFfQXmH3uPy5lSkoLbIkYlfyzhuM4juM4juM4juMMj6TzATQ4JH9tlRqFk8BM2aV9RWHB9K5kzK/KLui0KqliSQmgBa4BIS54cpMD0OeawFye3jk19JdKkWq62OAFkEIfrTXNUxBV1okf38Ot3MGjlFqHwQrQZvQ22Cfw7xjg6t8XkZaBGzpKIXdwcAJojZeCP5SC30HipJBEOigBZLn3qdzSPlKr8V9hyEmkgxCgj8zefuD9jen0AAOidwE0i6ZhfjXgRI+gDK016DUjqE3ubPhNLoWvaDLJouHToaSP9SbA0DJ7LekyiviNPgP0TC9dQM6FfxeZ7eyuT6cv0RPmAmjTx11uXx/MiegEDd425cfcwWV+H4O3+uiO+pTAVIA2uMN8av6QiWr5TQ++JVlTc/tEiF3jOMScZGC43kME0VSA95PJhWXhM+Gt1Phn98nStZa1r9mB2SDQPqefjhayfnDfFG2J5882z84eynVM5u3thlONhRhj0gLc5PRfwAw62JjW+wjE5Xa1L0VkshO4kXt/EPDev4ZJCyBRvlcwggjHG4EfYHc9OoIBBWy3mEUX4H1V7Ur7ZvILaT8qy7FRduleF9jXc4RggOUWs/gtANs0nYquvMXaMaTXlQHlE1ggayLvf5OKY0DUMYDWfmpsBjZa+9enOmiLy+VkcmqxaNW2ZgX9GnsLXNQWoGj4KYzQ2g8LyG5WUDR4hshEE6CN+AFmg5lFiRMYcI0uKRQGyIAwegWKJkBjYO8tzq12C7efQ7CK2I00MomIxOsCiCcwQhaW3sEQ6W7sPi/yIDqKAHp8m2nIF7COoc9ghQw4NU8SkYgiQCmLKXCCUSziPc84XYBh83/DSiWR3qUo2tT4ONdGYDTub73cSzD/PNt0rojdQHAByoXxw0E7XfoFhsjnRduD+DnWIkkXXACJl1cwRoMmf3cbRaOjLRzDXnKZVj9GBIILUJBtbVzyj9HAU19AgR6I9VzDtwCgMXpAo2Yxp0v/Ybi49ennJtIFEPMY/TCKHTvv+aTSUQzBgwrQ92YHbQVi3UN3GAVZhrf/jzECE1SAq/7n4yOJ074KPSBcJoii598vxgwrqAByg70HZJZbr0JJ0G5XZz5Z1e1rYccA5TAicqEk0O5ECl/3LvYys7mLTLHHCEzS7wz6Esv3+nyYTF58rwha63XAl8PG1aCnhesWq6EdOcKM3WvmXRHh+Gvv/tNVTJlJPC4a3RVEK72+sCSZ4+J/FBVhTUS43J7gJqFjrnl33A3sxtCa3nAWhX6bbAT4hJugCsNZ2TGA8224AJnjAmSOC5A5LkDmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnjAmSOC5A5LkDmuACZ4wJkjguQOWEFYJvz85xwBBWgKM1P68oKKsI/36ACdC9nsDlWPTsIJ5t1Hfw01OBjgI1p/YwLegIibw0CwESz9gUYZ2d/wHEcx3Ecx3Ecx3Ecx3HuS5QjfdrXxTHv3JzEkd2xKwHR9xPNuKGjzdf1MSIQXAA9XUsuuw8nKPpK3PWzs+AvrgwqgP1LojOjoEf3fRv6Zy+JgBSLOGfaOx1NE/6o+rCrgeT9fWp4SljmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnjAmSOC5A5LkDmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnj5wRmTlABqHQBohKhggUVYAEEP8fO+UiMgziDCvCwrnU3aw0nOATMQu8LVIIPAq+JdAerdwWBaQ/fjEBwAaQVmMnN7sEJCB3EqP3tlRGJy6qqmPkFMcZw7sucmfZiHQ6hRBNgSXdaCHbA7KeFfBvz9pxlxtl1gcN2XBWRfwHK959XFRG6AgAAAABJRU5ErkJggg==",
        this.supportedTransactionVersions = null,
        this._readyState = typeof window > "u" || typeof document > "u" ? Re.Unsupported : Re.NotDetected,
        this._disconnected = () => {
            const n = this._wallet;
            n && (n.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Ec),
            this.emit("disconnect"))
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Re.Unsupported && Bh( () => window.backpack?.isBackpack ? (this._readyState = Re.Installed,
        this.emit("readyStateChange", this._readyState),
        !0) : !1)
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.isConnected
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Re.Installed)
                throw new co;
            this._connecting = !0;
            const e = window.backpack;
            try {
                await e.connect()
            } catch (r) {
                throw new Ta(r?.message,r)
            }
            if (!e.publicKey)
                throw new ki;
            let n;
            try {
                n = new ne(e.publicKey.toBytes())
            } catch (r) {
                throw new uo(r?.message,r)
            }
            e.on("disconnect", this._disconnected),
            this._wallet = e,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (e) {
            throw this.emit("error", e),
            e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null;
            try {
                await e.disconnect()
            } catch (n) {
                this.emit("error", new Ac(n?.message,n))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(e, n, r={}) {
        try {
            const i = this._wallet;
            if (!i)
                throw new at;
            const {signers: s, ...o} = r;
            try {
                return await i.send(e, s, o, n, this.publicKey)
            } catch (a) {
                throw new Qr(a?.message,a)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
    async signTransaction(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signTransaction(e, this.publicKey)
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signAllTransactions(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signAllTransactions(e, this.publicKey)
            } catch (r) {
                throw new ir(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
    async signMessage(e) {
        try {
            const n = this._wallet;
            if (!n)
                throw new at;
            try {
                return await n.signMessage(e, this.publicKey)
            } catch (r) {
                throw new Ic(r?.message,r)
            }
        } catch (n) {
            throw this.emit("error", n),
            n
        }
    }
}
const zR = ({children: t}) => {
    console.log("🔗 WalletContextProvider initializing…");
    const e = Y.useMemo( () => "https://api.devnet.solana.com" || "https://api.devnet.solana.com", [])
      , n = Y.useMemo( () => [new IR, new PR, new DR], []);
    return console.log("✅ Using Solana endpoint:", e),
    S.jsx(xN, {
        endpoint: e,
        children: S.jsx(wR, {
            wallets: n,
            autoConnect: !0,
            children: S.jsx(kR, {
                children: t
            })
        })
    })
}
;
var $k = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , nv = J.createContext && J.createContext($k)
  , UR = ["attr", "size", "title"];
function WR(t, e) {
    if (t == null)
        return {};
    var n = FR(t, e), r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++)
            r = s[i],
            !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}
function FR(t, e) {
    if (t == null)
        return {};
    var n = {};
    for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
            if (e.indexOf(r) >= 0)
                continue;
            n[r] = t[r]
        }
    return n
}
function Qd() {
    return Qd = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    Qd.apply(this, arguments)
}
function rv(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function Jd(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? rv(Object(n), !0).forEach(function(r) {
            $R(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : rv(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}
function $R(t, e, n) {
    return e = KR(e),
    e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
function KR(t) {
    var e = VR(t, "string");
    return typeof e == "symbol" ? e : e + ""
}
function VR(t, e) {
    if (typeof t != "object" || !t)
        return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}
function Kk(t) {
    return t && t.map( (e, n) => J.createElement(e.tag, Jd({
        key: n
    }, e.attr), Kk(e.child)))
}
function xs(t) {
    return e => J.createElement(HR, Qd({
        attr: Jd({}, t.attr)
    }, e), Kk(t.child))
}
function HR(t) {
    var e = n => {
        var {attr: r, size: i, title: s} = t, o = WR(t, UR), a = i || n.size || "1em", l;
        return n.className && (l = n.className),
        t.className && (l = (l ? l + " " : "") + t.className),
        J.createElement("svg", Qd({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, n.attr, r, o, {
            className: l,
            style: Jd(Jd({
                color: t.color || n.color
            }, n.style), t.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg"
        }), s && J.createElement("title", null, s), t.children)
    }
    ;
    return nv !== void 0 ? J.createElement(nv.Consumer, null, n => e(n)) : e($k)
}
function iv(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.305 2.305 0 01-.567-.267C8.07 8.34 8 8.114 8 8c0-.114.07-.34.433-.582zM11 12.849v-1.698c.22.071.412.164.567.267.364.243.433.468.433.582 0 .114-.07.34-.433.582a2.305 2.305 0 01-.567.267z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 7.009 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.51 1.31c.562.649 1.413 1.076 2.353 1.253V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.511-1.31c-.563-.649-1.413-1.076-2.354-1.253V5z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(t)
}
function sv(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(t)
}
function qR(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(t)
}
function ov(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(t)
}
function av(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(t)
}
function Xd(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"
            },
            child: []
        }]
    })(t)
}
function eh(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"
            },
            child: []
        }]
    })(t)
}
function GR(t) {
    return xs({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z"
            },
            child: []
        }]
    })(t)
}
const Ay = "Gr1PWUXKBvEWN3d67d3FxvBmawjCtA5HWqfnJxSgDz1F";
async function Iy() {
    try {
        const t = typeof window > "u" ? {}.NEXT_PUBLIC_SITE_URL || "https://bonkeez.com" : ""
          , e = await fetch(`${t}/api/pumpfun/${Ay}`);
        if (!e.ok)
            throw new Error(`Failed to fetch BNKZ token data (status ${e.status})`);
        return await e.json()
    } catch (t) {
        return console.error("Error fetching BNKZ token data:", t),
        {
            price: "$0.000001",
            marketCap: "N/A",
            volume24h: "N/A",
            holders: "N/A",
            totalSupply: "1B",
            change24h: 0
        }
    }
}
function Vk() {
    return `https://pump.fun/${Ay}`
}
function YR() {
    return `https://solscan.io/token/${Ay}?cluster=mainnet-beta`
}
const ZR = () => {
    const [t,e] = Y.useState(!1)
      , [n,r] = Y.useState(null);
    Y.useEffect( () => {
        const o = async () => {
            const l = await Iy();
            r(l)
        }
        ;
        o();
        const a = setInterval(o, 3e4);
        return () => clearInterval(a)
    }
    , []);
    const i = o => {
        const a = document.getElementById(o);
        a && (a.scrollIntoView({
            behavior: "smooth"
        }),
        e(!1))
    }
      , s = o => {
        const l = {
            twitter: "https://x.com/abonkcommunity?s=21",
            telegram: "https://t.me/+Mh9YQsnnRcZlNWFh"
        }[o];
        l && window.open(l, "_blank", "noopener,noreferrer"),
        e(!1)
    }
    ;
    return S.jsxs(S.Fragment, {
        children: [S.jsx("header", {
            className: "bg-black/60 backdrop-blur-md border-b border-white/20 sticky top-0 z-50",
            children: S.jsx("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
                children: S.jsxs("div", {
                    className: "flex justify-between items-center h-16",
                    children: [S.jsxs("button", {
                        onClick: () => window.scrollTo({
                            top: 0,
                            behavior: "smooth"
                        }),
                        className: "flex items-center space-x-3 hover:opacity-80 transition-opacity duration-150",
                        children: [S.jsx("img", {
                            src: "/bonk.JPG",
                            alt: "Bonkeez Logo",
                            className: "w-12 h-12 rounded-full object-cover shadow-lg border-2 border-pink-500/30"
                        }), S.jsxs("div", {
                            children: [S.jsx("h1", {
                                className: "text-white font-bold text-xl",
                                children: "Bonkeez"
                            }), S.jsx("p", {
                                className: "text-pink-300 text-xs",
                                children: "NFT Exchange"
                            })]
                        })]
                    }), S.jsxs("nav", {
                        className: "hidden xl:flex items-center space-x-6",
                        children: [S.jsx("button", {
                            onClick: () => i("marketplace"),
                            className: "text-white hover:text-pink-400 font-medium text-sm",
                            children: "Marketplace"
                        }), S.jsx("button", {
                            onClick: () => i("stats"),
                            className: "text-white hover:text-yellow-400 font-medium text-sm",
                            children: "Stats"
                        }), S.jsx("button", {
                            onClick: () => i("minting"),
                            className: "text-white hover:text-purple-400 font-medium text-sm",
                            children: "NFT Minting"
                        }), S.jsxs("button", {
                            onClick: () => i("token"),
                            className: "text-white hover:text-blue-400 flex items-center space-x-1 font-medium text-sm",
                            children: [S.jsx(iv, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "$BNKZ Trading"
                            })]
                        }), S.jsxs("button", {
                            onClick: () => i("profile"),
                            className: "text-white hover:text-green-400 flex items-center space-x-1 font-medium text-sm",
                            children: [S.jsx(ov, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "Profile"
                            })]
                        }), S.jsxs("a", {
                            href: "/Bonkeez Whitepaper (1).pdf",
                            download: !0,
                            className: "text-white hover:text-red-400 flex items-center space-x-1 font-medium text-sm",
                            children: [S.jsx(sv, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "Whitepaper"
                            })]
                        })]
                    }), S.jsxs("div", {
                        className: "flex items-center space-x-4",
                        children: [S.jsxs("div", {
                            className: "hidden lg:flex items-center bg-gradient-to-r from-pink-500/20 to-purple-500/20 border border-pink-400/30 rounded-lg px-3 py-2 backdrop-blur-sm",
                            children: [S.jsx("img", {
                                src: "/bonk.JPG",
                                alt: "Bonk",
                                className: "w-5 h-5 rounded-full object-cover mr-2"
                            }), S.jsxs("div", {
                                className: "text-right",
                                children: [S.jsx("p", {
                                    className: "text-pink-300 font-bold text-xs",
                                    children: n?.price || "$0.0001"
                                }), S.jsx("p", {
                                    className: `text-xs ${(n?.change24h || 0) >= 0 ? "text-green-400" : "text-red-400"}`,
                                    children: n?.change24h ? `${n.change24h >= 0 ? "+" : ""}${n.change24h.toFixed(1)}%` : "+0.0%"
                                })]
                            })]
                        }), S.jsx("div", {
                            className: "hidden md:flex items-center space-x-3",
                            children: S.jsx(X1, {
                                className: "bg-gradient-to-r from-pink-500 via-purple-500 to-blue-500 text-white px-4 py-2 rounded-lg hover:from-pink-600 hover:via-purple-600 hover:to-blue-600 transition-all duration-150 shadow-lg border border-pink-400/30 text-sm font-medium"
                            })
                        }), S.jsx("button", {
                            className: "md:hidden text-white p-2 rounded-lg hover:bg-white/10 transition-colors duration-150 relative",
                            onClick: () => e(!t),
                            children: t ? S.jsx(av, {
                                className: "w-6 h-6"
                            }) : S.jsx(qR, {
                                className: "w-6 h-6"
                            })
                        })]
                    })]
                })
            })
        }), t && S.jsxs("div", {
            className: "fixed inset-0 z-[60] md:hidden flex flex-col bg-black/60 backdrop-blur-xl pt-20",
            children: [S.jsx("button", {
                onClick: () => e(!1),
                className: "absolute top-6 right-6 text-white p-2 rounded-lg hover:bg-white/10 transition-colors duration-150",
                children: S.jsx(av, {
                    className: "w-7 h-7"
                })
            }), S.jsxs("div", {
                className: "flex flex-col items-center px-6 py-6 h-full justify-between",
                children: [S.jsxs("nav", {
                    className: "flex flex-col items-center space-y-5",
                    children: [S.jsx("button", {
                        onClick: () => i("marketplace"),
                        className: "text-white hover:text-pink-400 font-semibold text-lg",
                        children: "Marketplace"
                    }), S.jsx("button", {
                        onClick: () => i("stats"),
                        className: "text-white hover:text-yellow-400 font-semibold text-lg",
                        children: "Stats"
                    }), S.jsx("button", {
                        onClick: () => i("minting"),
                        className: "text-white hover:text-purple-400 font-semibold text-lg",
                        children: "NFT Minting"
                    }), S.jsxs("button", {
                        onClick: () => i("token"),
                        className: "text-white hover:text-blue-400 flex items-center space-x-2 font-semibold text-lg",
                        children: [S.jsx(iv, {
                            className: "w-5 h-5"
                        }), S.jsx("span", {
                            children: "$BNKZ Trading"
                        })]
                    }), S.jsxs("button", {
                        onClick: () => i("profile"),
                        className: "text-white hover:text-green-400 flex items-center space-x-2 font-semibold text-lg",
                        children: [S.jsx(ov, {
                            className: "w-5 h-5"
                        }), S.jsx("span", {
                            children: "Profile"
                        })]
                    }), S.jsxs("a", {
                        href: "/Bonkeez Whitepaper (1).pdf",
                        download: !0,
                        onClick: () => e(!1),
                        className: "text-white hover:text-red-400 flex items-center space-x-2 font-semibold text-lg",
                        children: [S.jsx(sv, {
                            className: "w-5 h-5"
                        }), S.jsx("span", {
                            children: "Whitepaper"
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "flex flex-col items-center space-y-4",
                    children: [S.jsxs("div", {
                        className: "flex items-center bg-gradient-to-r from-pink-500/20 to-purple-500/20 border border-pink-400/30 rounded-lg px-3 py-2",
                        children: [S.jsx("img", {
                            src: "/bonk.JPG",
                            alt: "Bonk",
                            className: "w-6 h-6 rounded-full object-cover mr-2"
                        }), S.jsxs("div", {
                            children: [S.jsx("p", {
                                className: "text-pink-300 font-bold text-sm",
                                children: n?.price || "$0.0001"
                            }), S.jsx("p", {
                                className: `text-xs ${(n?.change24h || 0) >= 0 ? "text-green-400" : "text-red-400"}`,
                                children: n?.change24h ? `${n.change24h >= 0 ? "+" : ""}${n.change24h.toFixed(1)}%` : "+0.0%"
                            })]
                        })]
                    }), S.jsx(X1, {
                        className: "bg-gradient-to-r from-pink-500 via-purple-500 to-blue-500 text-white px-4 py-1.5 rounded-lg text-sm font-medium"
                    }), S.jsxs("div", {
                        className: "flex space-x-6",
                        children: [S.jsx("button", {
                            onClick: () => s("twitter"),
                            className: "text-slate-300 hover:text-emerald-400 transition-colors",
                            children: S.jsx(eh, {
                                className: "w-6 h-6"
                            })
                        }), S.jsx("button", {
                            onClick: () => s("telegram"),
                            className: "text-slate-300 hover:text-emerald-400 transition-colors",
                            children: S.jsx(Xd, {
                                className: "w-6 h-6"
                            })
                        })]
                    })]
                })]
            })]
        })]
    })
}
;
var QR = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
const JR = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , XR = (t, e) => {
    const n = Y.forwardRef( ({color: r="currentColor", size: i=24, strokeWidth: s=2, absoluteStrokeWidth: o, children: a, ...l}, c) => Y.createElement("svg", {
        ref: c,
        ...QR,
        width: i,
        height: i,
        stroke: r,
        strokeWidth: o ? Number(s) * 24 / Number(i) : s,
        className: `lucide lucide-${JR(t)}`,
        ...l
    }, [...e.map( ([d,h]) => Y.createElement(d, h)), ...(Array.isArray(a) ? a : [a]) || []]));
    return n.displayName = `${t}`,
    n
}
;
var nn = XR;
const e5 = nn("AlertTriangle", [["path", {
    d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z",
    key: "c3ski4"
}], ["path", {
    d: "M12 9v4",
    key: "juzpu7"
}], ["path", {
    d: "M12 17h.01",
    key: "p32p05"
}]])
  , t5 = nn("ArrowRight", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "m12 5 7 7-7 7",
    key: "xquz4c"
}]])
  , n5 = nn("ArrowUpDown", [["path", {
    d: "m21 16-4 4-4-4",
    key: "f6ql7i"
}], ["path", {
    d: "M17 20V4",
    key: "1ejh1v"
}], ["path", {
    d: "m3 8 4-4 4 4",
    key: "11wl7u"
}], ["path", {
    d: "M7 4v16",
    key: "1glfcx"
}]])
  , r5 = nn("Bell", [["path", {
    d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9",
    key: "1qo2s2"
}], ["path", {
    d: "M10.3 21a1.94 1.94 0 0 0 3.4 0",
    key: "qgo35s"
}]])
  , i5 = nn("CheckCircle", [["path", {
    d: "M22 11.08V12a10 10 0 1 1-5.93-9.14",
    key: "g774vq"
}], ["polyline", {
    points: "22 4 12 14.01 9 11.01",
    key: "6xbx8j"
}]])
  , s5 = nn("Clock", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["polyline", {
    points: "12 6 12 12 16 14",
    key: "68esgv"
}]])
  , o5 = nn("Coins", [["circle", {
    cx: "8",
    cy: "8",
    r: "6",
    key: "3yglwk"
}], ["path", {
    d: "M18.09 10.37A6 6 0 1 1 10.34 18",
    key: "t5s6rm"
}], ["path", {
    d: "M7 6h1v4",
    key: "1obek4"
}], ["path", {
    d: "m16.71 13.88.7.71-2.82 2.82",
    key: "1rbuyh"
}]])
  , Hk = nn("DollarSign", [["line", {
    x1: "12",
    x2: "12",
    y1: "2",
    y2: "22",
    key: "7eqyqh"
}], ["path", {
    d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6",
    key: "1b0p4s"
}]])
  , Mg = nn("ExternalLink", [["path", {
    d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
    key: "a6xqqp"
}], ["polyline", {
    points: "15 3 21 3 21 9",
    key: "mznyad"
}], ["line", {
    x1: "10",
    x2: "21",
    y1: "14",
    y2: "3",
    key: "18c3s4"
}]])
  , a5 = nn("Filter", [["polygon", {
    points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3",
    key: "1yg77f"
}]])
  , l5 = nn("Grid", [["rect", {
    width: "18",
    height: "18",
    x: "3",
    y: "3",
    rx: "2",
    ry: "2",
    key: "1m3agn"
}], ["line", {
    x1: "3",
    x2: "21",
    y1: "9",
    y2: "9",
    key: "1vqk6q"
}], ["line", {
    x1: "3",
    x2: "21",
    y1: "15",
    y2: "15",
    key: "o2sbyz"
}], ["line", {
    x1: "9",
    x2: "9",
    y1: "3",
    y2: "21",
    key: "13tij5"
}], ["line", {
    x1: "15",
    x2: "15",
    y1: "3",
    y2: "21",
    key: "1hpv9i"
}]])
  , c5 = nn("List", [["line", {
    x1: "8",
    x2: "21",
    y1: "6",
    y2: "6",
    key: "7ey8pc"
}], ["line", {
    x1: "8",
    x2: "21",
    y1: "12",
    y2: "12",
    key: "rjfblc"
}], ["line", {
    x1: "8",
    x2: "21",
    y1: "18",
    y2: "18",
    key: "c3b1m8"
}], ["line", {
    x1: "3",
    x2: "3.01",
    y1: "6",
    y2: "6",
    key: "1g7gq3"
}], ["line", {
    x1: "3",
    x2: "3.01",
    y1: "12",
    y2: "12",
    key: "1pjlvk"
}], ["line", {
    x1: "3",
    x2: "3.01",
    y1: "18",
    y2: "18",
    key: "28t2mc"
}]])
  , u5 = nn("Search", [["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["path", {
    d: "m21 21-4.3-4.3",
    key: "1qie3q"
}]])
  , d5 = nn("Settings", [["path", {
    d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
    key: "1qme2f"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "3",
    key: "1v7zrd"
}]])
  , h5 = nn("Star", [["polygon", {
    points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
    key: "8f66p6"
}]])
  , qk = nn("TrendingUp", [["polyline", {
    points: "22 7 13.5 15.5 8.5 10.5 2 17",
    key: "126l90"
}], ["polyline", {
    points: "16 7 22 7 22 13",
    key: "kwv8wd"
}]])
  , Gk = nn("Users", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["path", {
    d: "M22 21v-2a4 4 0 0 0-3-3.87",
    key: "kshegd"
}], ["path", {
    d: "M16 3.13a4 4 0 0 1 0 7.75",
    key: "1da9ce"
}]])
  , f5 = nn("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]])
  , jl = nn("Zap", [["polygon", {
    points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2",
    key: "45s27k"
}]])
  , p5 = () => {
    const t = () => {
        const n = document.getElementById("marketplace");
        n && n.scrollIntoView({
            behavior: "smooth"
        })
    }
      , e = () => {
        const n = document.getElementById("token");
        n && n.scrollIntoView({
            behavior: "smooth"
        })
    }
    ;
    return S.jsxs("section", {
        className: "relative py-20 px-4 sm:px-6 lg:px-8 overflow-hidden",
        children: [S.jsx("div", {
            className: "absolute inset-0 bg-gradient-to-br from-yellow-400/8 via-transparent to-green-400/8"
        }), S.jsx("div", {
            className: "absolute top-1/4 left-1/4 w-96 h-96 bg-pink-400/6 rounded-full blur-3xl"
        }), S.jsx("div", {
            className: "absolute bottom-1/4 right-1/4 w-96 h-96 bg-blue-400/6 rounded-full blur-3xl"
        }), S.jsxs("div", {
            className: "relative max-w-7xl mx-auto",
            children: [S.jsxs("div", {
                className: "text-center mb-16",
                children: [S.jsxs("div", {
                    className: "inline-flex items-center bg-purple-400/20 text-purple-400 px-6 py-3 rounded-full text-lg font-bold mb-8",
                    children: [S.jsx(jl, {
                        className: "w-5 h-5 mr-2"
                    }), "Pre-Launch • Collection Ready"]
                }), S.jsxs("h1", {
                    className: "text-3xl sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl font-bold text-white mb-4 sm:mb-6 leading-tight px-2",
                    children: ["Welcome to", S.jsx("span", {
                        className: "block bg-gradient-to-r from-purple-400 to-slate-300 bg-clip-text text-transparent",
                        children: "Bonkeez Exchange"
                    })]
                }), S.jsx("p", {
                    className: "text-base sm:text-lg md:text-xl lg:text-2xl text-slate-300 mb-6 sm:mb-8 max-w-4xl mx-auto leading-relaxed px-4",
                    children: "The premier NFT marketplace for the Bonkeez collection on Solana. Trade with $BNKZ tokens and unlock exclusive benefits."
                }), S.jsxs("div", {
                    className: "flex flex-col sm:flex-row gap-4 sm:gap-6 justify-center mb-8 sm:mb-12 px-4",
                    children: [S.jsxs("button", {
                        onClick: t,
                        className: "bg-gradient-to-r from-purple-600 to-purple-700 text-white px-6 sm:px-8 py-3 sm:py-4 rounded-xl font-bold hover:from-purple-700 hover:to-purple-800 transition-all duration-150 flex items-center justify-center space-x-2 shadow-lg hover:shadow-purple-500/25 text-base sm:text-lg",
                        children: [S.jsx("span", {
                            children: "Explore Collection"
                        }), S.jsx(t5, {
                            className: "w-4 h-4 sm:w-5 sm:h-5"
                        })]
                    }), S.jsx("button", {
                        onClick: e,
                        className: "border-2 border-slate-600 text-white px-6 sm:px-8 py-3 sm:py-4 rounded-xl font-bold hover:bg-slate-800/50 transition-all duration-150 text-base sm:text-lg",
                        children: "Get $BNKZ Token"
                    })]
                }), S.jsxs("div", {
                    className: "flex justify-center gap-6 mb-12 sm:mb-16",
                    children: [S.jsx("a", {
                        href: "https://t.me/+Mh9YQsnnRcZlNWFh",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "bg-purple-600 hover:bg-purple-700 text-white w-12 h-12 rounded-full flex items-center justify-center shadow-lg transition",
                        children: S.jsx(Xd, {
                            className: "w-7 h-7"
                        })
                    }), S.jsx("a", {
                        href: "https://x.com/abonkcommunity?s=21",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "bg-purple-600 hover:bg-purple-700 text-white w-12 h-12 rounded-full flex items-center justify-center shadow-lg transition",
                        children: S.jsx(eh, {
                            className: "w-7 h-7"
                        })
                    })]
                })]
            }), S.jsx("div", {
                className: "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 sm:gap-8 mb-12 sm:mb-16 px-4 place-items-center",
                children: S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-6 sm:p-8 border border-white/10 text-center w-full",
                    children: [S.jsx("div", {
                        className: "w-12 h-12 sm:w-16 sm:h-16 bg-gradient-to-r from-purple-600 to-purple-700 rounded-full flex items-center justify-center mx-auto mb-3 sm:mb-4 shadow-lg",
                        children: S.jsx(h5, {
                            className: "w-6 h-6 sm:w-8 sm:h-8 text-white"
                        })
                    }), S.jsx("h3", {
                        className: "text-2xl sm:text-3xl font-bold text-white mb-2",
                        children: "5,350"
                    }), S.jsx("p", {
                        className: "text-slate-400 text-sm sm:text-base",
                        children: "Unique Bonkeez NFTs"
                    }), S.jsx("p", {
                        className: "text-purple-400 text-xs sm:text-sm mt-1",
                        children: "Ready for Launch"
                    })]
                })
            })]
        })]
    })
}
  , g5 = () => {
    const [t,e] = Y.useState(null)
      , [n,r] = Y.useState(!0);
    Y.useEffect( () => {
        const a = async () => {
            try {
                r(!0);
                const c = await Iy();
                c && e(c)
            } catch (c) {
                console.warn("Failed to fetch token data:", c),
                e({
                    price: "$0.000001",
                    marketCap: "N/A",
                    volume24h: "N/A",
                    holders: "N/A",
                    totalSupply: "1B",
                    change24h: 0
                })
            } finally {
                r(!1)
            }
        }
        ;
        a();
        const l = setInterval(a, 6e4);
        return () => clearInterval(l)
    }
    , []);
    const i = () => {
        window.open(Vk(), "_blank", "noopener,noreferrer")
    }
      , s = () => {
        window.open(YR(), "_blank", "noopener,noreferrer")
    }
      , o = () => {
        alert("Add to wallet feature coming soon! This will automatically add $BNKZ to your connected Solana wallet.")
    }
    ;
    return n || !t ? S.jsx("section", {
        id: "stats",
        className: "py-16 px-4 sm:px-6 lg:px-8 bg-gradient-to-r from-emerald-500/5 to-slate-600/5",
        children: S.jsx("div", {
            className: "max-w-7xl mx-auto text-center",
            children: S.jsxs("div", {
                className: "animate-pulse",
                children: [S.jsx("div", {
                    className: "h-8 bg-white/10 rounded-lg w-64 mx-auto mb-4"
                }), S.jsx("div", {
                    className: "h-4 bg-white/5 rounded w-96 mx-auto"
                })]
            })
        })
    }) : S.jsx("section", {
        id: "stats",
        className: "py-16 px-4 sm:px-6 lg:px-8 bg-gradient-to-r f",
        children: S.jsxs("div", {
            className: "max-w-7xl mx-auto",
            children: [S.jsxs("div", {
                className: "text-center mb-12",
                children: [S.jsxs("div", {
                    className: "inline-flex items-center bg-purple-800 text-purple-00 px-6 py-3 rounded-full text-lg font-bold mb-6",
                    children: [S.jsx(jl, {
                        className: "w-5 h-5 mr-2"
                    }), "$BNKZ Token Live on Pumpfun"]
                }), S.jsx("h2", {
                    className: "text-4xl lg:text-5xl font-bold text-white mb-4",
                    children: "$BNKZ Token Statistics"
                }), S.jsx("p", {
                    className: "text-xl text-slate-300 mb-6",
                    children: "The official Bonkeez ecosystem token powering the marketplace"
                }), S.jsxs("div", {
                    className: "flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4 text-slate-400",
                    children: [S.jsx("span", {
                        className: "font-mono text-sm",
                        children: "Contract: Gr1PWUXKBvEWN3d67d3FxvBmawjCtA5HWqfnJxSgDz1F"
                    }), S.jsxs("button", {
                        onClick: s,
                        className: "flex items-center space-x-1 text-emerald-400 hover:text-emerald-300 transition-colors",
                        children: [S.jsx(Mg, {
                            className: "w-4 h-4"
                        }), S.jsx("span", {
                            children: "View on Solscan"
                        })]
                    })]
                })]
            }), S.jsxs("div", {
                className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6 mb-8 sm:mb-12",
                children: [S.jsxs("div", {
                    className: "bg-gradient-to-br from-emerald-500/10 to-slate-600/10 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-emerald-400/20",
                    children: [S.jsxs("div", {
                        className: "flex items-center justify-between mb-3 sm:mb-4",
                        children: [S.jsx("div", {
                            className: "w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-r from-purple-600 to-purple-800 rounded-lg flex items-center justify-center shadow-lg",
                            children: S.jsx(Hk, {
                                className: "w-5 h-5 sm:w-6 sm:h-6 text-white"
                            })
                        }), S.jsxs("div", {
                            className: `px-2 sm:px-3 py-1 rounded-full text-xs sm:text-sm font-bold ${t.change24h >= 0 ? "text-emerald-400 bg-emerald-400/20" : "text-red-400 bg-red-400/20"}`,
                            children: [t.change24h >= 0 ? "+" : "", t.change24h.toFixed(1), "%"]
                        })]
                    }), S.jsxs("div", {
                        children: [S.jsx("p", {
                            className: "text-slate-400 text-xs sm:text-sm mb-1",
                            children: "Token Price"
                        }), S.jsx("p", {
                            className: "text-white text-xl sm:text-2xl lg:text-3xl font-bold break-all",
                            children: t.price
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                    children: [S.jsx("div", {
                        className: "flex items-center justify-between mb-3 sm:mb-4",
                        children: S.jsx("div", {
                            className: "w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-r from-purple-800 to-purple-600 rounded-lg flex items-center justify-center shadow-lg",
                            children: S.jsx(qk, {
                                className: "w-5 h-5 sm:w-6 sm:h-6 text-white"
                            })
                        })
                    }), S.jsxs("div", {
                        children: [S.jsx("p", {
                            className: "text-slate-400 text-xs sm:text-sm mb-1",
                            children: "Market Cap"
                        }), S.jsx("p", {
                            className: "text-white text-xl sm:text-2xl lg:text-3xl font-bold",
                            children: t.marketCap
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10 sm:col-span-2 lg:col-span-1",
                    children: [S.jsx("div", {
                        className: "flex items-center justify-between mb-3 sm:mb-4",
                        children: S.jsx("div", {
                            className: "w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-r from-purple-600 to-purple-500 rounded-lg flex items-center justify-center shadow-lg",
                            children: S.jsx(jl, {
                                className: "w-5 h-5 sm:w-6 sm:h-6 text-white"
                            })
                        })
                    }), S.jsxs("div", {
                        children: [S.jsx("p", {
                            className: "text-slate-400 text-xs sm:text-sm mb-1",
                            children: "24h Volume"
                        }), S.jsx("p", {
                            className: "text-white text-xl sm:text-2xl lg:text-3xl font-bold",
                            children: t.volume24h
                        })]
                    })]
                })]
            }), S.jsxs("div", {
                className: "grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6",
                children: [S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                    children: [S.jsxs("div", {
                        className: "flex items-center space-x-2 sm:space-x-3 mb-3 sm:mb-4",
                        children: [S.jsx(Gk, {
                            className: "w-5 h-5 sm:w-6 sm:h-6 text-slate-400"
                        }), S.jsx("h3", {
                            className: "text-white text-lg sm:text-xl font-bold",
                            children: "Token Holders"
                        })]
                    }), S.jsx("p", {
                        className: "text-2xl sm:text-3xl font-bold text-white mb-2",
                        children: t.holders
                    }), S.jsx("p", {
                        className: "text-slate-400 text-sm sm:text-base",
                        children: "Active wallet addresses"
                    })]
                }), S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                    children: [S.jsxs("div", {
                        className: "flex items-center space-x-2 sm:space-x-3 mb-3 sm:mb-4",
                        children: [S.jsx(jl, {
                            className: "w-5 h-5 sm:w-6 sm:h-6 text-purple-300"
                        }), S.jsx("h3", {
                            className: "text-white text-lg sm:text-xl font-bold",
                            children: "Total Supply"
                        })]
                    }), S.jsx("p", {
                        className: "text-2xl sm:text-3xl font-bold text-white mb-2",
                        children: t.totalSupply
                    }), S.jsx("p", {
                        className: "text-slate-400 text-sm sm:text-base",
                        children: "Maximum token supply"
                    })]
                })]
            }), S.jsx("div", {
                className: "text-center mt-8 sm:mt-12",
                children: S.jsxs("div", {
                    className: "flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center max-w-md sm:max-w-none mx-auto",
                    children: [S.jsxs("button", {
                        onClick: i,
                        className: "bg-gradient-to-r from-emerald-600 to-emerald-700 text-white px-6 sm:px-8 py-3 sm:py-4 rounded-lg font-bold hover:from-emerald-700 hover:to-emerald-800 transition-all flex items-center justify-center space-x-2 shadow-lg hover:shadow-emerald-500/25 text-sm sm:text-base",
                        children: [S.jsx("span", {
                            children: "Buy $BNKZ on Pumpfun"
                        }), S.jsx(Mg, {
                            className: "w-4 h-4 sm:w-5 sm:h-5"
                        })]
                    }), S.jsx("button", {
                        onClick: o,
                        className: "border-2 border-slate-600 text-white px-6 sm:px-8 py-3 sm:py-4 rounded-lg font-bold hover:bg-slate-800/50 transition-all text-sm sm:text-base",
                        children: "Add to Wallet"
                    })]
                })
            })]
        })
    })
}
  , m5 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => bo( () => Promise.resolve().then( () => Va), void 0).then( ({default: r}) => r(...n)) : e = fetch,
    (...n) => e(...n)
}
;
class My extends Error {
    constructor(e, n="FunctionsError", r) {
        super(e),
        this.name = n,
        this.context = r
    }
}
class y5 extends My {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
class lv extends My {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
class cv extends My {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
var Tg;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(Tg || (Tg = {}));
var w5 = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
class v5 {
    constructor(e, {headers: n={}, customFetch: r, region: i=Tg.Any}={}) {
        this.url = e,
        this.headers = n,
        this.region = i,
        this.fetch = m5(r)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e, n={}) {
        var r;
        return w5(this, void 0, void 0, function*() {
            try {
                const {headers: i, method: s, body: o} = n;
                let a = {}
                  , {region: l} = n;
                l || (l = this.region);
                const c = new URL(`${this.url}/${e}`);
                l && l !== "any" && (a["x-region"] = l,
                c.searchParams.set("forceFunctionRegion", l));
                let d;
                o && (i && !Object.prototype.hasOwnProperty.call(i, "Content-Type") || !i) && (typeof Blob < "u" && o instanceof Blob || o instanceof ArrayBuffer ? (a["Content-Type"] = "application/octet-stream",
                d = o) : typeof o == "string" ? (a["Content-Type"] = "text/plain",
                d = o) : typeof FormData < "u" && o instanceof FormData ? d = o : (a["Content-Type"] = "application/json",
                d = JSON.stringify(o)));
                const h = yield this.fetch(c.toString(), {
                    method: s || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, a), this.headers), i),
                    body: d
                }).catch(E => {
                    throw new y5(E)
                }
                )
                  , y = h.headers.get("x-relay-error");
                if (y && y === "true")
                    throw new lv(h);
                if (!h.ok)
                    throw new cv(h);
                let m = ((r = h.headers.get("Content-Type")) !== null && r !== void 0 ? r : "text/plain").split(";")[0].trim(), v;
                return m === "application/json" ? v = yield h.json() : m === "application/octet-stream" ? v = yield h.blob() : m === "text/event-stream" ? v = h : m === "multipart/form-data" ? v = yield h.formData() : v = yield h.text(),
                {
                    data: v,
                    error: null,
                    response: h
                }
            } catch (i) {
                return {
                    data: null,
                    error: i,
                    response: i instanceof cv || i instanceof lv ? i.context : void 0
                }
            }
        })
    }
}
var Kn = {}
  , Ty = {}
  , Gh = {}
  , Lc = {}
  , Yh = {}
  , Zh = {}
  , b5 = function() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof globalThis < "u")
        return globalThis;
    throw new Error("unable to locate globalThis object")
}
  , Ba = b5();
const _5 = Ba.fetch
  , Yk = Ba.fetch.bind(Ba)
  , Zk = Ba.Headers
  , x5 = Ba.Request
  , S5 = Ba.Response
  , Va = Object.freeze(Object.defineProperty({
    __proto__: null,
    Headers: Zk,
    Request: x5,
    Response: S5,
    default: Yk,
    fetch: _5
}, Symbol.toStringTag, {
    value: "Module"
}))
  , k5 = ms(Va);
var Qh = {};
Object.defineProperty(Qh, "__esModule", {
    value: !0
});
let E5 = class extends Error {
    constructor(e) {
        super(e.message),
        this.name = "PostgrestError",
        this.details = e.details,
        this.hint = e.hint,
        this.code = e.code
    }
}
;
Qh.default = E5;
var Qk = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Zh, "__esModule", {
    value: !0
});
const A5 = Qk(k5)
  , I5 = Qk(Qh);
let M5 = class {
    constructor(e) {
        var n, r;
        this.shouldThrowOnError = !1,
        this.method = e.method,
        this.url = e.url,
        this.headers = new Headers(e.headers),
        this.schema = e.schema,
        this.body = e.body,
        this.shouldThrowOnError = (n = e.shouldThrowOnError) !== null && n !== void 0 ? n : !1,
        this.signal = e.signal,
        this.isMaybeSingle = (r = e.isMaybeSingle) !== null && r !== void 0 ? r : !1,
        e.fetch ? this.fetch = e.fetch : typeof fetch > "u" ? this.fetch = A5.default : this.fetch = fetch
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    setHeader(e, n) {
        return this.headers = new Headers(this.headers),
        this.headers.set(e, n),
        this
    }
    then(e, n) {
        this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
        this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
        const r = this.fetch;
        let i = r(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal
        }).then(async s => {
            var o, a, l, c;
            let d = null
              , h = null
              , y = null
              , m = s.status
              , v = s.statusText;
            if (s.ok) {
                if (this.method !== "HEAD") {
                    const x = await s.text();
                    x === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((o = this.headers.get("Accept")) === null || o === void 0) && o.includes("application/vnd.pgrst.plan+text")) ? h = x : h = JSON.parse(x))
                }
                const A = (a = this.headers.get("Prefer")) === null || a === void 0 ? void 0 : a.match(/count=(exact|planned|estimated)/)
                  , _ = (l = s.headers.get("content-range")) === null || l === void 0 ? void 0 : l.split("/");
                A && _ && _.length > 1 && (y = parseInt(_[1])),
                this.isMaybeSingle && this.method === "GET" && Array.isArray(h) && (h.length > 1 ? (d = {
                    code: "PGRST116",
                    details: `Results contain ${h.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message: "JSON object requested, multiple (or no) rows returned"
                },
                h = null,
                y = null,
                m = 406,
                v = "Not Acceptable") : h.length === 1 ? h = h[0] : h = null)
            } else {
                const A = await s.text();
                try {
                    d = JSON.parse(A),
                    Array.isArray(d) && s.status === 404 && (h = [],
                    d = null,
                    m = 200,
                    v = "OK")
                } catch {
                    s.status === 404 && A === "" ? (m = 204,
                    v = "No Content") : d = {
                        message: A
                    }
                }
                if (d && this.isMaybeSingle && (!((c = d?.details) === null || c === void 0) && c.includes("0 rows")) && (d = null,
                m = 200,
                v = "OK"),
                d && this.shouldThrowOnError)
                    throw new I5.default(d)
            }
            return {
                error: d,
                data: h,
                count: y,
                status: m,
                statusText: v
            }
        }
        );
        return this.shouldThrowOnError || (i = i.catch(s => {
            var o, a, l;
            return {
                error: {
                    message: `${(o = s?.name) !== null && o !== void 0 ? o : "FetchError"}: ${s?.message}`,
                    details: `${(a = s?.stack) !== null && a !== void 0 ? a : ""}`,
                    hint: "",
                    code: `${(l = s?.code) !== null && l !== void 0 ? l : ""}`
                },
                data: null,
                count: null,
                status: 0,
                statusText: ""
            }
        }
        )),
        i.then(e, n)
    }
    returns() {
        return this
    }
    overrideTypes() {
        return this
    }
}
;
Zh.default = M5;
var T5 = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Yh, "__esModule", {
    value: !0
});
const N5 = T5(Zh);
let C5 = class extends N5.default {
    select(e) {
        let n = !1;
        const r = (e ?? "*").split("").map(i => /\s/.test(i) && !n ? "" : (i === '"' && (n = !n),
        i)).join("");
        return this.url.searchParams.set("select", r),
        this.headers.append("Prefer", "return=representation"),
        this
    }
    order(e, {ascending: n=!0, nullsFirst: r, foreignTable: i, referencedTable: s=i}={}) {
        const o = s ? `${s}.order` : "order"
          , a = this.url.searchParams.get(o);
        return this.url.searchParams.set(o, `${a ? `${a},` : ""}${e}.${n ? "asc" : "desc"}${r === void 0 ? "" : r ? ".nullsfirst" : ".nullslast"}`),
        this
    }
    limit(e, {foreignTable: n, referencedTable: r=n}={}) {
        const i = typeof r > "u" ? "limit" : `${r}.limit`;
        return this.url.searchParams.set(i, `${e}`),
        this
    }
    range(e, n, {foreignTable: r, referencedTable: i=r}={}) {
        const s = typeof i > "u" ? "offset" : `${i}.offset`
          , o = typeof i > "u" ? "limit" : `${i}.limit`;
        return this.url.searchParams.set(s, `${e}`),
        this.url.searchParams.set(o, `${n - e + 1}`),
        this
    }
    abortSignal(e) {
        return this.signal = e,
        this
    }
    single() {
        return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this
    }
    maybeSingle() {
        return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this.isMaybeSingle = !0,
        this
    }
    csv() {
        return this.headers.set("Accept", "text/csv"),
        this
    }
    geojson() {
        return this.headers.set("Accept", "application/geo+json"),
        this
    }
    explain({analyze: e=!1, verbose: n=!1, settings: r=!1, buffers: i=!1, wal: s=!1, format: o="text"}={}) {
        var a;
        const l = [e ? "analyze" : null, n ? "verbose" : null, r ? "settings" : null, i ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|")
          , c = (a = this.headers.get("Accept")) !== null && a !== void 0 ? a : "application/json";
        return this.headers.set("Accept", `application/vnd.pgrst.plan+${o}; for="${c}"; options=${l};`),
        o === "json" ? this : this
    }
    rollback() {
        return this.headers.append("Prefer", "tx=rollback"),
        this
    }
    returns() {
        return this
    }
    maxAffected(e) {
        return this.headers.append("Prefer", "handling=strict"),
        this.headers.append("Prefer", `max-affected=${e}`),
        this
    }
}
;
Yh.default = C5;
var R5 = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Lc, "__esModule", {
    value: !0
});
const L5 = R5(Yh);
let j5 = class extends L5.default {
    eq(e, n) {
        return this.url.searchParams.append(e, `eq.${n}`),
        this
    }
    neq(e, n) {
        return this.url.searchParams.append(e, `neq.${n}`),
        this
    }
    gt(e, n) {
        return this.url.searchParams.append(e, `gt.${n}`),
        this
    }
    gte(e, n) {
        return this.url.searchParams.append(e, `gte.${n}`),
        this
    }
    lt(e, n) {
        return this.url.searchParams.append(e, `lt.${n}`),
        this
    }
    lte(e, n) {
        return this.url.searchParams.append(e, `lte.${n}`),
        this
    }
    like(e, n) {
        return this.url.searchParams.append(e, `like.${n}`),
        this
    }
    likeAllOf(e, n) {
        return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`),
        this
    }
    likeAnyOf(e, n) {
        return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`),
        this
    }
    ilike(e, n) {
        return this.url.searchParams.append(e, `ilike.${n}`),
        this
    }
    ilikeAllOf(e, n) {
        return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`),
        this
    }
    ilikeAnyOf(e, n) {
        return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`),
        this
    }
    is(e, n) {
        return this.url.searchParams.append(e, `is.${n}`),
        this
    }
    in(e, n) {
        const r = Array.from(new Set(n)).map(i => typeof i == "string" && new RegExp("[,()]").test(i) ? `"${i}"` : `${i}`).join(",");
        return this.url.searchParams.append(e, `in.(${r})`),
        this
    }
    contains(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `cs.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`),
        this
    }
    containedBy(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `cd.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`),
        this
    }
    rangeGt(e, n) {
        return this.url.searchParams.append(e, `sr.${n}`),
        this
    }
    rangeGte(e, n) {
        return this.url.searchParams.append(e, `nxl.${n}`),
        this
    }
    rangeLt(e, n) {
        return this.url.searchParams.append(e, `sl.${n}`),
        this
    }
    rangeLte(e, n) {
        return this.url.searchParams.append(e, `nxr.${n}`),
        this
    }
    rangeAdjacent(e, n) {
        return this.url.searchParams.append(e, `adj.${n}`),
        this
    }
    overlaps(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `ov.${n}`) : this.url.searchParams.append(e, `ov.{${n.join(",")}}`),
        this
    }
    textSearch(e, n, {config: r, type: i}={}) {
        let s = "";
        i === "plain" ? s = "pl" : i === "phrase" ? s = "ph" : i === "websearch" && (s = "w");
        const o = r === void 0 ? "" : `(${r})`;
        return this.url.searchParams.append(e, `${s}fts${o}.${n}`),
        this
    }
    match(e) {
        return Object.entries(e).forEach( ([n,r]) => {
            this.url.searchParams.append(n, `eq.${r}`)
        }
        ),
        this
    }
    not(e, n, r) {
        return this.url.searchParams.append(e, `not.${n}.${r}`),
        this
    }
    or(e, {foreignTable: n, referencedTable: r=n}={}) {
        const i = r ? `${r}.or` : "or";
        return this.url.searchParams.append(i, `(${e})`),
        this
    }
    filter(e, n, r) {
        return this.url.searchParams.append(e, `${n}.${r}`),
        this
    }
}
;
Lc.default = j5;
var B5 = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Gh, "__esModule", {
    value: !0
});
const il = B5(Lc);
let P5 = class {
    constructor(e, {headers: n={}, schema: r, fetch: i}) {
        this.url = e,
        this.headers = new Headers(n),
        this.schema = r,
        this.fetch = i
    }
    select(e, {head: n=!1, count: r}={}) {
        const i = n ? "HEAD" : "GET";
        let s = !1;
        const o = (e ?? "*").split("").map(a => /\s/.test(a) && !s ? "" : (a === '"' && (s = !s),
        a)).join("");
        return this.url.searchParams.set("select", o),
        r && this.headers.append("Prefer", `count=${r}`),
        new il.default({
            method: i,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: this.fetch
        })
    }
    insert(e, {count: n, defaultToNull: r=!0}={}) {
        var i;
        const s = "POST";
        if (n && this.headers.append("Prefer", `count=${n}`),
        r || this.headers.append("Prefer", "missing=default"),
        Array.isArray(e)) {
            const o = e.reduce( (a, l) => a.concat(Object.keys(l)), []);
            if (o.length > 0) {
                const a = [...new Set(o)].map(l => `"${l}"`);
                this.url.searchParams.set("columns", a.join(","))
            }
        }
        return new il.default({
            method: s,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
        })
    }
    upsert(e, {onConflict: n, ignoreDuplicates: r=!1, count: i, defaultToNull: s=!0}={}) {
        var o;
        const a = "POST";
        if (this.headers.append("Prefer", `resolution=${r ? "ignore" : "merge"}-duplicates`),
        n !== void 0 && this.url.searchParams.set("on_conflict", n),
        i && this.headers.append("Prefer", `count=${i}`),
        s || this.headers.append("Prefer", "missing=default"),
        Array.isArray(e)) {
            const l = e.reduce( (c, d) => c.concat(Object.keys(d)), []);
            if (l.length > 0) {
                const c = [...new Set(l)].map(d => `"${d}"`);
                this.url.searchParams.set("columns", c.join(","))
            }
        }
        return new il.default({
            method: a,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
        })
    }
    update(e, {count: n}={}) {
        var r;
        const i = "PATCH";
        return n && this.headers.append("Prefer", `count=${n}`),
        new il.default({
            method: i,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (r = this.fetch) !== null && r !== void 0 ? r : fetch
        })
    }
    delete({count: e}={}) {
        var n;
        const r = "DELETE";
        return e && this.headers.append("Prefer", `count=${e}`),
        new il.default({
            method: r,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: (n = this.fetch) !== null && n !== void 0 ? n : fetch
        })
    }
}
;
Gh.default = P5;
var Jk = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Ty, "__esModule", {
    value: !0
});
const O5 = Jk(Gh)
  , D5 = Jk(Lc);
let z5 = class Xk {
    constructor(e, {headers: n={}, schema: r, fetch: i}={}) {
        this.url = e,
        this.headers = new Headers(n),
        this.schemaName = r,
        this.fetch = i
    }
    from(e) {
        const n = new URL(`${this.url}/${e}`);
        return new O5.default(n,{
            headers: new Headers(this.headers),
            schema: this.schemaName,
            fetch: this.fetch
        })
    }
    schema(e) {
        return new Xk(this.url,{
            headers: this.headers,
            schema: e,
            fetch: this.fetch
        })
    }
    rpc(e, n={}, {head: r=!1, get: i=!1, count: s}={}) {
        var o;
        let a;
        const l = new URL(`${this.url}/rpc/${e}`);
        let c;
        r || i ? (a = r ? "HEAD" : "GET",
        Object.entries(n).filter( ([h,y]) => y !== void 0).map( ([h,y]) => [h, Array.isArray(y) ? `{${y.join(",")}}` : `${y}`]).forEach( ([h,y]) => {
            l.searchParams.append(h, y)
        }
        )) : (a = "POST",
        c = n);
        const d = new Headers(this.headers);
        return s && d.set("Prefer", `count=${s}`),
        new D5.default({
            method: a,
            url: l,
            headers: d,
            schema: this.schemaName,
            body: c,
            fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
        })
    }
}
;
Ty.default = z5;
var Ha = Ye && Ye.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Kn, "__esModule", {
    value: !0
});
Kn.PostgrestError = Kn.PostgrestBuilder = Kn.PostgrestTransformBuilder = Kn.PostgrestFilterBuilder = Kn.PostgrestQueryBuilder = Kn.PostgrestClient = void 0;
const e2 = Ha(Ty);
Kn.PostgrestClient = e2.default;
const t2 = Ha(Gh);
Kn.PostgrestQueryBuilder = t2.default;
const n2 = Ha(Lc);
Kn.PostgrestFilterBuilder = n2.default;
const r2 = Ha(Yh);
Kn.PostgrestTransformBuilder = r2.default;
const i2 = Ha(Zh);
Kn.PostgrestBuilder = i2.default;
const s2 = Ha(Qh);
Kn.PostgrestError = s2.default;
var U5 = Kn.default = {
    PostgrestClient: e2.default,
    PostgrestQueryBuilder: t2.default,
    PostgrestFilterBuilder: n2.default,
    PostgrestTransformBuilder: r2.default,
    PostgrestBuilder: i2.default,
    PostgrestError: s2.default
};
const {PostgrestClient: W5, PostgrestQueryBuilder: X8, PostgrestFilterBuilder: ej, PostgrestTransformBuilder: tj, PostgrestBuilder: nj, PostgrestError: rj} = U5;
class F5 {
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        if (typeof process < "u" && process.versions && process.versions.node) {
            const n = parseInt(process.versions.node.split(".")[0]);
            return n >= 22 ? typeof globalThis.WebSocket < "u" ? {
                type: "native",
                constructor: globalThis.WebSocket
            } : {
                type: "unsupported",
                error: `Node.js ${n} detected but native WebSocket not found.`,
                workaround: "Provide a WebSocket implementation via the transport option."
            } : {
                type: "unsupported",
                error: `Node.js ${n} detected without native WebSocket support.`,
                workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let n = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (n += `

Suggested solution: ${e.workaround}`),
        new Error(n)
    }
    static createWebSocket(e, n) {
        const r = this.getWebSocketConstructor();
        return new r(e,n)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const $5 = "2.15.4"
  , K5 = `realtime-js/${$5}`
  , V5 = "1.0.0"
  , Ng = 1e4
  , H5 = 1e3
  , q5 = 100;
var Bl;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(Bl || (Bl = {}));
var Zt;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(Zt || (Zt = {}));
var Nr;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(Nr || (Nr = {}));
var Cg;
(function(t) {
    t.websocket = "websocket"
}
)(Cg || (Cg = {}));
var Ds;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(Ds || (Ds = {}));
class G5 {
    constructor() {
        this.HEADER_LENGTH = 1
    }
    decode(e, n) {
        return e.constructor === ArrayBuffer ? n(this._binaryDecode(e)) : n(typeof e == "string" ? JSON.parse(e) : {})
    }
    _binaryDecode(e) {
        const n = new DataView(e)
          , r = new TextDecoder;
        return this._decodeBroadcast(e, n, r)
    }
    _decodeBroadcast(e, n, r) {
        const i = n.getUint8(1)
          , s = n.getUint8(2);
        let o = this.HEADER_LENGTH + 2;
        const a = r.decode(e.slice(o, o + i));
        o = o + i;
        const l = r.decode(e.slice(o, o + s));
        o = o + s;
        const c = JSON.parse(r.decode(e.slice(o, e.byteLength)));
        return {
            ref: null,
            topic: a,
            event: l,
            payload: c
        }
    }
}
class o2 {
    constructor(e, n) {
        this.callback = e,
        this.timerCalc = n,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = n
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout( () => {
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var Xe;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(Xe || (Xe = {}));
const uv = (t, e, n={}) => {
    var r;
    const i = (r = n.skipTypes) !== null && r !== void 0 ? r : [];
    return Object.keys(e).reduce( (s, o) => (s[o] = Y5(o, t, e, i),
    s), {})
}
  , Y5 = (t, e, n, r) => {
    const i = e.find(a => a.name === t)
      , s = i?.type
      , o = n[t];
    return s && !r.includes(s) ? a2(s, o) : Rg(o)
}
  , a2 = (t, e) => {
    if (t.charAt(0) === "_") {
        const n = t.slice(1, t.length);
        return X5(e, n)
    }
    switch (t) {
    case Xe.bool:
        return Z5(e);
    case Xe.float4:
    case Xe.float8:
    case Xe.int2:
    case Xe.int4:
    case Xe.int8:
    case Xe.numeric:
    case Xe.oid:
        return Q5(e);
    case Xe.json:
    case Xe.jsonb:
        return J5(e);
    case Xe.timestamp:
        return eL(e);
    case Xe.abstime:
    case Xe.date:
    case Xe.daterange:
    case Xe.int4range:
    case Xe.int8range:
    case Xe.money:
    case Xe.reltime:
    case Xe.text:
    case Xe.time:
    case Xe.timestamptz:
    case Xe.timetz:
    case Xe.tsrange:
    case Xe.tstzrange:
        return Rg(e);
    default:
        return Rg(e)
    }
}
  , Rg = t => t
  , Z5 = t => {
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , Q5 = t => {
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , J5 = t => {
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch (e) {
            return console.log(`JSON parse error: ${e}`),
            t
        }
    return t
}
  , X5 = (t, e) => {
    if (typeof t != "string")
        return t;
    const n = t.length - 1
      , r = t[n];
    if (t[0] === "{" && r === "}") {
        let s;
        const o = t.slice(1, n);
        try {
            s = JSON.parse("[" + o + "]")
        } catch {
            s = o ? o.split(",") : []
        }
        return s.map(a => a2(e, a))
    }
    return t
}
  , eL = t => typeof t == "string" ? t.replace(" ", "T") : t
  , l2 = t => {
    let e = t;
    return e = e.replace(/^ws/i, "http"),
    e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""),
    e.replace(/\/+$/, "") + "/api/broadcast"
}
;
class S0 {
    constructor(e, n, r={}, i=Ng) {
        this.channel = e,
        this.event = n,
        this.payload = r,
        this.timeout = i,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, n) {
        var r;
        return this._hasReceived(e) && n((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response),
        this.recHooks.push({
            status: e,
            callback: n
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = n => {
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = n,
            this._matchReceive(n)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout( () => {
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, n) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: n
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: n}) {
        this.recHooks.filter(r => r.status === e).forEach(r => r.callback(n))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var dv;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(dv || (dv = {}));
class Pl {
    constructor(e, n) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: () => {}
            ,
            onLeave: () => {}
            ,
            onSync: () => {}
        };
        const r = n?.events || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(r.state, {}, i => {
            const {onJoin: s, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = Pl.syncState(this.state, i, s, o),
            this.pendingDiffs.forEach(l => {
                this.state = Pl.syncDiff(this.state, l, s, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(r.diff, {}, i => {
            const {onJoin: s, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(i) : (this.state = Pl.syncDiff(this.state, i, s, o),
            a())
        }
        ),
        this.onJoin( (i, s, o) => {
            this.channel._trigger("presence", {
                event: "join",
                key: i,
                currentPresences: s,
                newPresences: o
            })
        }
        ),
        this.onLeave( (i, s, o) => {
            this.channel._trigger("presence", {
                event: "leave",
                key: i,
                currentPresences: s,
                leftPresences: o
            })
        }
        ),
        this.onSync( () => {
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, n, r, i) {
        const s = this.cloneDeep(e)
          , o = this.transformState(n)
          , a = {}
          , l = {};
        return this.map(s, (c, d) => {
            o[c] || (l[c] = d)
        }
        ),
        this.map(o, (c, d) => {
            const h = s[c];
            if (h) {
                const y = d.map(A => A.presence_ref)
                  , m = h.map(A => A.presence_ref)
                  , v = d.filter(A => m.indexOf(A.presence_ref) < 0)
                  , E = h.filter(A => y.indexOf(A.presence_ref) < 0);
                v.length > 0 && (a[c] = v),
                E.length > 0 && (l[c] = E)
            } else
                a[c] = d
        }
        ),
        this.syncDiff(s, {
            joins: a,
            leaves: l
        }, r, i)
    }
    static syncDiff(e, n, r, i) {
        const {joins: s, leaves: o} = {
            joins: this.transformState(n.joins),
            leaves: this.transformState(n.leaves)
        };
        return r || (r = () => {}
        ),
        i || (i = () => {}
        ),
        this.map(s, (a, l) => {
            var c;
            const d = (c = e[a]) !== null && c !== void 0 ? c : [];
            if (e[a] = this.cloneDeep(l),
            d.length > 0) {
                const h = e[a].map(m => m.presence_ref)
                  , y = d.filter(m => h.indexOf(m.presence_ref) < 0);
                e[a].unshift(...y)
            }
            r(a, d, l)
        }
        ),
        this.map(o, (a, l) => {
            let c = e[a];
            if (!c)
                return;
            const d = l.map(h => h.presence_ref);
            c = c.filter(h => d.indexOf(h.presence_ref) < 0),
            e[a] = c,
            i(a, c, l),
            c.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, n) {
        return Object.getOwnPropertyNames(e).map(r => n(r, e[r]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce( (n, r) => {
            const i = e[r];
            return "metas"in i ? n[r] = i.metas.map(s => (s.presence_ref = s.phx_ref,
            delete s.phx_ref,
            delete s.phx_ref_prev,
            s)) : n[r] = i,
            n
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
var hv;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(hv || (hv = {}));
var Ol;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(Ol || (Ol = {}));
var pi;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(pi || (pi = {}));
class Ny {
    constructor(e, n={
        config: {}
    }, r) {
        this.topic = e,
        this.params = n,
        this.socket = r,
        this.bindings = {},
        this.state = Zt.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, n.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new S0(this,Nr.join,this.params,this.timeout),
        this.rejoinTimer = new o2( () => this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", () => {
            this.state = Zt.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(i => i.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose( () => {
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = Zt.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(i => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, i),
            this.state = Zt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", () => {
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = Zt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", i => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, i),
            this.state = Zt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(Nr.reply, {}, (i, s) => {
            this._trigger(this._replyEventName(s), i)
        }
        ),
        this.presence = new Pl(this),
        this.broadcastEndpointURL = l2(this.socket.endPoint),
        this.private = this.params.config.private || !1
    }
    subscribe(e, n=this.timeout) {
        var r, i, s;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == Zt.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , c = (i = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map(m => m.filter)) !== null && i !== void 0 ? i : []
              , d = !!this.bindings[Ol.PRESENCE] && this.bindings[Ol.PRESENCE].length > 0 || ((s = this.params.config.presence) === null || s === void 0 ? void 0 : s.enabled) === !0
              , h = {}
              , y = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: d
                }),
                postgres_changes: c,
                private: l
            };
            this.socket.accessTokenValue && (h.access_token = this.socket.accessTokenValue),
            this._onError(m => e?.(pi.CHANNEL_ERROR, m)),
            this._onClose( () => e?.(pi.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: y
            }, h)),
            this.joinedOnce = !0,
            this._rejoin(n),
            this.joinPush.receive("ok", async ({postgres_changes: m}) => {
                var v;
                if (this.socket.setAuth(),
                m === void 0) {
                    e?.(pi.SUBSCRIBED);
                    return
                } else {
                    const E = this.bindings.postgres_changes
                      , A = (v = E?.length) !== null && v !== void 0 ? v : 0
                      , _ = [];
                    for (let x = 0; x < A; x++) {
                        const b = E[x]
                          , {filter: {event: R, schema: O, table: D, filter: z}} = b
                          , K = m && m[x];
                        if (K && K.event === R && K.schema === O && K.table === D && K.filter === z)
                            _.push(Object.assign(Object.assign({}, b), {
                                id: K.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = Zt.errored,
                            e?.(pi.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = _,
                    e && e(pi.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", m => {
                this.state = Zt.errored,
                e?.(pi.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(m).join(", ") || "error")))
            }
            ).receive("timeout", () => {
                e?.(pi.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, n={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, n.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, n, r) {
        return this.state === Zt.joined && e === Ol.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then( () => this.subscribe())),
        this._on(e, n, r)
    }
    async send(e, n={}) {
        var r, i;
        if (!this._canPush() && e.type === "broadcast") {
            const {event: s, payload: o} = e
              , l = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: s,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const c = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (r = n.timeout) !== null && r !== void 0 ? r : this.timeout);
                return await ((i = c.body) === null || i === void 0 ? void 0 : i.cancel()),
                c.ok ? "ok" : "error"
            } catch (c) {
                return c.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(s => {
                var o, a, l;
                const c = this._push(e.type, e, n.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && s("ok"),
                c.receive("ok", () => s("ok")),
                c.receive("error", () => s("error")),
                c.receive("timeout", () => s("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = Zt.leaving;
        const n = () => {
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(Nr.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let r = null;
        return new Promise(i => {
            r = new S0(this,Nr.leave,{},e),
            r.receive("ok", () => {
                n(),
                i("ok")
            }
            ).receive("timeout", () => {
                n(),
                i("timed out")
            }
            ).receive("error", () => {
                i("error")
            }
            ),
            r.send(),
            this._canPush() || r.trigger("ok", {})
        }
        ).finally( () => {
            r?.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e => e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = Zt.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, n, r) {
        const i = new AbortController
          , s = setTimeout( () => i.abort(), r)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, n), {
            signal: i.signal
        }));
        return clearTimeout(s),
        o
    }
    _push(e, n, r=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let i = new S0(this,e,n,r);
        return this._canPush() ? i.send() : this._addToPushBuffer(i),
        i
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > q5) {
            const n = this.pushBuffer.shift();
            n && (n.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${n.event}`, n.payload))
        }
    }
    _onMessage(e, n, r) {
        return n
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, n, r) {
        var i, s;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: c, join: d} = Nr;
        if (r && [a, l, c, d].indexOf(o) >= 0 && r !== this._joinRef())
            return;
        let y = this._onMessage(o, n, r);
        if (n && !y)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (i = this.bindings.postgres_changes) === null || i === void 0 || i.filter(m => {
            var v, E, A;
            return ((v = m.filter) === null || v === void 0 ? void 0 : v.event) === "*" || ((A = (E = m.filter) === null || E === void 0 ? void 0 : E.event) === null || A === void 0 ? void 0 : A.toLocaleLowerCase()) === o
        }
        ).map(m => m.callback(y, r)) : (s = this.bindings[o]) === null || s === void 0 || s.filter(m => {
            var v, E, A, _, x, b;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in m) {
                    const R = m.id
                      , O = (v = m.filter) === null || v === void 0 ? void 0 : v.event;
                    return R && ((E = n.ids) === null || E === void 0 ? void 0 : E.includes(R)) && (O === "*" || O?.toLocaleLowerCase() === ((A = n.data) === null || A === void 0 ? void 0 : A.type.toLocaleLowerCase()))
                } else {
                    const R = (x = (_ = m?.filter) === null || _ === void 0 ? void 0 : _.event) === null || x === void 0 ? void 0 : x.toLocaleLowerCase();
                    return R === "*" || R === ((b = n?.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase())
                }
            else
                return m.type.toLocaleLowerCase() === o
        }
        ).map(m => {
            if (typeof y == "object" && "ids"in y) {
                const v = y.data
                  , {schema: E, table: A, commit_timestamp: _, type: x, errors: b} = v;
                y = Object.assign(Object.assign({}, {
                    schema: E,
                    table: A,
                    commit_timestamp: _,
                    eventType: x,
                    new: {},
                    old: {},
                    errors: b
                }), this._getPayloadRecords(v))
            }
            m.callback(y, r)
        }
        )
    }
    _isClosed() {
        return this.state === Zt.closed
    }
    _isJoined() {
        return this.state === Zt.joined
    }
    _isJoining() {
        return this.state === Zt.joining
    }
    _isLeaving() {
        return this.state === Zt.leaving
    }
    _replyEventName(e) {
        return `chan_reply_${e}`
    }
    _on(e, n, r) {
        const i = e.toLocaleLowerCase()
          , s = {
            type: i,
            filter: n,
            callback: r
        };
        return this.bindings[i] ? this.bindings[i].push(s) : this.bindings[i] = [s],
        this
    }
    _off(e, n) {
        const r = e.toLocaleLowerCase();
        return this.bindings[r] && (this.bindings[r] = this.bindings[r].filter(i => {
            var s;
            return !(((s = i.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && Ny.isEqual(i.filter, n))
        }
        )),
        this
    }
    static isEqual(e, n) {
        if (Object.keys(e).length !== Object.keys(n).length)
            return !1;
        for (const r in e)
            if (e[r] !== n[r])
                return !1;
        return !0
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(Nr.close, {}, e)
    }
    _onError(e) {
        this._on(Nr.error, {}, n => e(n))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = Zt.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const n = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (n.new = uv(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (n.old = uv(e.columns, e.old_record)),
        n
    }
}
const k0 = () => {}
  , du = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , tL = [1e3, 2e3, 5e3, 1e4]
  , nL = 1e4
  , rL = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class iL {
    constructor(e, n) {
        var r;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = Ng,
        this.transport = null,
        this.heartbeatIntervalMs = du.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = k0,
        this.ref = 0,
        this.reconnectTimer = null,
        this.logger = k0,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new G5,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._resolveFetch = i => {
            let s;
            return i ? s = i : typeof fetch > "u" ? s = (...o) => bo( () => Promise.resolve().then( () => Va), void 0).then( ({default: a}) => a(...o)).catch(a => {
                throw new Error(`Failed to load @supabase/node-fetch: ${a.message}. This is required for HTTP requests in Node.js environments without native fetch.`)
            }
            ) : s = fetch,
            (...o) => s(...o)
        }
        ,
        !(!((r = n?.params) === null || r === void 0) && r.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = n.params.apikey,
        this.endPoint = `${e}/${Cg.websocket}`,
        this.httpEndpoint = l2(e),
        this._initializeOptions(n),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(n?.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = F5.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const n = e.message;
                    throw n.includes("Node.js") ? new Error(`${n}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${n}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: V5
        }))
    }
    disconnect(e, n) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const r = setTimeout( () => {
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = () => {
                    clearTimeout(r),
                    this._setConnectionState("disconnected")
                }
                ,
                e ? this.conn.close(e, n ?? "") : this.conn.close(),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const n = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        n
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(n => n.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, n, r) {
        this.logger(e, n, r)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case Bl.connecting:
            return Ds.Connecting;
        case Bl.open:
            return Ds.Open;
        case Bl.closing:
            return Ds.Closing;
        default:
            return Ds.Closed
        }
    }
    isConnected() {
        return this.connectionState() === Ds.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, n={
        config: {}
    }) {
        const r = `realtime:${e}`
          , i = this.getChannels().find(s => s.topic === r);
        if (i)
            return i;
        {
            const s = new Ny(`realtime:${e}`,n,this);
            return this.channels.push(s),
            s
        }
    }
    push(e) {
        const {topic: n, event: r, payload: i, ref: s} = e
          , o = () => {
            this.encode(e, a => {
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${n} ${r} (${s})`, i),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (n) {
                this.log("error", "error in heartbeat callback", n)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (n) {
                this.log("error", "error in heartbeat callback", n)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(H5, "heartbeat timeout"),
            setTimeout( () => {
                var n;
                this.isConnected() || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout()
            }
            , du.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (n) {
            this.log("error", "error in heartbeat callback", n)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let n = this.channels.find(r => r.topic === e && (r._isJoined() || r._isJoining()));
        n && (this.log("transport", `leaving duplicate topic "${e}"`),
        n.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(n => n.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, n => {
            if (n.topic === "phoenix" && n.event === "phx_reply")
                try {
                    this.heartbeatCallback(n.payload.status === "ok" ? "ok" : "error")
                } catch (c) {
                    this.log("error", "error in heartbeat callback", c)
                }
            n.ref && n.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
            const {topic: r, event: i, payload: s, ref: o} = n
              , a = o ? `(${o})` : ""
              , l = s.status || "";
            this.log("receive", `${l} ${r} ${i} ${a}`.trim(), s),
            this.channels.filter(c => c._isMember(r)).forEach(c => c._trigger(i, s, o)),
            this._triggerStateCallbacks("message", n)
        }
        )
    }
    _clearTimer(e) {
        var n;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((n = this.reconnectTimer) === null || n === void 0 || n.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = () => this._onConnOpen(),
        this.conn.onerror = e => this._onConnError(e),
        this.conn.onmessage = e => this._onConnMessage(e),
        this.conn.onclose = e => this._onConnClose(e))
    }
    _teardownConnection() {
        this.conn && (this.conn.onopen = null,
        this.conn.onerror = null,
        this.conn.onmessage = null,
        this.conn.onclose = null,
        this.conn = null),
        this._clearAllTimers(),
        this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        this.flushSendBuffer(),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval( () => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = n => {
            this.log("worker", "worker error", n.message),
            this.workerRef.terminate()
        }
        ,
        this.workerRef.onmessage = n => {
            n.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _onConnClose(e) {
        var n;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e => e._trigger(Nr.error))
    }
    _appendParams(e, n) {
        if (Object.keys(n).length === 0)
            return e;
        const r = e.match(/\?/) ? "&" : "?"
          , i = new URLSearchParams(n);
        return `${e}${r}${i}`
    }
    _workerObjectUrl(e) {
        let n;
        if (e)
            n = e;
        else {
            const r = new Blob([rL],{
                type: "application/javascript"
            });
            n = URL.createObjectURL(r)
        }
        return n
    }
    _setConnectionState(e, n=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = n)
    }
    async _performAuth(e=null) {
        let n;
        e ? n = e : this.accessToken ? n = await this.accessToken() : n = this.accessTokenValue,
        this.accessTokenValue != n && (this.accessTokenValue = n,
        this.channels.forEach(r => {
            const i = {
                access_token: n,
                version: K5
            };
            n && r.updateJoinPayload(i),
            r.joinedOnce && r._isJoined() && r._push(Nr.access_token, {
                access_token: n
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this.setAuth().catch(n => {
            this.log("error", `error setting auth in ${e}`, n)
        }
        )
    }
    _triggerStateCallbacks(e, n) {
        try {
            this.stateChangeCallbacks[e].forEach(r => {
                try {
                    r(n)
                } catch (i) {
                    this.log("error", `error in ${e} callback`, i)
                }
            }
            )
        } catch (r) {
            this.log("error", `error triggering ${e} callbacks`, r)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new o2(async () => {
            setTimeout(async () => {
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , du.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var n, r, i, s, o, a, l, c, d;
        if (this.transport = (n = e?.transport) !== null && n !== void 0 ? n : null,
        this.timeout = (r = e?.timeout) !== null && r !== void 0 ? r : Ng,
        this.heartbeatIntervalMs = (i = e?.heartbeatIntervalMs) !== null && i !== void 0 ? i : du.HEARTBEAT_INTERVAL,
        this.worker = (s = e?.worker) !== null && s !== void 0 ? s : !1,
        this.accessToken = (o = e?.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e?.heartbeatCallback) !== null && a !== void 0 ? a : k0,
        e?.params && (this.params = e.params),
        e?.logger && (this.logger = e.logger),
        (e?.logLevel || e?.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (l = e?.reconnectAfterMs) !== null && l !== void 0 ? l : h => tL[h - 1] || nL,
        this.encode = (c = e?.encode) !== null && c !== void 0 ? c : (h, y) => y(JSON.stringify(h)),
        this.decode = (d = e?.decode) !== null && d !== void 0 ? d : this.serializer.decode.bind(this.serializer),
        this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e?.workerUrl
        }
    }
}
class Cy extends Error {
    constructor(e) {
        super(e),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
function Jt(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
class sL extends Cy {
    constructor(e, n, r) {
        super(e),
        this.name = "StorageApiError",
        this.status = n,
        this.statusCode = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class Lg extends Cy {
    constructor(e, n) {
        super(e),
        this.name = "StorageUnknownError",
        this.originalError = n
    }
}
var oL = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
const c2 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => bo( () => Promise.resolve().then( () => Va), void 0).then( ({default: r}) => r(...n)) : e = fetch,
    (...n) => e(...n)
}
  , aL = () => oL(void 0, void 0, void 0, function*() {
    return typeof Response > "u" ? (yield bo( () => Promise.resolve().then( () => Va), void 0)).Response : Response
})
  , jg = t => {
    if (Array.isArray(t))
        return t.map(n => jg(n));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach( ([n,r]) => {
        const i = n.replace(/([-_][a-z])/gi, s => s.toUpperCase().replace(/[-_]/g, ""));
        e[i] = jg(r)
    }
    ),
    e
}
  , lL = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
;
var _o = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
const E0 = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , cL = (t, e, n) => _o(void 0, void 0, void 0, function*() {
    const r = yield aL();
    t instanceof r && !n?.noResolveJson ? t.json().then(i => {
        const s = t.status || 500
          , o = i?.statusCode || s + "";
        e(new sL(E0(i),s,o))
    }
    ).catch(i => {
        e(new Lg(E0(i),i))
    }
    ) : e(new Lg(E0(t),t))
})
  , uL = (t, e, n, r) => {
    const i = {
        method: t,
        headers: e?.headers || {}
    };
    return t === "GET" || !r ? i : (lL(r) ? (i.headers = Object.assign({
        "Content-Type": "application/json"
    }, e?.headers),
    i.body = JSON.stringify(r)) : i.body = r,
    e?.duplex && (i.duplex = e.duplex),
    Object.assign(Object.assign({}, i), n))
}
;
function jc(t, e, n, r, i, s) {
    return _o(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(n, uL(e, r, i, s)).then(l => {
                if (!l.ok)
                    throw l;
                return r?.noResolveJson ? l : l.json()
            }
            ).then(l => o(l)).catch(l => cL(l, a, r))
        }
        )
    })
}
function th(t, e, n, r) {
    return _o(this, void 0, void 0, function*() {
        return jc(t, "GET", e, n, r)
    })
}
function Fr(t, e, n, r, i) {
    return _o(this, void 0, void 0, function*() {
        return jc(t, "POST", e, r, i, n)
    })
}
function Bg(t, e, n, r, i) {
    return _o(this, void 0, void 0, function*() {
        return jc(t, "PUT", e, r, i, n)
    })
}
function dL(t, e, n, r) {
    return _o(this, void 0, void 0, function*() {
        return jc(t, "HEAD", e, Object.assign(Object.assign({}, n), {
            noResolveJson: !0
        }), r)
    })
}
function u2(t, e, n, r, i) {
    return _o(this, void 0, void 0, function*() {
        return jc(t, "DELETE", e, r, i, n)
    })
}
var Ln = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
const hL = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , fv = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
class fL {
    constructor(e, n={}, r, i) {
        this.url = e,
        this.headers = n,
        this.bucketId = r,
        this.fetch = c2(i)
    }
    uploadOrUpdate(e, n, r, i) {
        return Ln(this, void 0, void 0, function*() {
            try {
                let s;
                const o = Object.assign(Object.assign({}, fv), i);
                let a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
                    "x-upsert": String(o.upsert)
                });
                const l = o.metadata;
                typeof Blob < "u" && r instanceof Blob ? (s = new FormData,
                s.append("cacheControl", o.cacheControl),
                l && s.append("metadata", this.encodeMetadata(l)),
                s.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (s = r,
                s.append("cacheControl", o.cacheControl),
                l && s.append("metadata", this.encodeMetadata(l))) : (s = r,
                a["cache-control"] = `max-age=${o.cacheControl}`,
                a["content-type"] = o.contentType,
                l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
                i?.headers && (a = Object.assign(Object.assign({}, a), i.headers));
                const c = this._removeEmptyFolders(n)
                  , d = this._getFinalPath(c)
                  , h = yield(e == "PUT" ? Bg : Fr)(this.fetch, `${this.url}/object/${d}`, s, Object.assign({
                    headers: a
                }, o?.duplex ? {
                    duplex: o.duplex
                } : {}));
                return {
                    data: {
                        path: c,
                        id: h.Id,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (s) {
                if (Jt(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    upload(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", e, n, r)
        })
    }
    uploadToSignedUrl(e, n, r, i) {
        return Ln(this, void 0, void 0, function*() {
            const s = this._removeEmptyFolders(e)
              , o = this._getFinalPath(s)
              , a = new URL(this.url + `/object/upload/sign/${o}`);
            a.searchParams.set("token", n);
            try {
                let l;
                const c = Object.assign({
                    upsert: fv.upsert
                }, i)
                  , d = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(c.upsert)
                });
                typeof Blob < "u" && r instanceof Blob ? (l = new FormData,
                l.append("cacheControl", c.cacheControl),
                l.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (l = r,
                l.append("cacheControl", c.cacheControl)) : (l = r,
                d["cache-control"] = `max-age=${c.cacheControl}`,
                d["content-type"] = c.contentType);
                const h = yield Bg(this.fetch, a.toString(), l, {
                    headers: d
                });
                return {
                    data: {
                        path: s,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (l) {
                if (Jt(l))
                    return {
                        data: null,
                        error: l
                    };
                throw l
            }
        })
    }
    createSignedUploadUrl(e, n) {
        return Ln(this, void 0, void 0, function*() {
            try {
                let r = this._getFinalPath(e);
                const i = Object.assign({}, this.headers);
                n?.upsert && (i["x-upsert"] = "true");
                const s = yield Fr(this.fetch, `${this.url}/object/upload/sign/${r}`, {}, {
                    headers: i
                })
                  , o = new URL(this.url + s.url)
                  , a = o.searchParams.get("token");
                if (!a)
                    throw new Cy("No token returned by API");
                return {
                    data: {
                        signedUrl: o.toString(),
                        path: e,
                        token: a
                    },
                    error: null
                }
            } catch (r) {
                if (Jt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    update(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", e, n, r)
        })
    }
    move(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Fr(this.fetch, `${this.url}/object/move`, {
                        bucketId: this.bucketId,
                        sourceKey: e,
                        destinationKey: n,
                        destinationBucket: r?.destinationBucket
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (i) {
                if (Jt(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    copy(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            try {
                return {
                    data: {
                        path: (yield Fr(this.fetch, `${this.url}/object/copy`, {
                            bucketId: this.bucketId,
                            sourceKey: e,
                            destinationKey: n,
                            destinationBucket: r?.destinationBucket
                        }, {
                            headers: this.headers
                        })).Key
                    },
                    error: null
                }
            } catch (i) {
                if (Jt(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    createSignedUrl(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            try {
                let i = this._getFinalPath(e)
                  , s = yield Fr(this.fetch, `${this.url}/object/sign/${i}`, Object.assign({
                    expiresIn: n
                }, r?.transform ? {
                    transform: r.transform
                } : {}), {
                    headers: this.headers
                });
                const o = r?.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
                return s = {
                    signedUrl: encodeURI(`${this.url}${s.signedURL}${o}`)
                },
                {
                    data: s,
                    error: null
                }
            } catch (i) {
                if (Jt(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    createSignedUrls(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            try {
                const i = yield Fr(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn: n,
                    paths: e
                }, {
                    headers: this.headers
                })
                  , s = r?.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
                return {
                    data: i.map(o => Object.assign(Object.assign({}, o), {
                        signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${s}`) : null
                    })),
                    error: null
                }
            } catch (i) {
                if (Jt(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    download(e, n) {
        return Ln(this, void 0, void 0, function*() {
            const i = typeof n?.transform < "u" ? "render/image/authenticated" : "object"
              , s = this.transformOptsToQueryString(n?.transform || {})
              , o = s ? `?${s}` : "";
            try {
                const a = this._getFinalPath(e);
                return {
                    data: yield(yield th(this.fetch, `${this.url}/${i}/${a}${o}`, {
                        headers: this.headers,
                        noResolveJson: !0
                    })).blob(),
                    error: null
                }
            } catch (a) {
                if (Jt(a))
                    return {
                        data: null,
                        error: a
                    };
                throw a
            }
        })
    }
    info(e) {
        return Ln(this, void 0, void 0, function*() {
            const n = this._getFinalPath(e);
            try {
                const r = yield th(this.fetch, `${this.url}/object/info/${n}`, {
                    headers: this.headers
                });
                return {
                    data: jg(r),
                    error: null
                }
            } catch (r) {
                if (Jt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    exists(e) {
        return Ln(this, void 0, void 0, function*() {
            const n = this._getFinalPath(e);
            try {
                return yield dL(this.fetch, `${this.url}/object/${n}`, {
                    headers: this.headers
                }),
                {
                    data: !0,
                    error: null
                }
            } catch (r) {
                if (Jt(r) && r instanceof Lg) {
                    const i = r.originalError;
                    if ([400, 404].includes(i?.status))
                        return {
                            data: !1,
                            error: r
                        }
                }
                throw r
            }
        })
    }
    getPublicUrl(e, n) {
        const r = this._getFinalPath(e)
          , i = []
          , s = n?.download ? `download=${n.download === !0 ? "" : n.download}` : "";
        s !== "" && i.push(s);
        const a = typeof n?.transform < "u" ? "render/image" : "object"
          , l = this.transformOptsToQueryString(n?.transform || {});
        l !== "" && i.push(l);
        let c = i.join("&");
        return c !== "" && (c = `?${c}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${a}/public/${r}${c}`)
            }
        }
    }
    remove(e) {
        return Ln(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield u2(this.fetch, `${this.url}/object/${this.bucketId}`, {
                        prefixes: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (Jt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    list(e, n, r) {
        return Ln(this, void 0, void 0, function*() {
            try {
                const i = Object.assign(Object.assign(Object.assign({}, hL), n), {
                    prefix: e || ""
                });
                return {
                    data: yield Fr(this.fetch, `${this.url}/object/list/${this.bucketId}`, i, {
                        headers: this.headers
                    }, r),
                    error: null
                }
            } catch (i) {
                if (Jt(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    listV2(e, n) {
        return Ln(this, void 0, void 0, function*() {
            try {
                const r = Object.assign({}, e);
                return {
                    data: yield Fr(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, r, {
                        headers: this.headers
                    }, n),
                    error: null
                }
            } catch (r) {
                if (Jt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    encodeMetadata(e) {
        return JSON.stringify(e)
    }
    toBase64(e) {
        return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
        const n = [];
        return e.width && n.push(`width=${e.width}`),
        e.height && n.push(`height=${e.height}`),
        e.resize && n.push(`resize=${e.resize}`),
        e.format && n.push(`format=${e.format}`),
        e.quality && n.push(`quality=${e.quality}`),
        n.join("&")
    }
}
const pL = "2.11.0"
  , gL = {
    "X-Client-Info": `storage-js/${pL}`
};
var Mo = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
class mL {
    constructor(e, n={}, r, i) {
        const s = new URL(e);
        i?.useNewHostname && /supabase\.(co|in|red)$/.test(s.hostname) && !s.hostname.includes("storage.supabase.") && (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")),
        this.url = s.href,
        this.headers = Object.assign(Object.assign({}, gL), n),
        this.fetch = c2(r)
    }
    listBuckets() {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield th(this.fetch, `${this.url}/bucket`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (e) {
                if (Jt(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
    getBucket(e) {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield th(this.fetch, `${this.url}/bucket/${e}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (Jt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    createBucket(e, n={
        public: !1
    }) {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Fr(this.fetch, `${this.url}/bucket`, {
                        id: e,
                        name: e,
                        type: n.type,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (Jt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    updateBucket(e, n) {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Bg(this.fetch, `${this.url}/bucket/${e}`, {
                        id: e,
                        name: e,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (Jt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    emptyBucket(e) {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Fr(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (Jt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    deleteBucket(e) {
        return Mo(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield u2(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (Jt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
}
class yL extends mL {
    constructor(e, n={}, r, i) {
        super(e, n, r, i)
    }
    from(e) {
        return new fL(this.url,this.headers,e,this.fetch)
    }
}
const wL = "2.57.0";
let bl = "";
typeof Deno < "u" ? bl = "deno" : typeof document < "u" ? bl = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? bl = "react-native" : bl = "node";
const vL = {
    "X-Client-Info": `supabase-js-${bl}/${wL}`
}
  , bL = {
    headers: vL
}
  , _L = {
    schema: "public"
}
  , xL = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
}
  , SL = {};
var kL = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
const EL = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = Yk : e = fetch,
    (...n) => e(...n)
}
  , AL = () => typeof Headers > "u" ? Zk : Headers
  , IL = (t, e, n) => {
    const r = EL(n)
      , i = AL();
    return (s, o) => kL(void 0, void 0, void 0, function*() {
        var a;
        const l = (a = yield e()) !== null && a !== void 0 ? a : t;
        let c = new i(o?.headers);
        return c.has("apikey") || c.set("apikey", t),
        c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
        r(s, Object.assign(Object.assign({}, o), {
            headers: c
        }))
    })
}
;
var ML = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
function TL(t) {
    return t.endsWith("/") ? t : t + "/"
}
function NL(t, e) {
    var n, r;
    const {db: i, auth: s, realtime: o, globalThis: a} = t
      , {db: l, auth: c, realtime: d, globalThis: h} = e
      , y = {
        db: Object.assign(Object.assign({}, l), i),
        auth: Object.assign(Object.assign({}, c), s),
        realtime: Object.assign(Object.assign({}, d), o),
        storage: {},
        globalThis: Object.assign(Object.assign(Object.assign({}, h), a), {
            headers: Object.assign(Object.assign({}, (n = h?.headers) !== null && n !== void 0 ? n : {}), (r = a?.headers) !== null && r !== void 0 ? r : {})
        }),
        accessToken: () => ML(this, void 0, void 0, function*() {
            return ""
        })
    };
    return t.accessToken ? y.accessToken = t.accessToken : delete y.accessToken,
    y
}
const d2 = "2.71.1"
  , Fo = 30 * 1e3
  , Pg = 3
  , A0 = Pg * Fo
  , CL = "http://localhost:9999"
  , RL = "supabase.auth.token"
  , LL = {
    "X-Client-Info": `gotrue-js/${d2}`
}
  , Og = "X-Supabase-Api-Version"
  , h2 = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , jL = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , BL = 10 * 60 * 1e3;
class Ry extends Error {
    constructor(e, n, r) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = n,
        this.code = r
    }
}
function ke(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
class PL extends Ry {
    constructor(e, n, r) {
        super(e, n, r),
        this.name = "AuthApiError",
        this.status = n,
        this.code = r
    }
}
function OL(t) {
    return ke(t) && t.name === "AuthApiError"
}
class f2 extends Ry {
    constructor(e, n) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = n
    }
}
class Ss extends Ry {
    constructor(e, n, r, i) {
        super(e, r, i),
        this.name = n,
        this.status = r
    }
}
class $i extends Ss {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
function DL(t) {
    return ke(t) && t.name === "AuthSessionMissingError"
}
class hu extends Ss {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
class fu extends Ss {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
class pu extends Ss {
    constructor(e, n=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
function zL(t) {
    return ke(t) && t.name === "AuthImplicitGrantRedirectError"
}
class pv extends Ss {
    constructor(e, n=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
class Dg extends Ss {
    constructor(e, n) {
        super(e, "AuthRetryableFetchError", n, void 0)
    }
}
function I0(t) {
    return ke(t) && t.name === "AuthRetryableFetchError"
}
class gv extends Ss {
    constructor(e, n, r) {
        super(e, "AuthWeakPasswordError", n, "weak_password"),
        this.reasons = r
    }
}
class zg extends Ss {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
const nh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , mv = ` 	
\r=`.split("")
  , UL = ( () => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < mv.length; e += 1)
        t[mv[e].charCodeAt(0)] = -2;
    for (let e = 0; e < nh.length; e += 1)
        t[nh[e].charCodeAt(0)] = e;
    return t
}
)();
function yv(t, e, n) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const r = e.queue >> e.queuedBits - 6 & 63;
            n(nh[r]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const r = e.queue >> e.queuedBits - 6 & 63;
            n(nh[r]),
            e.queuedBits -= 6
        }
}
function p2(t, e, n) {
    const r = UL[t];
    if (r > -1)
        for (e.queue = e.queue << 6 | r,
        e.queuedBits += 6; e.queuedBits >= 8; )
            n(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (r === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function wv(t) {
    const e = []
      , n = o => {
        e.push(String.fromCodePoint(o))
    }
      , r = {
        utf8seq: 0,
        codepoint: 0
    }
      , i = {
        queue: 0,
        queuedBits: 0
    }
      , s = o => {
        $L(o, r, n)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        p2(t.charCodeAt(o), i, s);
    return e.join("")
}
function WL(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function FL(t, e) {
    for (let n = 0; n < t.length; n += 1) {
        let r = t.charCodeAt(n);
        if (r > 55295 && r <= 56319) {
            const i = (r - 55296) * 1024 & 65535;
            r = (t.charCodeAt(n + 1) - 56320 & 65535 | i) + 65536,
            n += 1
        }
        WL(r, e)
    }
}
function $L(t, e, n) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            n(t);
            return
        }
        for (let r = 1; r < 6; r += 1)
            if (!(t >> 7 - r & 1)) {
                e.utf8seq = r;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && n(e.codepoint)
    }
}
function KL(t) {
    const e = []
      , n = {
        queue: 0,
        queuedBits: 0
    }
      , r = i => {
        e.push(i)
    }
    ;
    for (let i = 0; i < t.length; i += 1)
        p2(t.charCodeAt(i), n, r);
    return new Uint8Array(e)
}
function VL(t) {
    const e = [];
    return FL(t, n => e.push(n)),
    new Uint8Array(e)
}
function HL(t) {
    const e = []
      , n = {
        queue: 0,
        queuedBits: 0
    }
      , r = i => {
        e.push(i)
    }
    ;
    return t.forEach(i => yv(i, n, r)),
    yv(null, n, r),
    e.join("")
}
function qL(t) {
    return Math.round(Date.now() / 1e3) + t
}
function GL() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
        const e = Math.random() * 16 | 0;
        return (t == "x" ? e : e & 3 | 8).toString(16)
    })
}
const Ar = () => typeof window < "u" && typeof document < "u"
  , ks = {
    tested: !1,
    writable: !1
}
  , g2 = () => {
    if (!Ar())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (ks.tested)
        return ks.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        ks.tested = !0,
        ks.writable = !0
    } catch {
        ks.tested = !0,
        ks.writable = !1
    }
    return ks.writable
}
;
function YL(t) {
    const e = {}
      , n = new URL(t);
    if (n.hash && n.hash[0] === "#")
        try {
            new URLSearchParams(n.hash.substring(1)).forEach( (i, s) => {
                e[s] = i
            }
            )
        } catch {}
    return n.searchParams.forEach( (r, i) => {
        e[i] = r
    }
    ),
    e
}
const m2 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => bo( () => Promise.resolve().then( () => Va), void 0).then( ({default: r}) => r(...n)) : e = fetch,
    (...n) => e(...n)
}
  , ZL = t => typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , $o = async (t, e, n) => {
    await t.setItem(e, JSON.stringify(n))
}
  , Es = async (t, e) => {
    const n = await t.getItem(e);
    if (!n)
        return null;
    try {
        return JSON.parse(n)
    } catch {
        return n
    }
}
  , zi = async (t, e) => {
    await t.removeItem(e)
}
;
class Jh {
    constructor() {
        this.promise = new Jh.promiseConstructor( (e, n) => {
            this.resolve = e,
            this.reject = n
        }
        )
    }
}
Jh.promiseConstructor = Promise;
function M0(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new zg("Invalid JWT structure");
    for (let r = 0; r < e.length; r++)
        if (!jL.test(e[r]))
            throw new zg("JWT not in base64url format");
    return {
        header: JSON.parse(wv(e[0])),
        payload: JSON.parse(wv(e[1])),
        signature: KL(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function QL(t) {
    return await new Promise(e => {
        setTimeout( () => e(null), t)
    }
    )
}
function JL(t, e) {
    return new Promise( (r, i) => {
        (async () => {
            for (let s = 0; s < 1 / 0; s++)
                try {
                    const o = await t(s);
                    if (!e(s, null, o)) {
                        r(o);
                        return
                    }
                } catch (o) {
                    if (!e(s, o)) {
                        i(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function XL(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function e8() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , r = n.length;
        let i = "";
        for (let s = 0; s < 56; s++)
            i += n.charAt(Math.floor(Math.random() * r));
        return i
    }
    return crypto.getRandomValues(e),
    Array.from(e, XL).join("")
}
async function t8(t) {
    const n = new TextEncoder().encode(t)
      , r = await crypto.subtle.digest("SHA-256", n)
      , i = new Uint8Array(r);
    return Array.from(i).map(s => String.fromCharCode(s)).join("")
}
async function n8(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const n = await t8(t);
    return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function To(t, e, n=!1) {
    const r = e8();
    let i = r;
    n && (i += "/PASSWORD_RECOVERY"),
    await $o(t, `${e}-code-verifier`, i);
    const s = await n8(r);
    return [s, r === s ? "plain" : "s256"]
}
const r8 = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function i8(t) {
    const e = t.headers.get(Og);
    if (!e || !e.match(r8))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function s8(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function o8(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const a8 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function No(t) {
    if (!a8.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function T0() {
    const t = {};
    return new Proxy(t,{
        get: (e, n) => {
            if (n === "__isUserNotAvailableProxy")
                return !0;
            if (typeof n == "symbol") {
                const r = n.toString();
                if (r === "Symbol(Symbol.toPrimitive)" || r === "Symbol(Symbol.toStringTag)" || r === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${n}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e, n) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e, n) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function vv(t) {
    return JSON.parse(JSON.stringify(t))
}
var l8 = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}
;
const Ls = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , c8 = [502, 503, 504];
async function bv(t) {
    var e;
    if (!ZL(t))
        throw new Dg(Ls(t),0);
    if (c8.includes(t.status))
        throw new Dg(Ls(t),t.status);
    let n;
    try {
        n = await t.json()
    } catch (s) {
        throw new f2(Ls(s),s)
    }
    let r;
    const i = i8(t);
    if (i && i.getTime() >= h2["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? r = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (r = n.error_code),
    r) {
        if (r === "weak_password")
            throw new gv(Ls(n),t.status,((e = n.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (r === "session_not_found")
            throw new $i
    } else if (typeof n == "object" && n && typeof n.weak_password == "object" && n.weak_password && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.reasons.reduce( (s, o) => s && typeof o == "string", !0))
        throw new gv(Ls(n),t.status,n.weak_password.reasons);
    throw new PL(Ls(n),t.status || 500,r)
}
const u8 = (t, e, n, r) => {
    const i = {
        method: t,
        headers: e?.headers || {}
    };
    return t === "GET" ? i : (i.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e?.headers),
    i.body = JSON.stringify(r),
    Object.assign(Object.assign({}, i), n))
}
;
async function Ne(t, e, n, r) {
    var i;
    const s = Object.assign({}, r?.headers);
    s[Og] || (s[Og] = h2["2024-01-01"].name),
    r?.jwt && (s.Authorization = `Bearer ${r.jwt}`);
    const o = (i = r?.query) !== null && i !== void 0 ? i : {};
    r?.redirectTo && (o.redirect_to = r.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await d8(t, e, n + a, {
        headers: s,
        noResolveJson: r?.noResolveJson
    }, {}, r?.body);
    return r?.xform ? r?.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function d8(t, e, n, r, i, s) {
    const o = u8(e, r, i, s);
    let a;
    try {
        a = await t(n, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new Dg(Ls(l),0)
    }
    if (a.ok || await bv(a),
    r?.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await bv(l)
    }
}
function hi(t) {
    var e;
    let n = null;
    g8(t) && (n = Object.assign({}, t),
    t.expires_at || (n.expires_at = qL(t.expires_in)));
    const r = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: n,
            user: r
        },
        error: null
    }
}
function _v(t) {
    const e = hi(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce( (n, r) => n && typeof r == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function Zi(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function h8(t) {
    return {
        data: t,
        error: null
    }
}
function f8(t) {
    const {action_link: e, email_otp: n, hashed_token: r, redirect_to: i, verification_type: s} = t
      , o = l8(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: n,
        hashed_token: r,
        redirect_to: i,
        verification_type: s
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function p8(t) {
    return t
}
function g8(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const N0 = ["globalThis", "local", "others"];
var m8 = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}
;
class y8 {
    constructor({url: e="", headers: n={}, fetch: r}) {
        this.url = e,
        this.headers = n,
        this.fetch = m2(r),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        }
    }
    async signOut(e, n=N0[0]) {
        if (N0.indexOf(n) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${N0.join(", ")}`);
        try {
            return await Ne(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (r) {
            if (ke(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async inviteUserByEmail(e, n={}) {
        try {
            return await Ne(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: n.data
                },
                headers: this.headers,
                redirectTo: n.redirectTo,
                xform: Zi
            })
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async generateLink(e) {
        try {
            const {options: n} = e
              , r = m8(e, ["options"])
              , i = Object.assign(Object.assign({}, r), n);
            return "newEmail"in r && (i.new_email = r?.newEmail,
            delete i.newEmail),
            await Ne(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: i,
                headers: this.headers,
                xform: f8,
                redirectTo: n?.redirectTo
            })
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async createUser(e) {
        try {
            return await Ne(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: Zi
            })
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async listUsers(e) {
        var n, r, i, s, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , d = await Ne(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (r = (n = e?.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "",
                    per_page: (s = (i = e?.perPage) === null || i === void 0 ? void 0 : i.toString()) !== null && s !== void 0 ? s : ""
                },
                xform: p8
            });
            if (d.error)
                throw d.error;
            const h = await d.json()
              , y = (o = d.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , m = (l = (a = d.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return m.length > 0 && (m.forEach(v => {
                const E = parseInt(v.split(";")[0].split("=")[1].substring(0, 1))
                  , A = JSON.parse(v.split(";")[1].split("=")[1]);
                c[`${A}Page`] = E
            }
            ),
            c.total = parseInt(y)),
            {
                data: Object.assign(Object.assign({}, h), c),
                error: null
            }
        } catch (c) {
            if (ke(c))
                return {
                    data: {
                        users: []
                    },
                    error: c
                };
            throw c
        }
    }
    async getUserById(e) {
        No(e);
        try {
            return await Ne(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: Zi
            })
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async updateUserById(e, n) {
        No(e);
        try {
            return await Ne(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: n,
                headers: this.headers,
                xform: Zi
            })
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async deleteUser(e, n=!1) {
        No(e);
        try {
            return await Ne(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: n
                },
                xform: Zi
            })
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async _listFactors(e) {
        No(e.userId);
        try {
            const {data: n, error: r} = await Ne(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: i => ({
                    data: {
                        factors: i
                    },
                    error: null
                })
            });
            return {
                data: n,
                error: r
            }
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteFactor(e) {
        No(e.userId),
        No(e.id);
        try {
            return {
                data: await Ne(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
}
function xv(t={}) {
    return {
        getItem: e => t[e] || null,
        setItem: (e, n) => {
            t[e] = n
        }
        ,
        removeItem: e => {
            delete t[e]
        }
    }
}
function w8() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
const Co = {
    debug: !!(globalThis && g2() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class y2 extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
class v8 extends y2 {
}
async function b8(t, e, n) {
    Co.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const r = new globalThis.AbortController;
    return e > 0 && setTimeout( () => {
        r.abort(),
        Co.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then( () => globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: r.signal
    }, async i => {
        if (i) {
            Co.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, i.name);
            try {
                return await n()
            } finally {
                Co.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, i.name)
            }
        } else {
            if (e === 0)
                throw Co.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new v8(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (Co.debug)
                try {
                    const s = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(s, null, "  "))
                } catch (s) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", s)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await n()
        }
    }
    ))
}
w8();
const _8 = {
    url: CL,
    storageKey: RL,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: LL,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1
};
async function Sv(t, e, n) {
    return await n()
}
const Ro = {};
class hc {
    constructor(e) {
        var n, r;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log,
        this.instanceID = hc.nextInstanceID,
        hc.nextInstanceID += 1,
        this.instanceID > 0 && Ar() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
        const i = Object.assign(Object.assign({}, _8), e);
        if (this.logDebugMessages = !!i.debug,
        typeof i.debug == "function" && (this.logger = i.debug),
        this.persistSession = i.persistSession,
        this.storageKey = i.storageKey,
        this.autoRefreshToken = i.autoRefreshToken,
        this.admin = new y8({
            url: i.url,
            headers: i.headers,
            fetch: i.fetch
        }),
        this.url = i.url,
        this.headers = i.headers,
        this.fetch = m2(i.fetch),
        this.lock = i.lock || Sv,
        this.detectSessionInUrl = i.detectSessionInUrl,
        this.flowType = i.flowType,
        this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader,
        i.lock ? this.lock = i.lock : Ar() && (!((n = globalThis?.navigator) === null || n === void 0) && n.locks) ? this.lock = b8 : this.lock = Sv,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
        },
        this.persistSession ? (i.storage ? this.storage = i.storage : g2() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = xv(this.memoryStorage)),
        i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {},
        this.storage = xv(this.memoryStorage)),
        Ar() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (s) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", s)
            }
            (r = this.broadcastChannel) === null || r === void 0 || r.addEventListener("message", async s => {
                this._debug("received broadcast notification from other tab or client", s),
                await this._notifyAllSubscribers(s.data.event, s.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    get jwks() {
        var e, n;
        return (n = (e = Ro[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && n !== void 0 ? n : {
            keys: []
        }
    }
    set jwks(e) {
        Ro[this.storageKey] = Object.assign(Object.assign({}, Ro[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, n;
        return (n = (e = Ro[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && n !== void 0 ? n : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        Ro[this.storageKey] = Object.assign(Object.assign({}, Ro[this.storageKey]), {
            cachedAt: e
        })
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${d2}) ${new Date().toISOString()}`, ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            const n = YL(window.location.href);
            let r = "none";
            if (this._isImplicitGrantCallback(n) ? r = "implicit" : await this._isPKCECallback(n) && (r = "pkce"),
            Ar() && this.detectSessionInUrl && r !== "none") {
                const {data: i, error: s} = await this._getSessionFromURL(n, r);
                if (s) {
                    if (this._debug("#_initialize()", "error detecting session from URL", s),
                    zL(s)) {
                        const l = (e = s.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: s
                            }
                    }
                    return await this._removeSession(),
                    {
                        error: s
                    }
                }
                const {session: o, redirectType: a} = i;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async () => {
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (n) {
            return ke(n) ? {
                error: n
            } : {
                error: new f2("Unexpected error during initialization",n)
            }
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var n, r, i;
        try {
            const s = await Ne(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (r = (n = e?.options) === null || n === void 0 ? void 0 : n.data) !== null && r !== void 0 ? r : {},
                    gotrue_meta_security: {
                        captcha_token: (i = e?.options) === null || i === void 0 ? void 0 : i.captchaToken
                    }
                },
                xform: hi
            })
              , {data: o, error: a} = s;
            if (a || !o)
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (s) {
            if (ke(s))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signUp(e) {
        var n, r, i;
        try {
            let s;
            if ("email"in e) {
                const {email: d, password: h, options: y} = e;
                let m = null
                  , v = null;
                this.flowType === "pkce" && ([m,v] = await To(this.storage, this.storageKey)),
                s = await Ne(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: y?.emailRedirectTo,
                    body: {
                        email: d,
                        password: h,
                        data: (n = y?.data) !== null && n !== void 0 ? n : {},
                        gotrue_meta_security: {
                            captcha_token: y?.captchaToken
                        },
                        code_challenge: m,
                        code_challenge_method: v
                    },
                    xform: hi
                })
            } else if ("phone"in e) {
                const {phone: d, password: h, options: y} = e;
                s = await Ne(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: d,
                        password: h,
                        data: (r = y?.data) !== null && r !== void 0 ? r : {},
                        channel: (i = y?.channel) !== null && i !== void 0 ? i : "sms",
                        gotrue_meta_security: {
                            captcha_token: y?.captchaToken
                        }
                    },
                    xform: hi
                })
            } else
                throw new fu("You must provide either an email or phone number and a password");
            const {data: o, error: a} = s;
            if (a || !o)
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (s) {
            if (ke(s))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signInWithPassword(e) {
        try {
            let n;
            if ("email"in e) {
                const {email: s, password: o, options: a} = e;
                n = await Ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: s,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a?.captchaToken
                        }
                    },
                    xform: _v
                })
            } else if ("phone"in e) {
                const {phone: s, password: o, options: a} = e;
                n = await Ne(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: s,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a?.captchaToken
                        }
                    },
                    xform: _v
                })
            } else
                throw new fu("You must provide either an email or phone number and a password");
            const {data: r, error: i} = n;
            return i ? {
                data: {
                    user: null,
                    session: null
                },
                error: i
            } : !r || !r.session || !r.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new hu
            } : (r.session && (await this._saveSession(r.session),
            await this._notifyAllSubscribers("SIGNED_IN", r.session)),
            {
                data: Object.assign({
                    user: r.user,
                    session: r.session
                }, r.weak_password ? {
                    weakPassword: r.weak_password
                } : null),
                error: i
            })
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async signInWithOAuth(e) {
        var n, r, i, s;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
            scopes: (r = e.options) === null || r === void 0 ? void 0 : r.scopes,
            queryParams: (i = e.options) === null || i === void 0 ? void 0 : i.queryParams,
            skipBrowserRedirect: (s = e.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: n} = e;
        if (n === "solana")
            return await this.signInWithSolana(e);
        throw new Error(`@supabase/auth-js: Unsupported chain "${n}"`)
    }
    async signInWithSolana(e) {
        var n, r, i, s, o, a, l, c, d, h, y, m;
        let v, E;
        if ("message"in e)
            v = e.message,
            E = e.signature;
        else {
            const {chain: A, wallet: _, statement: x, options: b} = e;
            let R;
            if (Ar())
                if (typeof _ == "object")
                    R = _;
                else {
                    const D = window;
                    if ("solana"in D && typeof D.solana == "object" && ("signIn"in D.solana && typeof D.solana.signIn == "function" || "signMessage"in D.solana && typeof D.solana.signMessage == "function"))
                        R = D.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof _ != "object" || !b?.url)
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                R = _
            }
            const O = new URL((n = b?.url) !== null && n !== void 0 ? n : window.location.href);
            if ("signIn"in R && R.signIn) {
                const D = await R.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, b?.signInWithSolana), {
                    version: "1",
                    domain: O.host,
                    uri: O.href
                }), x ? {
                    statement: x
                } : null));
                let z;
                if (Array.isArray(D) && D[0] && typeof D[0] == "object")
                    z = D[0];
                else if (D && typeof D == "object" && "signedMessage"in D && "signature"in D)
                    z = D;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in z && "signature"in z && (typeof z.signedMessage == "string" || z.signedMessage instanceof Uint8Array) && z.signature instanceof Uint8Array)
                    v = typeof z.signedMessage == "string" ? z.signedMessage : new TextDecoder().decode(z.signedMessage),
                    E = z.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in R) || typeof R.signMessage != "function" || !("publicKey"in R) || typeof R != "object" || !R.publicKey || !("toBase58"in R.publicKey) || typeof R.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                v = [`${O.host} wants you to sign in with your Solana account:`, R.publicKey.toBase58(), ...x ? ["", x, ""] : [""], "Version: 1", `URI: ${O.href}`, `Issued At: ${(i = (r = b?.signInWithSolana) === null || r === void 0 ? void 0 : r.issuedAt) !== null && i !== void 0 ? i : new Date().toISOString()}`, ...!((s = b?.signInWithSolana) === null || s === void 0) && s.notBefore ? [`Not Before: ${b.signInWithSolana.notBefore}`] : [], ...!((o = b?.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${b.signInWithSolana.expirationTime}`] : [], ...!((a = b?.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${b.signInWithSolana.chainId}`] : [], ...!((l = b?.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${b.signInWithSolana.nonce}`] : [], ...!((c = b?.signInWithSolana) === null || c === void 0) && c.requestId ? [`Request ID: ${b.signInWithSolana.requestId}`] : [], ...!((h = (d = b?.signInWithSolana) === null || d === void 0 ? void 0 : d.resources) === null || h === void 0) && h.length ? ["Resources", ...b.signInWithSolana.resources.map(z => `- ${z}`)] : []].join(`
`);
                const D = await R.signMessage(new TextEncoder().encode(v), "utf8");
                if (!D || !(D instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                E = D
            }
        }
        try {
            const {data: A, error: _} = await Ne(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: v,
                    signature: HL(E)
                }, !((y = e.options) === null || y === void 0) && y.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (m = e.options) === null || m === void 0 ? void 0 : m.captchaToken
                    }
                } : null),
                xform: hi
            });
            if (_)
                throw _;
            return !A || !A.session || !A.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new hu
            } : (A.session && (await this._saveSession(A.session),
            await this._notifyAllSubscribers("SIGNED_IN", A.session)),
            {
                data: Object.assign({}, A),
                error: _
            })
        } catch (A) {
            if (ke(A))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: A
                };
            throw A
        }
    }
    async _exchangeCodeForSession(e) {
        const n = await Es(this.storage, `${this.storageKey}-code-verifier`)
          , [r,i] = (n ?? "").split("/");
        try {
            const {data: s, error: o} = await Ne(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: r
                },
                xform: hi
            });
            if (await zi(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            return !s || !s.session || !s.user ? {
                data: {
                    user: null,
                    session: null,
                    redirectType: null
                },
                error: new hu
            } : (s.session && (await this._saveSession(s.session),
            await this._notifyAllSubscribers("SIGNED_IN", s.session)),
            {
                data: Object.assign(Object.assign({}, s), {
                    redirectType: i ?? null
                }),
                error: o
            })
        } catch (s) {
            if (ke(s))
                return {
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: n, provider: r, token: i, access_token: s, nonce: o} = e
              , a = await Ne(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: r,
                    id_token: i,
                    access_token: s,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: n?.captchaToken
                    }
                },
                xform: hi
            })
              , {data: l, error: c} = a;
            return c ? {
                data: {
                    user: null,
                    session: null
                },
                error: c
            } : !l || !l.session || !l.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new hu
            } : (l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            {
                data: l,
                error: c
            })
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async signInWithOtp(e) {
        var n, r, i, s, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let c = null
                  , d = null;
                this.flowType === "pkce" && ([c,d] = await To(this.storage, this.storageKey));
                const {error: h} = await Ne(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (n = l?.data) !== null && n !== void 0 ? n : {},
                        create_user: (r = l?.shouldCreateUser) !== null && r !== void 0 ? r : !0,
                        gotrue_meta_security: {
                            captcha_token: l?.captchaToken
                        },
                        code_challenge: c,
                        code_challenge_method: d
                    },
                    redirectTo: l?.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: h
                }
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: c, error: d} = await Ne(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (i = l?.data) !== null && i !== void 0 ? i : {},
                        create_user: (s = l?.shouldCreateUser) !== null && s !== void 0 ? s : !0,
                        gotrue_meta_security: {
                            captcha_token: l?.captchaToken
                        },
                        channel: (o = l?.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: c?.message_id
                    },
                    error: d
                }
            }
            throw new fu("You must provide either an email or phone number.")
        } catch (a) {
            if (ke(a))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            throw a
        }
    }
    async verifyOtp(e) {
        var n, r;
        try {
            let i, s;
            "options"in e && (i = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
            s = (r = e.options) === null || r === void 0 ? void 0 : r.captchaToken);
            const {data: o, error: a} = await Ne(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: s
                    }
                }),
                redirectTo: i,
                xform: hi
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , c = o.user;
            return l?.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (i) {
            if (ke(i))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                };
            throw i
        }
    }
    async signInWithSSO(e) {
        var n, r, i;
        try {
            let s = null
              , o = null;
            return this.flowType === "pkce" && ([s,o] = await To(this.storage, this.storageKey)),
            await Ne(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && r !== void 0 ? r : void 0
                }), !((i = e?.options) === null || i === void 0) && i.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: s,
                    code_challenge_method: o
                }),
                headers: this.headers,
                xform: h8
            })
        } catch (s) {
            if (ke(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e => {
                const {data: {session: n}, error: r} = e;
                if (r)
                    throw r;
                if (!n)
                    throw new $i;
                const {error: i} = await Ne(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: n.access_token
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                }
            }
            )
        } catch (e) {
            if (ke(e))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                };
            throw e
        }
    }
    async resend(e) {
        try {
            const n = `${this.url}/resend`;
            if ("email"in e) {
                const {email: r, type: i, options: s} = e
                  , {error: o} = await Ne(this.fetch, "POST", n, {
                    headers: this.headers,
                    body: {
                        email: r,
                        type: i,
                        gotrue_meta_security: {
                            captcha_token: s?.captchaToken
                        }
                    },
                    redirectTo: s?.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                }
            } else if ("phone"in e) {
                const {phone: r, type: i, options: s} = e
                  , {data: o, error: a} = await Ne(this.fetch, "POST", n, {
                    headers: this.headers,
                    body: {
                        phone: r,
                        type: i,
                        gotrue_meta_security: {
                            captcha_token: s?.captchaToken
                        }
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: o?.message_id
                    },
                    error: a
                }
            }
            throw new fu("You must provide either an email or phone number and a type")
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => this._useSession(async n => n))
    }
    async _acquireLock(e, n) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , i = (async () => (await r,
                await n()))();
                return this.pendingInLock.push((async () => {
                    try {
                        await i
                    } catch {}
                }
                )()),
                i
            }
            return await this.lock(`lock:${this.storageKey}`, e, async () => {
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const r = n();
                    for (this.pendingInLock.push((async () => {
                        try {
                            await r
                        } catch {}
                    }
                    )()),
                    await r; this.pendingInLock.length; ) {
                        const i = [...this.pendingInLock];
                        await Promise.all(i),
                        this.pendingInLock.splice(0, i.length)
                    }
                    return await r
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const n = await this.__loadSession();
            return await e(n)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const n = await Es(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", n),
            n !== null && (this._isValidSession(n) ? e = n : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const r = e.expires_at ? e.expires_at * 1e3 - Date.now() < A0 : !1;
            if (this._debug("#__loadSession()", `session has${r ? "" : " not"} expired`, "expires_at", e.expires_at),
            !r) {
                if (this.userStorage) {
                    const o = await Es(this.userStorage, this.storageKey + "-user");
                    o?.user ? e.user = o.user : e.user = T0()
                }
                if (this.storage.isServer && e.user) {
                    let o = this.suppressGetSessionWarning;
                    e = new Proxy(e,{
                        get: (l, c, d) => (!o && c === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
                        o = !0,
                        this.suppressGetSessionWarning = !0),
                        Reflect.get(l, c, d))
                    })
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {session: i, error: s} = await this._callRefreshToken(e.refresh_token);
            return s ? {
                data: {
                    session: null
                },
                error: s
            } : {
                data: {
                    session: i
                },
                error: null
            }
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        return e ? await this._getUser(e) : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()))
    }
    async _getUser(e) {
        try {
            return e ? await Ne(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: Zi
            }) : await this._useSession(async n => {
                var r, i, s;
                const {data: o, error: a} = n;
                if (a)
                    throw a;
                return !(!((r = o.session) === null || r === void 0) && r.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new $i
                } : await Ne(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (s = (i = o.session) === null || i === void 0 ? void 0 : i.access_token) !== null && s !== void 0 ? s : void 0,
                    xform: Zi
                })
            }
            )
        } catch (n) {
            if (ke(n))
                return DL(n) && (await this._removeSession(),
                await zi(this.storage, `${this.storageKey}-code-verifier`)),
                {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async updateUser(e, n={}) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._updateUser(e, n))
    }
    async _updateUser(e, n={}) {
        try {
            return await this._useSession(async r => {
                const {data: i, error: s} = r;
                if (s)
                    throw s;
                if (!i.session)
                    throw new $i;
                const o = i.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await To(this.storage, this.storageKey));
                const {data: c, error: d} = await Ne(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: n?.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: Zi
                });
                if (d)
                    throw d;
                return o.user = c.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                {
                    data: {
                        user: o.user
                    },
                    error: null
                }
            }
            )
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new $i;
            const n = Date.now() / 1e3;
            let r = n
              , i = !0
              , s = null;
            const {payload: o} = M0(e.access_token);
            if (o.exp && (r = o.exp,
            i = r <= n),
            i) {
                const {session: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    };
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                s = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                s = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: r - n,
                    expires_at: r
                },
                await this._saveSession(s),
                await this._notifyAllSubscribers("SIGNED_IN", s)
            }
            return {
                data: {
                    user: s.user,
                    session: s
                },
                error: null
            }
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async n => {
                var r;
                if (!e) {
                    const {data: o, error: a} = n;
                    if (a)
                        throw a;
                    e = (r = o.session) !== null && r !== void 0 ? r : void 0
                }
                if (!e?.refresh_token)
                    throw new $i;
                const {session: i, error: s} = await this._callRefreshToken(e.refresh_token);
                return s ? {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                } : i ? {
                    data: {
                        user: i.user,
                        session: i
                    },
                    error: null
                } : {
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                }
            }
            )
        } catch (n) {
            if (ke(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _getSessionFromURL(e, n) {
        try {
            if (!Ar())
                throw new pu("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new pu(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (n) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new pv("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new pu("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (n === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new pv("No code detected.");
                const {data: x, error: b} = await this._exchangeCodeForSession(e.code);
                if (b)
                    throw b;
                const R = new URL(window.location.href);
                return R.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", R.toString()),
                {
                    data: {
                        session: x.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: r, provider_refresh_token: i, access_token: s, refresh_token: o, expires_in: a, expires_at: l, token_type: c} = e;
            if (!s || !a || !o || !c)
                throw new pu("No session defined in URL");
            const d = Math.round(Date.now() / 1e3)
              , h = parseInt(a);
            let y = d + h;
            l && (y = parseInt(l));
            const m = y - d;
            m * 1e3 <= Fo && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${m}s, should have been closer to ${h}s`);
            const v = y - h;
            d - v >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", v, y, d) : d - v < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", v, y, d);
            const {data: E, error: A} = await this._getUser(s);
            if (A)
                throw A;
            const _ = {
                provider_token: r,
                provider_refresh_token: i,
                access_token: s,
                expires_in: h,
                expires_at: y,
                refresh_token: o,
                token_type: c,
                user: E.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            {
                data: {
                    session: _,
                    redirectType: e.type
                },
                error: null
            }
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: r
                };
            throw r
        }
    }
    _isImplicitGrantCallback(e) {
        return !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const n = await Es(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && n)
    }
    async signOut(e={
        scope: "globalThis"
    }) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "globalThis"
    }) {
        return await this._useSession(async n => {
            var r;
            const {data: i, error: s} = n;
            if (s)
                return {
                    error: s
                };
            const o = (r = i.session) === null || r === void 0 ? void 0 : r.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(OL(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return {
                        error: a
                    }
            }
            return e !== "others" && (await this._removeSession(),
            await zi(this.storage, `${this.storageKey}-code-verifier`)),
            {
                error: null
            }
        }
        )
    }
    onAuthStateChange(e) {
        const n = GL()
          , r = {
            id: n,
            callback: e,
            unsubscribe: () => {
                this._debug("#unsubscribe()", "state change callback with id removed", n),
                this.stateChangeEmitters.delete(n)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", n),
        this.stateChangeEmitters.set(n, r),
        (async () => (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            this._emitInitialSession(n)
        }
        )))(),
        {
            data: {
                subscription: r
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async n => {
            var r, i;
            try {
                const {data: {session: s}, error: o} = n;
                if (o)
                    throw o;
                await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", s)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", s)
            } catch (s) {
                await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0 ? void 0 : i.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", s),
                console.error(s)
            }
        }
        )
    }
    async resetPasswordForEmail(e, n={}) {
        let r = null
          , i = null;
        this.flowType === "pkce" && ([r,i] = await To(this.storage, this.storageKey, !0));
        try {
            return await Ne(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: r,
                    code_challenge_method: i,
                    gotrue_meta_security: {
                        captcha_token: n.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: n.redirectTo
            })
        } catch (s) {
            if (ke(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: n, error: r} = await this.getUser();
            if (r)
                throw r;
            return {
                data: {
                    identities: (e = n.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            }
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async linkIdentity(e) {
        var n;
        try {
            const {data: r, error: i} = await this._useSession(async s => {
                var o, a, l, c, d;
                const {data: h, error: y} = s;
                if (y)
                    throw y;
                const m = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await Ne(this.fetch, "GET", m, {
                    headers: this.headers,
                    jwt: (d = (c = h.session) === null || c === void 0 ? void 0 : c.access_token) !== null && d !== void 0 ? d : void 0
                })
            }
            );
            if (i)
                throw i;
            return Ar() && !(!((n = e.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(r?.url),
            {
                data: {
                    provider: e.provider,
                    url: r?.url
                },
                error: null
            }
        } catch (r) {
            if (ke(r))
                return {
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: r
                };
            throw r
        }
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async n => {
                var r, i;
                const {data: s, error: o} = n;
                if (o)
                    throw o;
                return await Ne(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (i = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && i !== void 0 ? i : void 0
                })
            }
            )
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _refreshAccessToken(e) {
        const n = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(n, "begin");
        try {
            const r = Date.now();
            return await JL(async i => (i > 0 && await QL(200 * Math.pow(2, i - 1)),
            this._debug(n, "refreshing attempt", i),
            await Ne(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: hi
            })), (i, s) => {
                const o = 200 * Math.pow(2, i);
                return s && I0(s) && Date.now() + o - r < Fo
            }
            )
        } catch (r) {
            if (this._debug(n, "error", r),
            ke(r))
                return {
                    data: {
                        session: null,
                        user: null
                    },
                    error: r
                };
            throw r
        } finally {
            this._debug(n, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, n) {
        const r = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: n.redirectTo,
            scopes: n.scopes,
            queryParams: n.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", n, "url", r),
        Ar() && !n.skipBrowserRedirect && window.location.assign(r),
        {
            data: {
                provider: e,
                url: r
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, n;
        const r = "#_recoverAndRefresh()";
        this._debug(r, "begin");
        try {
            const i = await Es(this.storage, this.storageKey);
            if (i && this.userStorage) {
                let o = await Es(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: i.user
                },
                await $o(this.userStorage, this.storageKey + "-user", o)),
                i.user = (e = o?.user) !== null && e !== void 0 ? e : T0()
            } else if (i && !i.user && !i.user) {
                const o = await Es(this.storage, this.storageKey + "-user");
                o && o?.user ? (i.user = o.user,
                await zi(this.storage, this.storageKey + "-user"),
                await $o(this.storage, this.storageKey, i)) : i.user = T0()
            }
            if (this._debug(r, "session from storage", i),
            !this._isValidSession(i)) {
                this._debug(r, "session is not valid"),
                i !== null && await this._removeSession();
                return
            }
            const s = ((n = i.expires_at) !== null && n !== void 0 ? n : 1 / 0) * 1e3 - Date.now() < A0;
            if (this._debug(r, `session has${s ? "" : " not"} expired with margin of ${A0}s`),
            s) {
                if (this.autoRefreshToken && i.refresh_token) {
                    const {error: o} = await this._callRefreshToken(i.refresh_token);
                    o && (console.error(o),
                    I0(o) || (this._debug(r, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (i.user && i.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(i.access_token);
                    !a && o?.user ? (i.user = o.user,
                    await this._saveSession(i),
                    await this._notifyAllSubscribers("SIGNED_IN", i)) : this._debug(r, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(r, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", i)
        } catch (i) {
            this._debug(r, "error", i),
            console.error(i);
            return
        } finally {
            this._debug(r, "end")
        }
    }
    async _callRefreshToken(e) {
        var n, r;
        if (!e)
            throw new $i;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const i = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(i, "begin");
        try {
            this.refreshingDeferred = new Jh;
            const {data: s, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!s.session)
                throw new $i;
            await this._saveSession(s.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
            const a = {
                session: s.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (s) {
            if (this._debug(i, "error", s),
            ke(s)) {
                const o = {
                    session: null,
                    error: s
                };
                return I0(s) || await this._removeSession(),
                (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(o),
                o
            }
            throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(s),
            s
        } finally {
            this.refreshingDeferred = null,
            this._debug(i, "end")
        }
    }
    async _notifyAllSubscribers(e, n, r=!0) {
        const i = `#_notifyAllSubscribers(${e})`;
        this._debug(i, "begin", n, `broadcast = ${r}`);
        try {
            this.broadcastChannel && r && this.broadcastChannel.postMessage({
                event: e,
                session: n
            });
            const s = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                try {
                    await a.callback(e, n)
                } catch (l) {
                    s.push(l)
                }
            }
            );
            if (await Promise.all(o),
            s.length > 0) {
                for (let a = 0; a < s.length; a += 1)
                    console.error(s[a]);
                throw s[0]
            }
        } finally {
            this._debug(i, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0;
        const n = Object.assign({}, e)
          , r = n.user && n.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !r && n.user && await $o(this.userStorage, this.storageKey + "-user", {
                user: n.user
            });
            const i = Object.assign({}, n);
            delete i.user;
            const s = vv(i);
            await $o(this.storage, this.storageKey, s)
        } else {
            const i = vv(n);
            await $o(this.storage, this.storageKey, i)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        await zi(this.storage, this.storageKey),
        await zi(this.storage, this.storageKey + "-code-verifier"),
        await zi(this.storage, this.storageKey + "-user"),
        this.userStorage && await zi(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && Ar() && window?.removeEventListener && window.removeEventListener("visibilitychange", e)
        } catch (n) {
            console.error("removing visibilitychange callback failed", n)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval( () => this._autoRefreshTokenTick(), Fo);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e),
        setTimeout(async () => {
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async () => {
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async n => {
                            const {data: {session: r}} = n;
                            if (!r || !r.refresh_token || !r.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const i = Math.floor((r.expires_at * 1e3 - e) / Fo);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${i} ticks, a tick lasts ${Fo}ms, refresh threshold is ${Pg} ticks`),
                            i <= Pg && await this._callRefreshToken(r.refresh_token)
                        }
                        )
                    } catch (n) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", n)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof y2)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !Ar() || !window?.addEventListener)
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1),
            window?.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const n = `#_onVisibilityChanged(${e})`;
        this._debug(n, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
                this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, n, r) {
        const i = [`provider=${encodeURIComponent(n)}`];
        if (r?.redirectTo && i.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`),
        r?.scopes && i.push(`scopes=${encodeURIComponent(r.scopes)}`),
        this.flowType === "pkce") {
            const [s,o] = await To(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(s)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            i.push(a.toString())
        }
        if (r?.queryParams) {
            const s = new URLSearchParams(r.queryParams);
            i.push(s.toString())
        }
        return r?.skipBrowserRedirect && i.push(`skip_http_redirect=${r.skipBrowserRedirect}`),
        `${e}?${i.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async n => {
                var r;
                const {data: i, error: s} = n;
                return s ? {
                    data: null,
                    error: s
                } : await Ne(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (r = i?.session) === null || r === void 0 ? void 0 : r.access_token
                })
            }
            )
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async n => {
                var r, i;
                const {data: s, error: o} = n;
                if (o)
                    return {
                        data: null,
                        error: o
                    };
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : {
                    issuer: e.issuer
                })
                  , {data: l, error: c} = await Ne(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (r = s?.session) === null || r === void 0 ? void 0 : r.access_token
                });
                return c ? {
                    data: null,
                    error: c
                } : (e.factorType === "totp" && (!((i = l?.totp) === null || i === void 0) && i.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                {
                    data: l,
                    error: null
                })
            }
            )
        } catch (n) {
            if (ke(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _verify(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async n => {
                    var r;
                    const {data: i, error: s} = n;
                    if (s)
                        return {
                            data: null,
                            error: s
                        };
                    const {data: o, error: a} = await Ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: {
                            code: e.code,
                            challenge_id: e.challengeId
                        },
                        headers: this.headers,
                        jwt: (r = i?.session) === null || r === void 0 ? void 0 : r.access_token
                    });
                    return a ? {
                        data: null,
                        error: a
                    } : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + o.expires_in
                    }, o)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", o),
                    {
                        data: o,
                        error: a
                    })
                }
                )
            } catch (n) {
                if (ke(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async n => {
                    var r;
                    const {data: i, error: s} = n;
                    return s ? {
                        data: null,
                        error: s
                    } : await Ne(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: {
                            channel: e.channel
                        },
                        headers: this.headers,
                        jwt: (r = i?.session) === null || r === void 0 ? void 0 : r.access_token
                    })
                }
                )
            } catch (n) {
                if (ke(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: n, error: r} = await this._challenge({
            factorId: e.factorId
        });
        return r ? {
            data: null,
            error: r
        } : await this._verify({
            factorId: e.factorId,
            challengeId: n.id,
            code: e.code
        })
    }
    async _listFactors() {
        const {data: {user: e}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const r = e?.factors || []
          , i = r.filter(o => o.factor_type === "totp" && o.status === "verified")
          , s = r.filter(o => o.factor_type === "phone" && o.status === "verified");
        return {
            data: {
                all: r,
                totp: i,
                phone: s
            },
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        return this._acquireLock(-1, async () => await this._useSession(async e => {
            var n, r;
            const {data: {session: i}, error: s} = e;
            if (s)
                return {
                    data: null,
                    error: s
                };
            if (!i)
                return {
                    data: {
                        currentLevel: null,
                        nextLevel: null,
                        currentAuthenticationMethods: []
                    },
                    error: null
                };
            const {payload: o} = M0(i.access_token);
            let a = null;
            o.aal && (a = o.aal);
            let l = a;
            ((r = (n = i.user.factors) === null || n === void 0 ? void 0 : n.filter(h => h.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (l = "aal2");
            const d = o.amr || [];
            return {
                data: {
                    currentLevel: a,
                    nextLevel: l,
                    currentAuthenticationMethods: d
                },
                error: null
            }
        }
        ))
    }
    async fetchJwk(e, n={
        keys: []
    }) {
        let r = n.keys.find(a => a.kid === e);
        if (r)
            return r;
        const i = Date.now();
        if (r = this.jwks.keys.find(a => a.kid === e),
        r && this.jwks_cached_at + BL > i)
            return r;
        const {data: s, error: o} = await Ne(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !s.keys || s.keys.length === 0 || (this.jwks = s,
        this.jwks_cached_at = i,
        r = s.keys.find(a => a.kid === e),
        !r) ? null : r
    }
    async getClaims(e, n={}) {
        try {
            let r = e;
            if (!r) {
                const {data: m, error: v} = await this.getSession();
                if (v || !m.session)
                    return {
                        data: null,
                        error: v
                    };
                r = m.session.access_token
            }
            const {header: i, payload: s, signature: o, raw: {header: a, payload: l}} = M0(r);
            n?.allowExpired || s8(s.exp);
            const c = !i.alg || i.alg.startsWith("HS") || !i.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(i.kid, n?.keys ? {
                keys: n.keys
            } : n?.jwks);
            if (!c) {
                const {error: m} = await this.getUser(r);
                if (m)
                    throw m;
                return {
                    data: {
                        claims: s,
                        header: i,
                        signature: o
                    },
                    error: null
                }
            }
            const d = o8(i.alg)
              , h = await crypto.subtle.importKey("jwk", c, d, !0, ["verify"]);
            if (!await crypto.subtle.verify(d, h, o, VL(`${a}.${l}`)))
                throw new zg("Invalid JWT signature");
            return {
                data: {
                    claims: s,
                    header: i,
                    signature: o
                },
                error: null
            }
        } catch (r) {
            if (ke(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
hc.nextInstanceID = 0;
const x8 = hc;
class S8 extends x8 {
    constructor(e) {
        super(e)
    }
}
var k8 = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(d) {
            try {
                c(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                c(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function c(d) {
            d.done ? s(d.value) : i(d.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    }
    )
}
;
class E8 {
    constructor(e, n, r) {
        var i, s, o;
        if (this.supabaseUrl = e,
        this.supabaseKey = n,
        !e)
            throw new Error("supabaseUrl is required.");
        if (!n)
            throw new Error("supabaseKey is required.");
        const a = TL(e)
          , l = new URL(a);
        this.realtimeUrl = new URL("realtime/v1",l),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",l),
        this.storageUrl = new URL("storage/v1",l),
        this.functionsUrl = new URL("functions/v1",l);
        const c = `sb-${l.hostname.split(".")[0]}-auth-token`
          , d = {
            db: _L,
            realtime: SL,
            auth: Object.assign(Object.assign({}, xL), {
                storageKey: c
            }),
            globalThis: bL
        }
          , h = NL(r ?? {}, d);
        this.storageKey = (i = h.auth.storageKey) !== null && i !== void 0 ? i : "",
        this.headers = (s = h.global.headers) !== null && s !== void 0 ? s : {},
        h.accessToken ? (this.accessToken = h.accessToken,
        this.auth = new Proxy({},{
            get: (y, m) => {
                throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(m)} is not possible`)
            }
        })) : this.auth = this._initSupabaseAuthClient((o = h.auth) !== null && o !== void 0 ? o : {}, this.headers, h.global.fetch),
        this.fetch = IL(n, this._getAccessToken.bind(this), h.global.fetch),
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, h.realtime)),
        this.rest = new W5(new URL("rest/v1",l).href,{
            headers: this.headers,
            schema: h.db.schema,
            fetch: this.fetch
        }),
        this.storage = new yL(this.storageUrl.href,this.headers,this.fetch,r?.storage),
        h.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new v5(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(e) {
        return this.rest.from(e)
    }
    schema(e) {
        return this.rest.schema(e)
    }
    rpc(e, n={}, r={}) {
        return this.rest.rpc(e, n, r)
    }
    channel(e, n={
        config: {}
    }) {
        return this.realtime.channel(e, n)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(e) {
        return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    _getAccessToken() {
        var e, n;
        return k8(this, void 0, void 0, function*() {
            if (this.accessToken)
                return yield this.accessToken();
            const {data: r} = yield this.auth.getSession();
            return (n = (e = r.session) === null || e === void 0 ? void 0 : e.access_token) !== null && n !== void 0 ? n : this.supabaseKey
        })
    }
    _initSupabaseAuthClient({autoRefreshToken: e, persistSession: n, detectSessionInUrl: r, storage: i, userStorage: s, storageKey: o, flowType: a, lock: l, debug: c}, d, h) {
        const y = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new S8({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, y), d),
            storageKey: o,
            autoRefreshToken: e,
            persistSession: n,
            detectSessionInUrl: r,
            storage: i,
            userStorage: s,
            flowType: a,
            lock: l,
            debug: c,
            fetch: h,
            hasCustomAuthorizationHeader: "Authorization"in this.headers
        })
    }
    _initRealtimeClient(e) {
        return new iL(this.realtimeUrl.href,Object.assign(Object.assign({}, e), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, e?.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange( (n, r) => {
            this._handleTokenChanged(n, "CLIENT", r?.access_token)
        }
        )
    }
    _handleTokenChanged(e, n, r) {
        (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== r ? this.changedAccessToken = r : e === "SIGNED_OUT" && (this.realtime.setAuth(),
        n == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
const A8 = (t, e, n) => new E8(t,e,n);
function I8() {
    if (typeof window < "u" || typeof process > "u")
        return !1;
    const t = process.version;
    if (t == null)
        return !1;
    const e = t.match(/^v(\d+)\./);
    return e ? parseInt(e[1], 10) <= 18 : !1
}
I8() && console.warn("⚠️  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const M8 = "https://oogphwzqrysxignqsvmd.supabase.co"
  , T8 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9vZ3Bod3pxcnlzeGlnbnFzdm1kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY3OTEyMzEsImV4cCI6MjA3MjM2NzIzMX0.n-DT4EP8H-63akqGbSR7JiwPknMRaDuk_mD5wR7NbOo"
  , N8 = A8(M8, T8)
  , C8 = ({isOpen: t, onClose: e}) => {
    const [n,r] = Y.useState("")
      , [i,s] = Y.useState("")
      , [o,a] = Y.useState(!1)
      , [l,c] = Y.useState(null)
      , d = async h => {
        h.preventDefault(),
        a(!0),
        c(null);
        const {error: y} = await N8.from("launch_signups").insert([{
            name: n,
            email: i
        }]);
        y ? c("❌ " + y.message) : (c("✅ You’re signed up! We’ll notify you at launch 🚀"),
        r(""),
        s("")),
        a(!1)
    }
    ;
    return t ? S.jsx("div", {
        className: "fixed inset-0 bg-black/60 flex items-center justify-center z-50",
        children: S.jsxs("div", {
            className: "bg-white/10 backdrop-blur-lg border border-white/20 rounded-2xl p-8 w-[90%] md:w-[60%] relative",
            children: [S.jsx("button", {
                onClick: e,
                className: "absolute top-4 right-4 text-white",
                children: S.jsx(f5, {
                    className: "w-6 h-6"
                })
            }), S.jsx("h2", {
                className: "text-3xl font-bold text-white mb-4 text-center",
                children: "Get Notified at Launch"
            }), S.jsx("p", {
                className: "text-slate-300 mb-6 text-center",
                children: "Enter your details and be the first to know when Bonkeez NFTs go live."
            }), S.jsxs("form", {
                onSubmit: d,
                className: "space-y-4",
                children: [S.jsx("input", {
                    type: "text",
                    placeholder: "Your Name",
                    value: n,
                    onChange: h => r(h.target.value),
                    className: "w-full px-4 py-3 rounded-lg bg-white/20 text-white placeholder-slate-400 focus:outline-none"
                }), S.jsx("input", {
                    type: "email",
                    placeholder: "Your Email",
                    required: !0,
                    value: i,
                    onChange: h => s(h.target.value),
                    className: "w-full px-4 py-3 rounded-lg bg-white/20 text-white placeholder-slate-400 focus:outline-none"
                }), S.jsx("button", {
                    type: "submit",
                    disabled: o,
                    className: "w-full bg-gradient-to-r from-emerald-600 to-emerald-700 text-white py-3 rounded-lg font-bold hover:from-emerald-700 hover:to-emerald-800 transition",
                    children: o ? "Saving..." : "Notify Me"
                })]
            }), l && S.jsx("p", {
                className: "mt-4 text-center text-sm text-emerald-400",
                children: l
            })]
        })
    }) : null
}
  , R8 = () => {
    const [t,e] = Y.useState("grid")
      , [n,r] = Y.useState("price")
      , [i,s] = Y.useState("")
      , [o,a] = Y.useState(!1)
      , l = [{
        id: 1,
        name: "Bloo Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/bloo-bonkee-1755298715025-223344300.jpeg",
        price: "0.8 SOL",
        bnkzPrice: "720 BNKZ",
        rarity: "Rare",
        totalSupply: 500,
        status: "Coming Soon"
    }, {
        id: 2,
        name: "Yelloo Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/yelloo-bonkee-1755298146545-396548464.jpeg",
        price: "0.5 SOL",
        bnkzPrice: "450 BNKZ",
        rarity: "Common",
        totalSupply: 2e3,
        status: "Coming Soon"
    }, {
        id: 3,
        name: "Redz Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/redz-1755298949640-153157693.jpeg",
        price: "1.2 SOL",
        bnkzPrice: "1,080 BNKZ",
        rarity: "Legendary",
        totalSupply: 100,
        status: "Coming Soon"
    }, {
        id: 4,
        name: "Pinko Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/image-1755299183632-281941757.jpg",
        price: "0.4 SOL",
        bnkzPrice: "360 BNKZ",
        rarity: "Common",
        totalSupply: 2e3,
        status: "Coming Soon"
    }, {
        id: 5,
        name: "Purpo Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/purpo-bonkee-1755299353407-767500589.jpeg",
        price: "0.9 SOL",
        bnkzPrice: "810 BNKZ",
        rarity: "Ultra Rare",
        totalSupply: 250,
        status: "Coming Soon"
    }, {
        id: 6,
        name: "Greeno Bonkee",
        image: "https://cdn.chatandbuild.com/users/689bee88f300c9caf5f9881e/greeno-bonkee-1755299593663-446736790.jpeg",
        price: "0.7 SOL",
        bnkzPrice: "630 BNKZ",
        rarity: "Rare",
        totalSupply: 500,
        status: "Coming Soon"
    }]
      , c = v => {
        switch (v) {
        case "Common":
            return "text-slate-400 bg-slate-400/20";
        case "Uncommon":
            return "text-green-400 bg-green-400/20";
        case "Rare":
            return "text-blue-400 bg-blue-400/20";
        case "Ultra Rare":
            return "text-purple-400 bg-purple-400/20";
        case "Legendary":
            return "text-yellow-400 bg-yellow-400/20";
        default:
            return "text-slate-400 bg-slate-400/20"
        }
    }
      , d = v => {
        v.preventDefault(),
        i && m.length === 0 && alert(`No results found for "${i}"`)
    }
      , h = () => {
        const v = ["All", "Common", "Rare", "Ultra Rare", "Legendary"]
          , E = prompt(`Filter by rarity:
${v.join(", ")}`, "All");
        E && v.includes(E) && s(E === "All" ? "" : E)
    }
      , y = () => {
        alert("This NFT will be available for minting at launch. Stay tuned!")
    }
      , m = l.filter(v => v.name.toLowerCase().includes(i.toLowerCase()) || v.rarity.toLowerCase().includes(i.toLowerCase()));
    return S.jsx("section", {
        id: "marketplace",
        className: "py-20 px-4 sm:px-6 lg:px-8 bg-gradient-to-r from-slate-800/10 to-emerald-900/10",
        children: S.jsxs("div", {
            className: "max-w-7xl mx-auto",
            children: [S.jsxs("div", {
                className: "text-center mb-12",
                children: [S.jsx("h2", {
                    className: "text-4xl lg:text-5xl font-bold text-white mb-6",
                    children: "Marketplace Preview"
                }), S.jsx("p", {
                    className: "text-xl text-slate-300 max-w-3xl mx-auto",
                    children: "Preview the upcoming Bonkeez collection. Launch pricing with 10% discount available with $BNKZ tokens."
                })]
            }), S.jsxs("div", {
                className: "bg-emerald-400/10 border border-emerald-400/20 rounded-2xl p-6 mb-8 text-center",
                children: [S.jsxs("div", {
                    className: "inline-flex items-center bg-emerald-400/20 text-emerald-400 px-4 py-2 rounded-full text-sm font-bold mb-4",
                    children: [S.jsx(s5, {
                        className: "w-4 h-4 mr-2"
                    }), "Pre-Launch Preview"]
                }), S.jsx("p", {
                    className: "text-white text-lg mb-2",
                    children: "Collection launching soon!"
                }), S.jsx("p", {
                    className: "text-slate-300",
                    children: "All NFTs will be available for minting at launch. No items have been minted yet."
                })]
            }), S.jsx("div", {
                className: "bg-white/5 backdrop-blur-sm rounded-2xl p-6 mb-8 border border-white/10",
                children: S.jsxs("div", {
                    className: "flex flex-col lg:flex-row gap-4 items-center justify-between",
                    children: [S.jsxs("form", {
                        onSubmit: d,
                        className: "flex items-center bg-white/10 rounded-lg px-4 py-3 w-full lg:w-96",
                        children: [S.jsx(u5, {
                            className: "w-5 h-5 text-slate-400 mr-3"
                        }), S.jsx("input", {
                            type: "text",
                            placeholder: "Search Bonkeez...",
                            value: i,
                            onChange: v => s(v.target.value),
                            className: "bg-transparent text-white placeholder-slate-400 outline-none flex-1"
                        })]
                    }), S.jsxs("div", {
                        className: "flex items-center space-x-4",
                        children: [S.jsxs("select", {
                            value: n,
                            onChange: v => r(v.target.value),
                            className: "bg-white/10 text-white rounded-lg px-4 py-3 outline-none border border-white/10",
                            children: [S.jsx("option", {
                                value: "price",
                                children: "Price: Low to High"
                            }), S.jsx("option", {
                                value: "price-desc",
                                children: "Price: High to Low"
                            }), S.jsx("option", {
                                value: "rarity",
                                children: "Rarity"
                            }), S.jsx("option", {
                                value: "supply",
                                children: "Supply"
                            })]
                        }), S.jsxs("button", {
                            onClick: h,
                            className: "bg-white/10 text-white px-4 py-3 rounded-lg hover:bg-white/20 transition-colors flex items-center space-x-2 border border-white/10",
                            children: [S.jsx(a5, {
                                className: "w-5 h-5"
                            }), S.jsx("span", {
                                children: "Filter"
                            })]
                        }), S.jsxs("div", {
                            className: "flex bg-white/10 rounded-lg p-1 border border-white/10",
                            children: [S.jsx("button", {
                                onClick: () => e("grid"),
                                className: `p-2 rounded-md transition-colors ${t === "grid" ? "bg-emerald-600 text-white" : "text-slate-400 hover:text-white"}`,
                                children: S.jsx(l5, {
                                    className: "w-5 h-5"
                                })
                            }), S.jsx("button", {
                                onClick: () => e("list"),
                                className: `p-2 rounded-md transition-colors ${t === "list" ? "bg-emerald-600 text-white" : "text-slate-400 hover:text-white"}`,
                                children: S.jsx(c5, {
                                    className: "w-5 h-5"
                                })
                            })]
                        })]
                    })]
                })
            }), S.jsx("div", {
                className: `grid gap-6 ${t === "grid" ? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3" : "grid-cols-1"}`,
                children: m.map(v => S.jsxs("div", {
                    className: `bg-white/5 backdrop-blur-sm rounded-2xl p-6 border border-white/10 hover:scale-105 transition-all group cursor-pointer ${t === "list" ? "flex items-center space-x-6" : ""}`,
                    onClick: y,
                    children: [S.jsxs("div", {
                        className: `relative overflow-hidden rounded-xl ${t === "list" ? "w-24 h-24 flex-shrink-0" : "mb-4"}`,
                        children: [S.jsx("img", {
                            src: v.image,
                            alt: v.name,
                            className: `object-cover group-hover:scale-110 transition-transform duration-300 ${t === "list" ? "w-full h-full" : "w-full h-48"}`
                        }), S.jsxs("div", {
                            className: "absolute top-2 right-2 flex flex-col space-y-1",
                            children: [S.jsx("span", {
                                className: `px-2 py-1 rounded-full text-xs font-bold ${c(v.rarity)}`,
                                children: v.rarity
                            }), S.jsx("span", {
                                className: "px-2 py-1 rounded-full text-xs font-bold bg-emerald-400/20 text-emerald-400",
                                children: v.status
                            })]
                        })]
                    }), S.jsxs("div", {
                        className: `${t === "list" ? "flex-1" : ""}`,
                        children: [S.jsxs("div", {
                            className: `${t === "list" ? "flex items-center justify-between" : "space-y-3"}`,
                            children: [S.jsxs("div", {
                                children: [S.jsx("h3", {
                                    className: "text-xl font-bold text-white mb-1",
                                    children: v.name
                                }), S.jsx("p", {
                                    className: "text-slate-400 text-sm",
                                    children: "Launch Collection"
                                }), t === "grid" && S.jsxs("div", {
                                    className: "flex items-center space-x-2 mt-2",
                                    children: [S.jsx(Gk, {
                                        className: "w-3 h-3 text-slate-400"
                                    }), S.jsx("span", {
                                        className: "text-xs text-emerald-400",
                                        children: "Full Supply Available"
                                    })]
                                })]
                            }), t === "list" && S.jsxs("div", {
                                className: "flex items-center space-x-6",
                                children: [S.jsxs("div", {
                                    className: "text-right",
                                    children: [S.jsx("p", {
                                        className: "text-white font-bold",
                                        children: v.price
                                    }), S.jsx("p", {
                                        className: "text-emerald-400 text-sm",
                                        children: v.bnkzPrice
                                    })]
                                }), S.jsxs("div", {
                                    className: "text-right",
                                    children: [S.jsx("p", {
                                        className: "text-slate-400 text-sm",
                                        children: "Supply"
                                    }), S.jsx("p", {
                                        className: "text-emerald-400 font-medium",
                                        children: v.totalSupply.toLocaleString()
                                    })]
                                }), S.jsxs("div", {
                                    className: "text-right",
                                    children: [S.jsx("p", {
                                        className: "text-slate-400 text-sm",
                                        children: "Status"
                                    }), S.jsx("p", {
                                        className: "text-emerald-400 font-medium",
                                        children: v.status
                                    })]
                                }), S.jsx("button", {
                                    onClick: E => {
                                        E.stopPropagation(),
                                        y()
                                    }
                                    ,
                                    className: "bg-gradient-to-r from-slate-600 to-slate-700 text-white px-6 py-2 rounded-lg font-bold opacity-75 cursor-not-allowed",
                                    children: "Coming Soon"
                                })]
                            })]
                        }), t === "grid" && S.jsxs(S.Fragment, {
                            children: [S.jsxs("div", {
                                className: "bg-white/5 rounded-xl p-3 mb-4 border border-white/10",
                                children: [S.jsxs("div", {
                                    className: "flex justify-between items-center mb-2",
                                    children: [S.jsx("span", {
                                        className: "text-slate-400 text-sm",
                                        children: "Total Supply"
                                    }), S.jsx("span", {
                                        className: "text-emerald-400 text-sm font-medium",
                                        children: "Full Supply Available"
                                    })]
                                }), S.jsxs("div", {
                                    className: "flex justify-between items-center text-xs",
                                    children: [S.jsx("span", {
                                        className: "text-slate-400",
                                        children: "0 minted"
                                    }), S.jsxs("span", {
                                        className: "text-emerald-400",
                                        children: [v.totalSupply.toLocaleString(), " available"]
                                    })]
                                })]
                            }), S.jsxs("div", {
                                className: "bg-white/5 rounded-xl p-4 mb-4 border border-white/10",
                                children: [S.jsxs("div", {
                                    className: "flex justify-between items-center mb-2",
                                    children: [S.jsx("span", {
                                        className: "text-slate-400 text-sm",
                                        children: "Launch Price"
                                    }), S.jsx("span", {
                                        className: "text-emerald-400 text-sm",
                                        children: "10% off with $BNKZ"
                                    })]
                                }), S.jsxs("div", {
                                    className: "space-y-1",
                                    children: [S.jsxs("div", {
                                        className: "flex justify-between items-center",
                                        children: [S.jsx("span", {
                                            className: "text-white font-bold text-lg",
                                            children: v.price
                                        }), S.jsx("span", {
                                            className: "text-slate-400 text-sm",
                                            children: "SOL"
                                        })]
                                    }), S.jsxs("div", {
                                        className: "flex justify-between items-center",
                                        children: [S.jsx("span", {
                                            className: "text-emerald-400 font-bold",
                                            children: v.bnkzPrice
                                        }), S.jsx("span", {
                                            className: "text-emerald-400 text-sm",
                                            children: "$BNKZ"
                                        })]
                                    })]
                                })]
                            }), S.jsx("button", {
                                onClick: E => {
                                    E.stopPropagation(),
                                    y()
                                }
                                ,
                                className: "w-full bg-gradient-to-r from-slate-600 to-slate-700 text-white py-3 rounded-xl font-bold opacity-75 cursor-not-allowed",
                                children: "Coming Soon"
                            })]
                        })]
                    })]
                }, v.id))
            }), m.length === 0 && S.jsxs("div", {
                className: "text-center py-12",
                children: [S.jsx("p", {
                    className: "text-slate-400 text-lg mb-4",
                    children: "No Bonkeez found matching your search."
                }), S.jsx("button", {
                    onClick: () => s(""),
                    className: "text-emerald-400 hover:text-emerald-300 transition-colors",
                    children: "Clear search"
                })]
            }), S.jsx("div", {
                className: "text-center mt-12",
                children: S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-2xl p-8 border border-white/10 max-w-2xl mx-auto",
                    children: [S.jsx("h3", {
                        className: "text-2xl font-bold text-white mb-4",
                        children: "Ready for Launch"
                    }), S.jsx("p", {
                        className: "text-slate-300 mb-6",
                        children: "All 5,350 Bonkeez NFTs will be available for minting at launch. Be ready to secure your favorite characters!"
                    }), S.jsxs("button", {
                        onClick: () => a(!0),
                        className: "bg-gradient-to-r from-emerald-600 to-emerald-700 text-white px-8 py-4 rounded-xl font-bold hover:from-emerald-700 hover:to-emerald-800 transition-all shadow-lg hover:shadow-emerald-500/25 flex items-center justify-center space-x-2 mx-auto",
                        children: [S.jsx(r5, {
                            className: "w-5 h-5"
                        }), S.jsx("span", {
                            children: "Get Notified at Launch"
                        })]
                    }), S.jsx(C8, {
                        isOpen: o,
                        onClose: () => a(!1)
                    })]
                })
            })]
        })
    })
}
  , L8 = () => {
    const t = r => {
        const s = {
            twitter: "https://x.com/abonkcommunity?s=21",
            telegram: "https://t.me/+Mh9YQsnnRcZlNWFh"
        }[r];
        s && window.open(s, "_blank", "noopener,noreferrer")
    }
      , e = r => {
        if (r === "privacy" || r === "terms")
            alert(`${r.charAt(0).toUpperCase() + r.slice(1)} page coming soon!`);
        else {
            const i = document.getElementById(r);
            i && i.scrollIntoView({
                behavior: "smooth"
            })
        }
    }
      , n = () => {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
    ;
    return S.jsx("footer", {
        className: "bg-black/40 backdrop-blur-md border-t border-white/10",
        children: S.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12",
            children: [S.jsxs("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8",
                children: [S.jsxs("div", {
                    className: "space-y-4",
                    children: [S.jsxs("button", {
                        onClick: n,
                        className: "flex items-center space-x-2 hover:opacity-80 transition-opacity duration-150",
                        children: [S.jsx("img", {
                            src: "/bonk.JPG",
                            alt: "Bonkeez Logo",
                            className: "w-10 h-10 rounded-full object-cover shadow-lg border-2 border-emerald-500/30"
                        }), S.jsxs("div", {
                            children: [S.jsx("h3", {
                                className: "text-white font-bold text-xl",
                                children: "Bonkeez"
                            }), S.jsx("p", {
                                className: "text-slate-400 text-xs",
                                children: "NFT Exchange"
                            })]
                        })]
                    }), S.jsx("p", {
                        className: "text-slate-300 text-sm",
                        children: "The premier NFT marketplace for the Bonkeez collection on Solana. Trade with $BNKZ tokens and unlock exclusive benefits."
                    }), S.jsxs("div", {
                        className: "flex space-x-4",
                        children: [S.jsx("button", {
                            onClick: () => t("twitter"),
                            className: "text-slate-400 hover:text-emerald-400 transition-colors duration-150",
                            children: S.jsx(eh, {
                                className: "w-5 h-5"
                            })
                        }), S.jsx("button", {
                            onClick: () => t("telegram"),
                            className: "text-slate-400 hover:text-emerald-400 transition-colors duration-150",
                            children: S.jsx(Xd, {
                                className: "w-5 h-5"
                            })
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "space-y-4",
                    children: [S.jsx("h4", {
                        className: "text-white font-bold text-lg",
                        children: "Navigation"
                    }), S.jsxs("nav", {
                        className: "space-y-2",
                        children: [S.jsx("button", {
                            onClick: () => e("marketplace"),
                            className: "block text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: "Marketplace"
                        }), S.jsx("button", {
                            onClick: () => e("stats"),
                            className: "block text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: "Stats"
                        }), S.jsx("button", {
                            onClick: () => e("minting"),
                            className: "block text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: "NFT Minting"
                        }), S.jsx("button", {
                            onClick: () => e("profile"),
                            className: "block text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: "Profile"
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "space-y-4",
                    children: [S.jsx("h4", {
                        className: "text-white font-bold text-lg",
                        children: "$BNKZ Token"
                    }), S.jsxs("nav", {
                        className: "space-y-2",
                        children: [S.jsx("button", {
                            onClick: () => e("token"),
                            className: "block text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: "$BNKZ Trading"
                        }), S.jsxs("a", {
                            href: "/Bonkeez Whitepaper (1).pdf",
                            download: !0,
                            className: "flex items-center space-x-2 text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: [S.jsx(GR, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "Whitepaper"
                            })]
                        })]
                    })]
                }), S.jsxs("div", {
                    className: "space-y-4",
                    children: [S.jsx("h4", {
                        className: "text-white font-bold text-lg",
                        children: "Community"
                    }), S.jsxs("nav", {
                        className: "space-y-2",
                        children: [S.jsxs("button", {
                            onClick: () => t("telegram"),
                            className: "flex items-center space-x-2 text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: [S.jsx(Xd, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "Join Telegram"
                            })]
                        }), S.jsxs("button", {
                            onClick: () => t("twitter"),
                            className: "flex items-center space-x-2 text-slate-400 hover:text-emerald-400 transition-colors duration-150 text-sm",
                            children: [S.jsx(eh, {
                                className: "w-4 h-4"
                            }), S.jsx("span", {
                                children: "Follow Twitter"
                            })]
                        })]
                    })]
                })]
            }), S.jsx("div", {
                className: "border-t border-white/10 mt-12 pt-8",
                children: S.jsxs("div", {
                    className: "flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0",
                    children: [S.jsxs("div", {
                        className: "flex items-center space-x-6 text-sm text-slate-400",
                        children: [S.jsx("span", {
                            children: "© 2025 Bonkeez NFT Exchange"
                        }), S.jsx("button", {
                            onClick: () => e("privacy"),
                            className: "hover:text-emerald-400 transition-colors duration-150",
                            children: "Privacy Policy"
                        }), S.jsx("button", {
                            onClick: () => e("terms"),
                            className: "hover:text-emerald-400 transition-colors duration-150",
                            children: "Terms of Service"
                        })]
                    }), S.jsxs("div", {
                        className: "flex items-center space-x-4 text-sm",
                        children: [S.jsx("span", {
                            className: "text-slate-400",
                            children: "Built on"
                        }), S.jsxs("div", {
                            className: "flex items-center space-x-2",
                            children: [S.jsx("div", {
                                className: "w-6 h-6 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center",
                                children: S.jsx("span", {
                                    className: "text-white font-bold text-xs",
                                    children: "S"
                                })
                            }), S.jsx("span", {
                                className: "text-emerald-400 font-medium",
                                children: "Solana"
                            })]
                        })]
                    })]
                })
            })]
        })
    })
}
  , j8 = () => {
    if (typeof window < "u") {
        const {protocol: t, hostname: e, href: n} = window.location;
        t !== "https:" && e !== "localhost" && e !== "127.0.0.1" && !e.includes("192.168.") && !e.includes("10.0.") && !e.includes("172.") && window.location.replace(`https:${n.substring(t.length)}`)
    }
}
  , w2 = () => {
    if (typeof window < "u") {
        const {hostname: t, protocol: e} = window.location
          , n = t === "localhost" || t === "127.0.0.1" || t.includes("192.168.") || t.includes("10.0.") || t.includes("172.");
        return window.isSecureContext || n || e === "https:"
    }
    return !0
}
  , B8 = () => {
    if (typeof window > "u")
        return !0;
    const {hostname: t, protocol: e} = window.location
      , n = t === "localhost" || t === "127.0.0.1" || t.includes("192.168.") || t.includes("10.0.") || t.includes("172.")
      , r = e === "https:" && (t === "www.bonkeez.com" || t === "bonkeez.com");
    return w2() && (n || r)
}
  , P8 = () => {
    j8(),
    typeof document < "u" && [{
        name: "referrer",
        content: "strict-origin-when-cross-origin"
    }, {
        "http-equiv": "X-Content-Type-Options",
        content: "nosniff"
    }, {
        "http-equiv": "X-Frame-Options",
        content: "DENY"
    }, {
        "http-equiv": "X-XSS-Protection",
        content: "1; mode=block"
    }].forEach(e => {
        if (!document.querySelector(`meta[name="${e.name}"], meta[http-equiv="${e["http-equiv"]}"]`)) {
            const r = document.createElement("meta");
            e.name && r.setAttribute("name", e.name),
            e["http-equiv"] && r.setAttribute("http-equiv", e["http-equiv"]),
            r.setAttribute("content", e.content),
            document.head.appendChild(r)
        }
    }
    )
}
  , O8 = () => {
    const [t,e] = Y.useState({
        isSecure: !0,
        isWalletReady: !0,
        showWarning: !1,
        showSuccess: !1
    });
    return Y.useEffect( () => {
        P8();
        const n = () => {
            const i = w2()
              , s = B8()
              , o = window.location.hostname.includes("bonkeez.com")
              , a = window.location.protocol === "https:";
            e({
                isSecure: i,
                isWalletReady: s,
                showWarning: o && !a,
                showSuccess: o && a && i && s
            })
        }
        ;
        n();
        const r = setTimeout(n, 1e3);
        return () => clearTimeout(r)
    }
    , []),
    t.showSuccess ? S.jsx("div", {
        className: "fixed top-20 left-4 right-4 z-50 max-w-md mx-auto",
        children: S.jsx("div", {
            className: "bg-green-500/20 border border-green-500/30 rounded-lg p-4 backdrop-blur-sm",
            children: S.jsxs("div", {
                className: "flex items-start space-x-3",
                children: [S.jsx(i5, {
                    className: "w-5 h-5 text-green-400 mt-0.5 flex-shrink-0"
                }), S.jsxs("div", {
                    className: "flex-1",
                    children: [S.jsx("h3", {
                        className: "text-green-400 font-medium text-sm mb-1",
                        children: "Secure Connection"
                    }), S.jsx("p", {
                        className: "text-green-300 text-xs mb-3",
                        children: "Your connection is secure. Wallet operations are fully protected."
                    }), S.jsx("button", {
                        onClick: () => e(n => ({
                            ...n,
                            showSuccess: !1
                        })),
                        className: "text-green-400 hover:text-green-300 text-xs underline cursor-pointer",
                        children: "Dismiss"
                    })]
                })]
            })
        })
    }) : t.showWarning ? S.jsx("div", {
        className: "fixed top-20 left-4 right-4 z-50 max-w-md mx-auto",
        children: S.jsx("div", {
            className: "bg-red-500/20 border border-red-500/30 rounded-lg p-4 backdrop-blur-sm",
            children: S.jsxs("div", {
                className: "flex items-start space-x-3",
                children: [S.jsx(e5, {
                    className: "w-5 h-5 text-red-400 mt-0.5 flex-shrink-0"
                }), S.jsxs("div", {
                    className: "flex-1",
                    children: [S.jsx("h3", {
                        className: "text-red-400 font-medium text-sm mb-1",
                        children: "Insecure Connection"
                    }), S.jsx("p", {
                        className: "text-red-300 text-xs mb-3",
                        children: "This site is not served over HTTPS. Redirecting to secure connection..."
                    }), S.jsxs("div", {
                        className: "flex items-center space-x-2",
                        children: [S.jsx("button", {
                            onClick: () => e(n => ({
                                ...n,
                                showWarning: !1
                            })),
                            className: "text-red-400 hover:text-red-300 text-xs underline cursor-pointer",
                            children: "Dismiss"
                        }), S.jsxs("a", {
                            href: "https://www.bonkeez.com",
                            className: "flex items-center space-x-1 text-red-400 hover:text-red-300 text-xs underline",
                            children: [S.jsx("span", {
                                children: "Go to HTTPS"
                            }), S.jsx(Mg, {
                                className: "w-3 h-3"
                            })]
                        })]
                    })]
                })]
            })
        })
    }) : null
}
  , D8 = () => {
    const [t,e] = Y.useState("")
      , [n,r] = Y.useState("")
      , [i,s] = Y.useState("SOL")
      , [o,a] = Y.useState("BNKZ")
      , [l,c] = Y.useState("0.5")
      , [d,h] = Y.useState(null);
    Y.useEffect( () => {
        const A = async () => {
            const x = await Iy();
            h(x)
        }
        ;
        A();
        const _ = setInterval(A, 3e4);
        return () => clearInterval(_)
    }
    , []);
    const y = () => {
        s(o),
        a(i),
        e(n),
        r(t)
    }
      , m = () => {
        window.open(Vk(), "_blank", "noopener,noreferrer")
    }
      , v = () => {
        const A = document.querySelector(".wallet-adapter-button");
        A && A.click()
    }
      , E = () => {
        alert("Advanced trading settings coming soon! This will include custom slippage, MEV protection, and more.")
    }
    ;
    return Y.useEffect( () => {
        if (t && i === "SOL" && o === "BNKZ") {
            const A = parseFloat(t);
            if (!isNaN(A)) {
                const _ = (A * 900).toFixed(0);
                r(_)
            }
        } else if (t && i === "BNKZ" && o === "SOL") {
            const A = parseFloat(t);
            if (!isNaN(A)) {
                const _ = (A / 900).toFixed(4);
                r(_)
            }
        }
    }
    , [t, i, o]),
    S.jsx("section", {
        id: "token",
        className: "py-20 px-4 sm:px-6 lg:px-8 bg-gradient-to-r from-slate-800/20 to-emerald-900/20",
        children: S.jsxs("div", {
            className: "max-w-7xl mx-auto",
            children: [S.jsxs("div", {
                className: "text-center mb-16",
                children: [S.jsxs("div", {
                    className: "inline-flex items-center bg-emerald-400/20 text-emerald-400 px-6 py-3 rounded-full text-lg font-bold mb-6",
                    children: [S.jsx(jl, {
                        className: "w-5 h-5 mr-2"
                    }), "$BNKZ Token Trading"]
                }), S.jsx("h2", {
                    className: "text-4xl lg:text-5xl font-bold text-white mb-6",
                    children: "Trade $BNKZ Token"
                }), S.jsx("p", {
                    className: "text-xl text-slate-300 max-w-3xl mx-auto",
                    children: "Swap SOL for $BNKZ tokens and unlock exclusive benefits in the Bonkeez ecosystem"
                })]
            }), S.jsxs("div", {
                className: "grid lg:grid-cols-2 gap-8 lg:gap-12 items-start",
                children: [S.jsxs("div", {
                    className: "bg-white/5 backdrop-blur-sm rounded-3xl p-4 sm:p-6 lg:p-8 border border-white/10",
                    children: [S.jsxs("div", {
                        className: "flex items-center justify-between mb-6",
                        children: [S.jsx("h3", {
                            className: "text-2xl font-bold text-white",
                            children: "Swap Tokens"
                        }), S.jsx("button", {
                            onClick: E,
                            className: "text-slate-400 hover:text-emerald-400 transition-colors",
                            children: S.jsx(d5, {
                                className: "w-6 h-6"
                            })
                        })]
                    }), S.jsxs("div", {
                        className: "bg-white/5 rounded-2xl p-4 sm:p-6 mb-4 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:justify-between sm:items-center mb-3 space-y-1 sm:space-y-0",
                            children: [S.jsx("span", {
                                className: "text-slate-400 text-sm",
                                children: "From"
                            }), S.jsx("button", {
                                onClick: v,
                                className: "text-slate-400 text-sm hover:text-emerald-400 transition-colors text-left sm:text-right",
                                children: "Balance: Connect Wallet"
                            })]
                        }), S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4",
                            children: [S.jsx("input", {
                                type: "number",
                                value: t,
                                onChange: A => e(A.target.value),
                                placeholder: "0.0",
                                className: "bg-transparent text-white text-xl sm:text-2xl font-bold outline-none flex-1 min-w-0"
                            }), S.jsxs("div", {
                                className: "flex items-center bg-white/10 rounded-lg px-3 sm:px-4 py-2 space-x-2 shrink-0",
                                children: [S.jsx("div", {
                                    className: "w-5 h-5 sm:w-6 sm:h-6 bg-gradient-to-r from-slate-600 to-slate-700 rounded-full flex items-center justify-center",
                                    children: S.jsx("span", {
                                        className: "text-white font-bold text-xs",
                                        children: "S"
                                    })
                                }), S.jsx("span", {
                                    className: "text-white font-bold text-sm sm:text-base",
                                    children: i
                                })]
                            })]
                        })]
                    }), S.jsx("div", {
                        className: "flex justify-center mb-4",
                        children: S.jsx("button", {
                            onClick: y,
                            className: "bg-white/10 hover:bg-white/20 rounded-full p-3 transition-colors border border-white/20",
                            children: S.jsx(n5, {
                                className: "w-6 h-6 text-white"
                            })
                        })
                    }), S.jsxs("div", {
                        className: "bg-white/5 rounded-2xl p-4 sm:p-6 mb-6 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:justify-between sm:items-center mb-3 space-y-1 sm:space-y-0",
                            children: [S.jsx("span", {
                                className: "text-slate-400 text-sm",
                                children: "To"
                            }), S.jsx("button", {
                                onClick: v,
                                className: "text-slate-400 text-sm hover:text-emerald-400 transition-colors text-left sm:text-right",
                                children: "Balance: Connect Wallet"
                            })]
                        }), S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4",
                            children: [S.jsx("input", {
                                type: "number",
                                value: n,
                                onChange: A => r(A.target.value),
                                placeholder: "0.0",
                                className: "bg-transparent text-white text-xl sm:text-2xl font-bold outline-none flex-1 min-w-0"
                            }), S.jsxs("div", {
                                className: "flex items-center bg-emerald-400/20 rounded-lg px-3 sm:px-4 py-2 space-x-2 shrink-0",
                                children: [S.jsx("div", {
                                    className: "w-5 h-5 sm:w-6 sm:h-6 bg-gradient-to-r from-emerald-600 to-emerald-700 rounded-full flex items-center justify-center",
                                    children: S.jsx("span", {
                                        className: "text-white font-bold text-xs",
                                        children: "B"
                                    })
                                }), S.jsx("span", {
                                    className: "text-emerald-400 font-bold text-sm sm:text-base",
                                    children: o
                                })]
                            })]
                        })]
                    }), S.jsxs("div", {
                        className: "bg-white/5 rounded-2xl p-4 mb-6 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:justify-between sm:items-center mb-3 space-y-3 sm:space-y-0",
                            children: [S.jsx("span", {
                                className: "text-white font-medium text-sm sm:text-base",
                                children: "Slippage Tolerance"
                            }), S.jsx("div", {
                                className: "flex space-x-2",
                                children: ["0.1", "0.5", "1.0"].map(A => S.jsxs("button", {
                                    onClick: () => c(A),
                                    className: `px-3 py-1 rounded-lg text-sm font-medium transition-colors ${l === A ? "bg-emerald-600 text-white" : "bg-white/10 text-slate-400 hover:text-white"}`,
                                    children: [A, "%"]
                                }, A))
                            })]
                        }), S.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:justify-between text-sm space-y-1 sm:space-y-0",
                            children: [S.jsx("span", {
                                className: "text-slate-400",
                                children: "Price Impact"
                            }), S.jsx("button", {
                                onClick: v,
                                className: "text-emerald-400 hover:text-emerald-300 transition-colors text-left sm:text-right",
                                children: "Connect wallet to see"
                            })]
                        })]
                    }), S.jsx("button", {
                        onClick: () => {
                            if (!t) {
                                alert("Please enter an amount to swap");
                                return
                            }
                            confirm(`Swap ${t} ${i} for ${n} ${o}?`) && alert("Swap executed successfully! (Demo mode)")
                        }
                        ,
                        className: "w-full bg-gradient-to-r from-emerald-600 to-emerald-700 text-white py-3 sm:py-4 rounded-xl font-bold hover:from-emerald-700 hover:to-emerald-800 transition-all shadow-lg hover:shadow-emerald-500/25 mb-2 text-sm sm:text-base",
                        children: "Execute Swap"
                    }), S.jsx("button", {
                        onClick: m,
                        className: "w-full bg-gradient-to-r from-slate-600 to-slate-700 text-white py-2 sm:py-3 rounded-xl font-medium hover:from-slate-700 hover:to-slate-800 transition-all text-sm sm:text-base",
                        children: "Or Trade on Pumpfun"
                    }), S.jsx("p", {
                        className: "text-slate-400 text-xs sm:text-sm text-center mt-4",
                        children: "Trading redirects to Pumpfun platform for secure transactions"
                    })]
                }), S.jsxs("div", {
                    className: "space-y-4 sm:space-y-6 mt-8 lg:mt-0",
                    children: [S.jsxs("div", {
                        className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex items-center space-x-3 mb-4",
                            children: [S.jsx("div", {
                                className: "w-12 h-12 bg-gradient-to-r from-emerald-600 to-emerald-700 rounded-lg flex items-center justify-center shadow-lg",
                                children: S.jsx(Hk, {
                                    className: "w-6 h-6 text-white"
                                })
                            }), S.jsxs("div", {
                                children: [S.jsx("h4", {
                                    className: "text-white font-bold text-lg",
                                    children: "NFT Discounts"
                                }), S.jsx("p", {
                                    className: "text-slate-400 text-sm",
                                    children: "Save 10% on all NFT purchases"
                                })]
                            })]
                        }), S.jsx("p", {
                            className: "text-slate-300",
                            children: "Use $BNKZ tokens to get exclusive discounts when buying Bonkeez NFTs on our marketplace."
                        })]
                    }), S.jsxs("div", {
                        className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex items-center space-x-3 mb-4",
                            children: [S.jsx("div", {
                                className: "w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-r from-slate-600 to-slate-700 rounded-lg flex items-center justify-center shadow-lg",
                                children: S.jsx(o5, {
                                    className: "w-5 h-5 sm:w-6 sm:h-6 text-white"
                                })
                            }), S.jsxs("div", {
                                children: [S.jsx("h4", {
                                    className: "text-white font-bold text-base sm:text-lg",
                                    children: "Staking Rewards"
                                }), S.jsx("p", {
                                    className: "text-slate-400 text-xs sm:text-sm",
                                    children: "Earn passive income"
                                })]
                            })]
                        }), S.jsx("p", {
                            className: "text-slate-300 text-sm sm:text-base",
                            children: "Stake your $BNKZ tokens to earn rewards and participate in the ecosystem governance."
                        })]
                    }), S.jsxs("div", {
                        className: "bg-white/5 backdrop-blur-sm rounded-2xl p-4 sm:p-6 border border-white/10",
                        children: [S.jsxs("div", {
                            className: "flex items-center space-x-3 mb-4",
                            children: [S.jsx("div", {
                                className: "w-12 h-12 bg-gradient-to-r from-emerald-600 to-slate-600 rounded-lg flex items-center justify-center shadow-lg",
                                children: S.jsx(qk, {
                                    className: "w-6 h-6 text-white"
                                })
                            }), S.jsxs("div", {
                                children: [S.jsx("h4", {
                                    className: "text-white font-bold text-lg",
                                    children: "Exclusive Access"
                                }), S.jsx("p", {
                                    className: "text-slate-400 text-sm",
                                    children: "VIP member benefits"
                                })]
                            })]
                        }), S.jsx("p", {
                            className: "text-slate-300",
                            children: "Get early access to new drops, exclusive events, and premium features in the Bonkeez ecosystem."
                        })]
                    }), S.jsxs("div", {
                        className: "grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4",
                        children: [S.jsxs("div", {
                            className: "bg-gradient-to-br from-emerald-500/10 to-slate-600/10 rounded-xl p-3 sm:p-4 border border-emerald-400/20",
                            children: [S.jsx("p", {
                                className: "text-emerald-400 text-xs sm:text-sm font-medium",
                                children: "Current Price"
                            }), S.jsx("p", {
                                className: "text-white text-lg sm:text-xl font-bold",
                                children: d?.price || "$0.0001"
                            }), S.jsxs("p", {
                                className: `text-xs ${(d?.change24h || 0) >= 0 ? "text-emerald-400" : "text-red-400"}`,
                                children: [d?.change24h ? `${d.change24h >= 0 ? "+" : ""}${d.change24h.toFixed(1)}%` : "+0.0%", " (24h)"]
                            })]
                        }), S.jsxs("div", {
                            className: "bg-white/5 rounded-xl p-3 sm:p-4 border border-white/10",
                            children: [S.jsx("p", {
                                className: "text-slate-400 text-xs sm:text-sm font-medium",
                                children: "Market Cap"
                            }), S.jsx("p", {
                                className: "text-white text-lg sm:text-xl font-bold",
                                children: d?.marketCap || "$100K"
                            }), S.jsx("p", {
                                className: "text-slate-400 text-xs",
                                children: "Fully Diluted"
                            })]
                        })]
                    })]
                })]
            })]
        })
    })
}
;
function z8() {
    const [t,e] = Y.useState(!0);
    return Y.useEffect( () => {
        const n = setTimeout( () => {
            e(!1)
        }
        , 1e3);
        return () => clearTimeout(n)
    }
    , []),
    t ? S.jsx("div", {
        className: "min-h-screen bg-gradient-to-br from-purple-600 via-pink-500 to-blue-600 flex items-center justify-center",
        children: S.jsxs("div", {
            className: "text-center",
            children: [S.jsx("div", {
                className: "animate-spin rounded-full h-16 w-16 border-b-2 border-emerald-400 mx-auto mb-4"
            }), S.jsx("h2", {
                className: "text-white text-xl font-bold",
                children: "Loading Bonkeez Exchange..."
            }), S.jsx("p", {
                className: "text-slate-400 mt-2",
                children: "Preparing your NFT marketplace experience"
            })]
        })
    }) : S.jsxs("div", {
        className: "min-h-screen bg-gradient-to-br from-purple-600 via-pink-500 to-blue-600",
        children: [S.jsx(O8, {}), S.jsx(ZR, {}), S.jsxs("main", {
            children: [S.jsx(p5, {}), S.jsx(g5, {}), S.jsx(D8, {}), S.jsx(R8, {}), S.jsx("section", {
                id: "profile",
                className: "py-16 px-4 sm:px-6 lg:px-8",
                children: S.jsx("div", {
                    className: "max-w-4xl mx-auto",
                    children: S.jsxs("div", {
                        className: "text-center mb-12",
                        children: [S.jsx("h2", {
                            className: "text-4xl lg:text-5xl font-bold text-white mb-4",
                            children: "Your Profile"
                        }), S.jsx("p", {
                            className: "text-xl text-slate-300",
                            children: "Connect your wallet to view your NFTs, $BNKZ balance, and portfolio stats"
                        })]
                    })
                })
            })]
        }), S.jsx(L8, {})]
    })
}
typeof window < "u" && (window.Buffer = pe.Buffer);
const U8 = document.getElementById("root")
  , W8 = C0.createRoot(U8);
W8.render(S.jsx(J.StrictMode, {
    children: S.jsx(zR, {
        children: S.jsx(z8, {})
    })
}));
export {ne as P, Be as T, oc as V, H8 as b, Me as c, ho as g};